<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YokumiのBlog</title>
  
  <subtitle>Here&#39;s an Yokumi...</subtitle>
  <link href="https://blog.yokumi.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.yokumi.cn/"/>
  <updated>2025-05-11T11:51:33.386Z</updated>
  <id>https://blog.yokumi.cn/</id>
  
  <author>
    <name>Yokumi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo博客的一些进阶配置</title>
    <link href="https://blog.yokumi.cn/2025/05/11/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.yokumi.cn/2025/05/11/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE/</id>
    <published>2025-05-11T11:51:33.000Z</published>
    <updated>2025-05-11T11:51:33.386Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>一些有关Game Theory(博弈论)的学习记录</title>
    <link href="https://blog.yokumi.cn/2025/04/05/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Game%20Theory(%E5%8D%9A%E5%BC%88%E8%AE%BA)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.yokumi.cn/2025/04/05/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Game%20Theory(%E5%8D%9A%E5%BC%88%E8%AE%BA)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2025-04-05T08:22:00.000Z</published>
    <updated>2025-05-10T12:17:54.193Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：</p><blockquote><p>以下是笔者学习<a href="https://www.bilibili.com/video/BV1xY411Y7Wj/">【耶鲁大学】博弈论</a> 课程中整理的内容，因为笔者实在是懒的自己找书啃。有些内容可能结合自己的研究方向（Multiple-Agent-System）简单拓展；至于数模感觉能用到的几率比较小。</p></blockquote><h1>一、Prisoner’s Dilemma 囚徒困境</h1><h2 id="1-1-四个重要结论">1.1 四个重要结论</h2><p><strong>定义 1.1</strong>：<strong>Strictly Dominant Strategy 严格优势策略</strong></p><blockquote><p>假如策略$\alpha$在无论对手选择何种应对的情况下的收益都高于策略$\beta$，则称策略$\alpha$为相对$\beta$的严格优势策略；</p></blockquote><p><strong>结论 1.1</strong>：<strong>不要使用严格劣势策略</strong></p><blockquote><p>我们假设参与博弈的行为人都是理性的（和经济学中定义的理想经济人类似），都希望追求更高的收益（当前，每个人衡量收益大小的标准有不同，对收益的看法显然也会影响决策）；</p></blockquote><p><strong>结论 1.2</strong>：<strong>理性的选择可能导致更糟的结果</strong></p><blockquote><p>显然，如果双方均追求对于个人收益的最大化，可能导致双输；</p></blockquote><p><strong>如何破解囚徒困境？</strong></p><blockquote><p>沟通并不能解决这个困境，在缺乏强制力介入的情况下，沟通缺乏意义，可能有效的方式是有强制力的合同（比如书面合同）、重复博弈、教育。</p></blockquote><p><strong>结论 1.3</strong>：<strong>如欲得之，必先知之 If you want to get it, you must know it first</strong></p><blockquote><p>如果我们不知道一个人或一场博弈中的收益情况，那么我们就不可能获得收益；</p></blockquote><p><strong>结论 1.4</strong>：<strong>换位思考 Put yourself  in others’ shoes and try to figure out what they’ll do</strong></p><blockquote><p>假如我们知道另一方的收益情况，那么如果我们确认对方会根据 <strong>结论 1.1</strong> 选择某种策略，那么我们可以根据对方的选择选择对于自己收益更高的那种，即使站在自己的角度，并没有严格优势策略；</p></blockquote><h2 id="1-2-Grade-Game-积分游戏">1.2 Grade Game 积分游戏</h2><p>关于耶鲁大学《博弈论》课程上的积分游戏的具体推导见下，懒地打了。。。<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/Page1.png" alt=""><br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/Page2.png" alt=""></p><h2 id="1-3-Ingredients-of-a-game-博弈的要素">1.3 Ingredients of a game 博弈的要素</h2><ul><li><strong>Players 参与者</strong>；</li><li><strong>Strategies 策略</strong>；<ul><li>$s_i$:  $Player_i$的某个特定策略；</li><li>$S_i$: $Player_i$的策略集合；</li><li>$S$: 一次博弈，即所有参与者的策略组合；</li></ul></li><li><strong>Payoff 收益</strong>；</li><li><strong>Assumption 假设</strong>：每个参与者都知道其他人的可能策略和收益，即博弈者之间信息透明；</li><li>$S_{-i}$: 一次博弈中除了$Player_i$之外的其他所有参与者的策略；</li></ul><p>定义符号后，我们给出更严格的严格优势策略的定义：</p><p><strong>定义 1.1 Plus</strong>：<strong>Strictly Dominant Strategy 严格优势策略</strong></p><blockquote><p>$Player_i$'s strategy $S’<em>i$ is strictly dominated by $Player_i$'s strategy $S_i$ if $U_i(S_i, S</em>{-i}) &gt; U_i(S’<em>i, S</em>{-i})$ for all $S_{-i}$；</p></blockquote><h2 id="1-4-Hannibal-汉尼拔">1.4 Hannibal 汉尼拔</h2><p>Ben教授通过汉尼拔进军罗马的例子，引入了弱优势策略，弱优势策略允许了一部分策略组下收益相等而不是严格大于；</p><p><strong>定义 1.1 Extension</strong>：<strong>Weakly Dominant Strategy 弱优势策略</strong></p><blockquote><p>$Player_i$'s strategy $S’<em>i$ is weakly dominated by $Player_i$'s strategy $S_i$ if $U_i(S_i, S</em>{-i}) \ge U_i(S’<em>i, S</em>{-i})$ for all $S_{-i}$, and $U_i(S_i, S_{-i}) &gt; U_i(S’<em>i, S</em>{-i})$ for some $S_{-i}$;</p></blockquote><p>关于汉尼拔的具体推导见下：<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/%E7%AC%94%E8%AE%B0%202025%E5%B9%B44%E6%9C%8815%E6%97%A5%20(2).png" alt=""></p><h2 id="1-5-Iterative-Deletion-迭代剔除劣势策略">1.5 Iterative Deletion 迭代剔除劣势策略</h2><p>该策略要求参与者首先找到所有劣势策略，剔除它们，然后再重新审视整个博弈，如此往复。一个具体的例子如下：</p><p>每人选择一个1到100之间的数字，谁选的数字最接近平均数的三分之二，则获得胜利。</p><p><strong>第一层</strong>：</p><blockquote><p>假设大家选取的数字是在 0 ～ 100 间随机分布的，那么 average 约等于50，50的2/3应该是33左右；但是问题也很明显，大家不会都进行随机选择；</p></blockquote><p><strong>第二层</strong>：</p><blockquote><p>我认为别人都按照第一层的思路进行思考，即大部分人都会选择33，那么我应该选择 33 * 2/3 = 22；</p></blockquote><p><strong>第三层</strong>：</p><blockquote><p>从这一层开始，使用了博弈论的框架，即假设参与者都是理性的。那么，选择大于67的数字属于弱劣势策略（除非大家均选择100）；那么大于67的数字就被剔除了；按照这个思路，我选择45；</p></blockquote><p><strong>第四层</strong>：</p><blockquote><p>如果大家都考虑到了上面一层，那么基于第三层，现在选择大于45的也变成了弱劣势策略；按照这个思路，我应该选择30；</p></blockquote><p>按照这个逻辑一直持续下去，30 ～ 20、20 ～ 13，不断持续剔除下去，那么最终所有人都会选择1；</p><p>但1就是正确答案吗？</p><p>得到1需要反复迭代、剔除，即需要我不断知道别人都想到了上一层，即我知道你知道我知道你知道（无限套娃）我是理性的，即 <strong>Common Knowledge 共同知识</strong> 。</p><p><strong>定义 1.5</strong>：<strong>共同知识</strong></p><blockquote><p>共同知识是指某个信息或事件不仅被所有参与者知晓，而且所有参与者都知道其他参与者也知道该信息，并且知道其他参与者也知道其他人知道该信息，如此无限递归。<br>即：所有人都是理性的；所有人都知道所有人是理性的；所有人都知道所有人都知道所有人是理性的……</p></blockquote><h2 id="1-6-The-Median-Voter-Theorem-中位选民定理">1.6 The Median-Voter Theorem 中位选民定理</h2><p>该定理事实上只是迭代剔除劣势策略在政治学上的一个应用。并且该模型还是简化了现实问题，存在不少问题；</p><p>首先，对于2个候选人A和B，他们的立场用 1 ～ 10 数字表示，假定每个数字对应10%的选民，选民仅按立场的接近程度进行投票；如果立场的接近程度相同，则一半一半；候选人的目标就是最大化选票，即收益；</p><p>容易发现，1和10为劣势策略，具体推导如下：如果A选择2，那么</p><ol><li>当B选1时，$U_A(2,1) = 90% &gt; U_A(1,1) = 50%$；</li><li>当B选2时，$U_A(2,2) = 50% &gt; U_A(1,2) = 10%$；</li><li>当B选3时，$U_A(2,3) = 20% &gt; U_A(1,3) = 15%$；</li><li>当B选4时，$U_A(2,4) = 25% &gt; U_A(1,4) = 20%$；</li></ol><p>以此类推，后面都是2优于1并且均相差$5%$；</p><p>选2严格优于选1，根据对称性，选9也严格优于选10。</p><p>越接近中间就优于两侧吗？并不，可以算一个例子：如果A选择3，那么</p><p>当B选择1时，$U_A(3,1) = 85% &lt; U_A(2, 1) = 90%$，即A选3并不严格优于选2；</p><p>但是如果按照迭代剔除的思想，剔除劣势策略1和10之后，那么接下来策略2和9就变成了劣势策略，以此类推，最优的策略是选5和选6；这就是中位选民定理；</p><p>这个模型存在以下问题：</p><ol><li>选民并非平均分布；</li><li>选民并非完全根据立场来投票，即考量因素往往是多维度的；</li><li>选民往往会根据候选人过去的行为判断立场而并非按候选人所声称的；</li><li>选民存在弃票；</li><li>候选人往往大于2个；</li><li>大选之前还有初选；</li><li>…</li></ol><h2 id="1-7-Best-Response-最优对策">1.7 Best Response 最优对策</h2><p>如果站在双方的角度，都不存在严格最优对策，那么站在我的角度，假设另一方采取某策略的概率是$p$，据此计算我选择每个策略的期望收益；</p><blockquote><p><em><strong>持续更新中…</strong></em></p></blockquote>]]></content>
    
    
    <summary type="html">一些有关Game Theory(博弈论)的学习记录</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="博弈论" scheme="https://blog.yokumi.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>简述MCP(Model Context Protocols)</title>
    <link href="https://blog.yokumi.cn/2025/04/04/%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/"/>
    <id>https://blog.yokumi.cn/2025/04/04/%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/</id>
    <published>2025-04-04T13:25:00.000Z</published>
    <updated>2025-05-10T12:17:54.367Z</updated>
    
    <content type="html"><![CDATA[<h1>What’s MCP</h1><p>MCP，模型上下文协议，是一种开源标准。如果希望让我们的AI Agent能自动使用工具，能与各种数据源建立连接，自动地访问和利用外部信息，那么MCP就是这一过程的中间件。由LLM来决定需要调用哪些工具，但是由于LLM供应商以及各种工具标准并不统一，就MCP标准化指令的执行。即，MCP提供了一种将代理连接到工具的标准化方法。</p><p>MCP作为一种“中间协议层”，可以通过下图来更好地理解，具体架构将在后文阐述；<br><img src="%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/1.png" alt=""></p><h1>Why’ s MCP</h1><p>上面也提到了，LLM供应商以及各种工具标准并不统一，并且函数调用本身就具有局限性，再进一步讲述之前，我们先明确函数调用的概念。</p><p>函数调用（function calling）负责将自然语言提示转换为结构化函数调用指令，以便面向工具的系统（如 MCP 服务器）能够理解并执行作。此阶段的重点是为工具或 API 生成精确的指令。这就是LLM与具体系统集成的第一阶段；第二阶段才是MCP提供标准化工具执行指令。</p><p>LLM供应商大都提供了函数调用的功能，这里以Deepseek为例，简述函数调用的过程和使用方法（不考虑MCP的使用），具体内容可以进一步参考<a href="https://api-docs.deepseek.com/zh-cn/guides/function_calling">Deepseek API文档</a>；</p><ol><li>用户提问：北京今天的天气如何？</li><li>LLM理解用户提问，返回 function <code>get_weather(&#123;location: 'Beijing'&#125;)</code>；</li><li>（用户）手动调用 function <code>get_weather(&#123;location: 'Beijing'&#125;)</code>，将返回结果传递给LLM；</li><li>LLM理解结果，并将答案以自然语言形式输出；</li></ol><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_messages</span>(<span class="hljs-params">messages</span>):<br>    response = client.chat.completions.create(<br>        model=<span class="hljs-string">&quot;deepseek-chat&quot;</span>,<br>        messages=messages,<br>        tools=tools<br>    )<br>    <span class="hljs-keyword">return</span> response.choices[<span class="hljs-number">0</span>].message<br><br>client = OpenAI(<br>    api_key=<span class="hljs-string">&quot;&lt;your api key&gt;&quot;</span>,<br>    base_url=<span class="hljs-string">&quot;https://api.deepseek.com&quot;</span>,<br>)<br><br>tools = [<br>    &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>        <span class="hljs-string">&quot;function&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;get_weather&quot;</span>,<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Get weather of an location, the user shoud supply a location first&quot;</span>,<br>            <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>                <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;location&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                        <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;The city and state, e.g. San Francisco, CA&quot;</span>,<br>                    &#125;<br>                &#125;,<br>                <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;location&quot;</span>]<br>            &#125;,<br>        &#125;<br>    &#125;,<br>]<br><br>messages = [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;How&#x27;s the weather in Beijing?&quot;</span>&#125;]<br>message = send_messages(messages)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;User&gt;\t <span class="hljs-subst">&#123;messages[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;content&#x27;</span>]&#125;</span>&quot;</span>)<br><br>tool = message.tool_calls[<span class="hljs-number">0</span>]<br>messages.append(message)<br><br>messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;tool&quot;</span>, <span class="hljs-string">&quot;tool_call_id&quot;</span>: tool.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;24℃&quot;</span>&#125;)<br>message = send_messages(messages)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Model&gt;\t <span class="hljs-subst">&#123;message.content&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>注意上述代码中，我们手动定义了工具的内容，其格式由LLM供应商决定，并且供应商之间标准并不统一。而且，函数调用功能是通过用户手动执行并将结果添加到prompt中实现的。</p><h2 id="MCP’s-Role-in-Execution">MCP’s Role in Execution</h2><p>LLM生成函数调用指令后，必须执行这些指令才能提供结果。这就是 MCP 的用武之地。MCP 提供了一个标准化的框架来管理执行过程，包括工具发现、调用和响应处理；关于其具体的执行过程，我们先介绍它的架构；</p><h1>MCP Architecture</h1><p><img src="%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/2.png" alt=""></p><p>上图直观展示了MCP的架构，它主要围绕三个组件构成：MCP Server、MCP Host、MCP Client；</p><ul><li>MCP Server：顾名思义，是MCP的服务端，即集成的工具、函数、结构和数据连接所在的位置，同时负责执行代理给出的指令；</li><li>MCP Host：主机，比如聊天应用程序，用户使用包含代理的应用程序；</li><li>MCP Client：MCP的客户端，是主机与服务器之间的接口，负责数据交换；</li></ul><p>当引入MCP后，我们通过Agent代理查询天气的过程变成：</p><ol><li>用户提问：北京今天的天气如何？</li><li>主机连接到LLM，根据问题和服务器提供的工具列表，确定使用哪些MCP Server；</li><li>客户端调用所需的MCP Server，执行所选的工具；</li><li>服务器将结果回送给LLM，后者生成最终答案并输出给用户；</li></ol><h1>MCP开发</h1><blockquote><p><em><strong>持续更新中</strong></em>；</p></blockquote><p>官方开发文档可参考：<br><a href="https://modelcontextprotocol.io/introduction">官方开发文档</a></p><h1>Reference</h1><p>[1]. <a href="https://medium.com/@tahirbalarabe2/what-is-model-context-protocol-mcp-architecture-overview-c75f20ba4498">What is Model Context Protocol? (MCP) Architecture Overview</a></p>]]></content>
    
    
    <summary type="html">简述MCP(Model Context Protocols)</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="https://blog.yokumi.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="LLM" scheme="https://blog.yokumi.cn/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>阿里云ESC + V2RayA实现科学上网</title>
    <link href="https://blog.yokumi.cn/2025/04/03/%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://blog.yokumi.cn/2025/04/03/%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</id>
    <published>2025-04-03T00:45:00.000Z</published>
    <updated>2025-05-10T12:17:54.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为个人的阿里云国内服务器偶遇运营商垃圾跨境节点导致连接github及其不稳定，所以有了这篇帖子；</p></blockquote><h1>环境</h1><blockquote><p>操作系统：Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-202-generic x86_64)<br>云服务器：阿里云ESC<br>代理客户端：V2RayA，优点是适用于无图形化的操作系统；</p></blockquote><h1>V2RayA 简介</h1><blockquote><p>一个易用而强大的，跨平台的 V2Ray 客户端<br>使用 Golang 和 Vue.js 编写，运行时没有任何外部依赖库，可跨平台运行，借助任意一款浏览器均可操作；<br>对于无图形界面的操作系统，打开它提供的 Web UI 就能完成配置工作，对于远程服务器及其友好；</p></blockquote><h1>V2RayA 安装</h1><p>演示通过软件源安装，其他安装方法和操作系统请参考：<a href="https://v2raya.org/docs/prologue/installation">请选择你的英雄</a></p><blockquote><p><strong>添加公钥</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -qO - https://apt.v2raya.org/key/public-key.asc | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/keyrings/v2raya.asc<br></code></pre></td></tr></table></figure><blockquote><p><strong>添加 V2RayA 软件源</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [signed-by=/etc/apt/keyrings/v2raya.asc] https://apt.v2raya.org/ v2raya main&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/v2raya.list<br><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure><blockquote><p><strong>安装 V2RayA</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install v2raya v2ray<br></code></pre></td></tr></table></figure><p>出现以下信息，说明安装成功：<img src="%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png" alt=""></p><h1>启动 V2RayA</h1><blockquote><p><strong>启动 V2RayA</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start v2raya.service<br></code></pre></td></tr></table></figure><blockquote><p><strong>设置 V2RayA 为开机自启动</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> v2raya.service<br></code></pre></td></tr></table></figure><blockquote><p><strong>检查V2RayA 启动状态</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl status v2raya.service<br></code></pre></td></tr></table></figure><p>如果看到类似以下信息，说明启动成功：<img src="%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png" alt=""></p><h1>V2RayA 配置</h1>]]></content>
    
    
    <summary type="html">让你的云服务器能够科学上网</summary>
    
    
    
    <category term="开发心得" scheme="https://blog.yokumi.cn/categories/%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="云服务器" scheme="https://blog.yokumi.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Agentic Design Pattern AI代理设计模式学习</title>
    <link href="https://blog.yokumi.cn/2025/03/13/Agentic%20Design%20Pattern%20AI%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://blog.yokumi.cn/2025/03/13/Agentic%20Design%20Pattern%20AI%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-13T02:44:00.000Z</published>
    <updated>2025-05-10T12:17:53.969Z</updated>
    
    <content type="html"><![CDATA[<h1>零、概述 Overview</h1><p>我们要让 LLM 一次性根据我们的提示生成一个应用的所有前端代码或一整篇论文，LLM 一次性输出最终 Token，不修改，显然是较为困难并且效果不佳的。但是，如果使用代理设计流（Agent Workflow），让 LLM 按照编排的工作流，多次提示，每个步骤都有优化任务，不断迭代改进输出，类似人拆解复杂任务、收集信息、改进迭代并最终达到满意结果的过程。</p><p>以编写文档为例，工作流大致涉及以下步骤：</p><ol><li>撰写文档大纲；</li><li>查询本地知识库或网络收集资料；</li><li>撰写初稿；</li><li>检查初稿并修正不合理之处；</li><li>如此迭代到文档符合要求；</li></ol><p>代理设计模式主要包括：</p><ol><li><strong>Reflection Pattern</strong>：反思模式，LLM 可以通过反思自己的行为成为更有效的代理；</li><li><strong>Tool Use Pattern</strong>：工具使用模式；</li><li><strong>Planning Pattern</strong>：规划模式；</li><li><strong>Multi-Agent Pattern</strong>：多代理模式；</li></ol><h1>壹、Reflection Pattern</h1><p>反思模式类似于我们直接与大模型对话，通过不断提示大模型达到我们想要的输出。代理设计模式中，需要将提供反馈的步骤自动化。</p><p>比如可以设计 Prompt 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">现有以下任务<span class="hljs-attribute">X</span>：略；以下是用于任务<span class="hljs-attribute">X</span>的代码：略；请你仔细检查代码的正确性、风格和效率，并就如何改进它给出建设性的批评和建议；<br></code></pre></td></tr></table></figure><p>然后，将之前生成的代码和检查后的反馈一起作为 Context 输入给 LLM，让 LLM 根据反馈建议修改代码；</p><p>一个简单的示意图如下：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504081117237.png" alt=""></p><p>当然，实际应用中会涉及多次迭代，以获得更高的精度；</p><h2 id="应用：SELF-RAG">应用：SELF-RAG</h2><p>SELF-RAG 在检索以及生成的过程中引入了自我反思机制，下图直观呈现了它和传统 RAG 的区别：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504081124295.png" alt=""></p><h1>贰、Tool Use Pattern</h1><p>代理通过调用 API 来获取预训练模型权重中缺少的额外信息，比如调用 Web 搜索、访问本地知识库、执行代码等等；</p><h1>叁、Planning Pattern</h1><p>前面已经提到，复杂的问题往往需要拆解为多个步骤。我们可以事先就搭建好代理工作流，但是在代理规划模式下，Agent 能动态决定需要采取的步骤。</p><p>关于任务的分解，主要有以下几种方式：</p><h2 id="Chain-of-Thought-思维链CoT">Chain of Thought(思维链CoT)</h2><p>通过“逐步思考”实现复杂推理，</p><blockquote><p>可参考内容</p></blockquote><p>[1]  <a href="https://arxiv.org/abs/2201.11903?utm_campaign=The%20Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8Kh954rkXmE4vgpKvro3Klpjhn7IuT-Y_eXIYtgVIq9PTzwa5zFWX7FZZqv1tuDEEsTDuY">Chain-of-Thought Prompting Elicits Reasoning in Large Language Models</a>, Wei et al. (2022)；</p><h2 id="Tree-of-Thought">Tree of Thought</h2><p>在前者的基础上进行了扩展，对于每个步骤生成了多个思考，建立树状结构，然后执行 BFS 或 DFS，通过分类器或多数投票进行评估；</p><h1>肆、Multi-Agent Collaboration</h1><p>Multi-Agent Collaboration，即多代理协作，顾名思义，对于一个复杂的任务，拆分成不同的任务，并交给不同代理去做。虽然现在 LLM 的上下文限制不断提升，但对于一个复杂的任务，比如开发一个较为复杂的软件系统，单个 LLM 并不一定能达到较好的效果。而如果像游戏公司一样，将不同部分交给专业的人去做，比如策划、客户端开发、服务端开发、TA、QA、美术等等，让不同的 Agent 完成不同的子任务，可能能达到更好的效果。</p><blockquote><p>可参考内容</p></blockquote><p>[1]  <a href="https://arxiv.org/abs/2307.07924?utm_campaign=The%20Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8TZzur2df1qdnGx09b-Fg94DTsc3-xXao4StKvKNU2HR51el3n8yOm0CPSw6GiAoLQNKua">Communicative Agents for Software Development</a>, Qian et al. (2023)；</p>]]></content>
    
    
    <summary type="html">有关AI代理设计模式的一些学习</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="https://blog.yokumi.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计(Java)</title>
    <link href="https://blog.yokumi.cn/2025/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(Java)/"/>
    <id>https://blog.yokumi.cn/2025/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(Java)/</id>
    <published>2025-03-01T03:08:00.000Z</published>
    <updated>2025-05-10T12:17:54.554Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象的三大特性</h1><ul><li>封装、继承、多态<ul><li>封装：对抽象的事物抽象成一个对象，并对其对象的属性私有化，同时能提供一些能被外部访问属性的方法。<ul><li>对象：属性+方法；<ul><li>成员变量：生存期是对象的生存期，作用域在类的内部；<ul><li>访问属性：private vs. public vs. friendly<ul><li>private：针对类而不是针对对象的，即同一个类的不同对象的私有属性之间可以相互访问；</li><li>friendly：既没有public也没有private修饰，可以在同一个package内进行访问；</li><li>public：一个编译单元（.java文件）只能有一个public类，并且名称要求相同；</li><li>protected：自己、同一个package内、子类可访问；</li></ul></li></ul></li><li>本地变量：生存期和作用域都是函数内部；</li><li>对象初始化：<ul><li>构造函数（无返回类型，接收无参和有参两种构造方式，即多个同名但参数表不同的函数构成了函数<em><strong>重载</strong></em>）；</li><li>初始化顺序：定义初始化$\rightarrow$构造器；如果继承了父类，先进行父类初始化，并需要确保父类的属性得到了正确的初始化；</li></ul></li></ul></li></ul></li><li>继承：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；<ul><li>Cpp和Java的一个重要区别是，Cpp支持多继承，并且有指针的概念；Java是单继承，但可以用接口来实现多继承；</li></ul></li><li>多态：<ul><li>多态变量：对象变量能对应多种类型，具体可分为静态类型和动态类型；</li><li>造型Cast：<ul><li>造型并不是类型转换；</li><li>向上造型Upcasting：子类对象可以当作父类对象来使用，即子类对象可以用父类对象来赋值；</li></ul></li><li>函数调用的绑定：通过对象类型去调用函数时，调用哪个函数称为绑定；<ul><li>静态绑定：根据变量的声明类型决定；在编译期间确定，被称为静态分派，比如函数的重载；</li><li>动态绑定：根据变量的动态类型决定；在程序运行时确定，被称为动态分派，比如方法的重写（同名同参数表的子类方法会覆盖(override)父类方法）；</li></ul></li><li>多态的底层实现是动态绑定，实际就是方法调用动态分派的过程。如果子类方法覆盖了父类方法，在多态调用时，会先确定实际类型为子类，然后先搜索子类中的该方法。</li></ul></li></ul></li></ul><h1>static vs. final</h1><ul><li>Static：<ul><li>static修饰属性：类变量，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用；</li><li>static修饰方法：类函数，随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用 this；</li></ul></li><li>final：<ul><li>final修饰变量：<ul><li>如果修饰基本数据类型，那相当于常量，不能改变值；</li><li>如果修饰引用数据类型的变量（即对象的引用），那么不能改变对象的引用（即存储地址），即初始化后不能再让其指向一个新的对象；</li></ul></li><li>final修饰方法：相当于禁用了重写，继承类不能修改该方法的含义；</li><li>final修饰类：<ul><li>该类不能被继承；</li><li>final类中的所有成员⽅法都会被隐式地指定为final⽅法；</li><li>该类的成员变量不受影响；</li><li>该类可以有内部类；</li><li>当然，也可以通过私有化构造方法来禁止该类被继承（单例模式）；</li></ul></li></ul></li></ul><h1>抽象类 vs. 接口Interface</h1><ul><li>抽象类：包含抽象方法的类，即使用abstract修饰的类；有抽象函数的类一定是抽象类；<ul><li>抽象类不能用于实例化对象；</li><li>抽象类只能被继承；</li></ul></li><li>接口：接口是一个抽象类型，是抽象方法的集合；<ul><li>接口支持多继承；</li><li>接口中定义的方法，默认是 public abstract 修饰的抽象方法；</li></ul></li><li>相同点：<ul><li>两者均不能被实例化；</li><li>子类/实现类必须重写抽象类/接口中定义的抽象方法；</li></ul></li><li>不同点：<ul><li>抽象类有构造方法，接口没有构造方法；</li><li>抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8 之后可以）；</li><li>抽象类只能单继承，接口可以多继承；</li><li>抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量；</li></ul></li></ul>]]></content>
    
    
    <summary type="html">面向对象的程序设计</summary>
    
    
    
    <category term="就业八股" scheme="https://blog.yokumi.cn/categories/%E5%B0%B1%E4%B8%9A%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="面向对象" scheme="https://blog.yokumi.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>一些有关Large Language Model(LLM)的学习记录</title>
    <link href="https://blog.yokumi.cn/2025/02/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Large%20Language%20Model(LLM)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.yokumi.cn/2025/02/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Large%20Language%20Model(LLM)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2025-02-27T13:33:00.000Z</published>
    <updated>2025-05-10T12:17:54.194Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：</p><blockquote><p>由于本人之前对于大模型的学习学的急功近利，偏向于应用（<s>乱用bushi</s>），回头看来对LLM本身过于肤浅，所以浅开一个坑，用于补齐原理性的知识；</p><p><s>BUPT课设太TM多了</s>。不定期随便填坑。</p></blockquote><p><strong>参考资料</strong>：</p><blockquote><p>【1】［美] 塞巴斯蒂安·拉施卡 著，叶文滔 译. 大模型技术30讲[M]. 北京：人民邮电出版社，2024.<br>【2】Raschka S. <em>Build a Large Language Model (From Scratch)</em>[M]. Shelter Island, NY: Manning, 2024.</p></blockquote><h1>一、Understanding LLM</h1><h2 id="1-1-What-is-LLM">1.1 What is LLM?</h2><p><strong>定义 1.1</strong>：<strong>Large Language Model</strong></p><blockquote><p>An LLM is a neural network designed to understand, generate, and respond to human-like text;</p></blockquote><ul><li>“Large” means, datasets on which it’s trained and parameters(the model’s size);<ul><li><strong>parameters</strong> are the adjustable weights in the network that are optimized during training to predict the next word in a sequence;</li></ul></li><li>LLM‘s architecture – <strong>Transformer</strong>, which enables them to pay selective attention to different parts of the input when making predictions;</li><li>LLM is also called <strong>Generative AI</strong>(生成式AI);</li></ul><p>至于其中使用到的两种手段 —— machine learning and deep learning，将在之后具体阐释。（后者是前者的一个子集，主要区别是是否需要手动提取特征。然而机器学习的经典算法已经快被淘汰了，令人感慨）；</p><h2 id="1-2-Application-of-LLM">1.2 Application of LLM</h2><p>无需多言，用过都说好；</p><h2 id="1-3-Stages-of-building-and-using-LLMs">1.3 Stages of building and using LLMs</h2><ul><li><strong>Pretraining 预训练</strong>：在多领域的庞大数据集下训练；</li><li><strong>Finetuning 微调</strong>：针对特定任务通过特定领域的标注数据集在Pretrained LLM的基础上进行训练；<ul><li><strong>Instruction Finetuning 指令微调</strong>：简单来说，就是<em><strong>标注数据 = 指令 + 正确答案</strong></em>；</li><li><strong>Classification Finetuning 分类微调</strong>：<em><strong>标注数据 = 文本 + 分类标签</strong></em>；</li></ul></li></ul><p>两者的具体区别如下图所示：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171352752.png" alt=""></p><h2 id="1-4-Introducing-the-transformer-architecture">1.4 Introducing the transformer architecture</h2><p>Transformer 的两个重要组件是 <strong>Encoder 编码器</strong> 和 <strong>Decoder 解码器</strong>，编码器将输入文本编码为向量，而解码器解码向量并生成相应文本。区别于传统的全连接型或卷积型，编码器和解码器之间采用 <strong>Self-attention mechanism 自注意力机制</strong> 连接；</p><p>在 Transformer模型的基础上，又衍生出了两种不同架构：<strong>Bert(Bidirectional encoder representations from transformers)</strong> 和 <strong>GPT(Generative pretrained transformers)</strong>；</p><p>从全拼也可以看出，这两种模型分别用于不同的任务，Bert模型主要用于 predict masked or hidden words 预测掩码值，适用于文本分类任务，以下是它和 GPT-Model 区别的图示：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171450135.png" alt=""></p><p>GPT-Model 又分为：</p><ul><li><strong>Zero-shot 零样本学习</strong>：能够处理从未在训练数据中见过的任务或类别，即模型在面对新任务时不需要额外的训练和微调也能做出合理的决策；</li><li><strong>Few-shot 少样本学习</strong>：模型在提供极少量样本或示例时，就能够理解并执行特定任务的能力；泛化能力强；</li></ul><p>下图具体说明了两者的区别：<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171510313.png" alt=""></p><p>GPT-Model采用 <strong>自监督(Self-supervised learning)</strong> 的方式进行学习，即自标注形式(Self-labeling)。我们可以将句子或者文档中的下一个单词作为模型应该预测的标签进行训练。</p><blockquote><p><strong>注</strong>：模型能够执行未明确训练的任务的能力称为 <strong>Emergent Ability 涌现</strong>，模型并未针对专门任务进行训练，但是在大量数据集的训练下突然表现出未预料到的新行为或新能力。增加参数量往往会促进涌现行为的出现。</p></blockquote><h2 id="1-5-Building-a-large-language-model">1.5 Building a large language model</h2><p><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504172235133.png" alt=""></p><h1>零、</h1>]]></content>
    
    
    <summary type="html">一些有关Large Language Model(LLM)的学习记录</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="https://blog.yokumi.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="Python" scheme="https://blog.yokumi.cn/tags/Python/"/>
    
    <category term="LLM" scheme="https://blog.yokumi.cn/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>RAG（Retrieval-augmented generation）个人学习笔记</title>
    <link href="https://blog.yokumi.cn/2025/02/22/RAG%EF%BC%88Retrieval-augmented%20generation%EF%BC%89%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.yokumi.cn/2025/02/22/RAG%EF%BC%88Retrieval-augmented%20generation%EF%BC%89%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-02-22T08:54:00.000Z</published>
    <updated>2025-05-10T12:17:54.193Z</updated>
    
    <content type="html"><![CDATA[<h1>为什么需要RAG？</h1><p>传统的LLM模型主要存在以下2个问题：幻觉以及外部知识/最新知识的缺失，RAG可以通过结合基于检索和生成模型的优势来提供更准确和上下文相关的响应，可以添加自己的预料构建知识库。</p><h1>RAG vs. fine-tuning a LLM model</h1><p>下图源自<a href="https://github.com/Tongji-KGLLM/RAG-Survey/">RAG-Survey</a><br><img src="./RAG%EF%BC%88Retrieval-augmented%20generation%EF%BC%89%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RAG_FT_Table.jpg" alt=""><br>结合个人理解：</p><ol><li>RAG更适合知识库需要动态更新的情景，这部分数据不作为用于LLM的训练数据，而是通过LLM的能力进行检索。</li><li>RAG由于采用检索的形式，数据来源是可知的，而LLM是黑箱。</li><li>RAG 可以对生成过程提供更多控制。</li></ol><h1>Query Classification 查询分类</h1><p>并非所有查询都需要用到检索增强，需要将查询分类为需要使用RAG和直接用LLM生成两类。</p><blockquote><p>持续更新中…</p></blockquote>]]></content>
    
    
    <summary type="html">个人关于RAG的学习记录</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="https://blog.yokumi.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="RAG" scheme="https://blog.yokumi.cn/tags/RAG/"/>
    
    <category term="LLM" scheme="https://blog.yokumi.cn/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>NSFC爬虫练习</title>
    <link href="https://blog.yokumi.cn/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/"/>
    <id>https://blog.yokumi.cn/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/</id>
    <published>2025-01-22T12:47:00.000Z</published>
    <updated>2025-05-10T12:17:54.190Z</updated>
    
    <content type="html"><![CDATA[<h1>需求</h1><p>从国家自然科学基金大数据知识管理服务门户爬取论文数据。</p><h1>搜索API</h1><ol><li>打开浏览器的<strong>开发者工具</strong>（如 Chrome 的 F12）；</li><li>在网络（Network）选项卡中，监控搜索的请求；</li><li>找到接口()[<a href="https://kd.nsfc.cn/api/baseQuery/completionQueryResultsData">https://kd.nsfc.cn/api/baseQuery/completionQueryResultsData</a>]；</li><li>其请求体如下：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;A01&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;fuzzyKeyword&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;complete&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;isFuzzySearch&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;conclusionYear&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2020&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;dependUnit&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;pageNum&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;pageSize&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;personInCharge&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;projectName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;projectType&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;218&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;subPType&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;psPType&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ratifyNo&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ratifyYear&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;enddate&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ordering&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;desc&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;codeScreening&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;dependUnitScreening&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;keywordsScreening&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;projectTypeNameScreening&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>需要用到的字段只有：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">code <span class="hljs-comment">// 申请代码</span><br>conclusionYear <span class="hljs-comment">// 结题年度</span><br>projectType <span class="hljs-comment">// 资助类别</span><br></code></pre></td></tr></table></figure><ol start="5"><li>观察其返回内容：<img src="/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/1.png" alt="">为一串无规律的长字符串，初步判断是经过了某种加密；</li></ol><h1>解密</h1><p>页面的HTML文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>We&#x27;re sorry but 国家自然科学基金大数据知识管理服务门户 doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/chunk-vendors.559d99e0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/app.17b88e26.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在网页的 JavaScript 文件中，尝试寻找相关的解密代码，最终在app.17b88e26.js中找到以下内容（注释为后期补充）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 定义密钥</span><br>    <span class="hljs-keyword">var</span> t = p.<span class="hljs-property">a</span>.<span class="hljs-property">enc</span>.<span class="hljs-property">Utf8</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;IFROMC86&quot;</span>);<br>    <br>    <span class="hljs-comment">// 使用 DES 解密方法</span><br>    <span class="hljs-keyword">var</span> n = p.<span class="hljs-property">a</span>.<span class="hljs-property">DES</span>.<span class="hljs-title function_">decrypt</span>(<br>        &#123;<br>            <span class="hljs-attr">ciphertext</span>: p.<span class="hljs-property">a</span>.<span class="hljs-property">enc</span>.<span class="hljs-property">Base64</span>.<span class="hljs-title function_">parse</span>(e) <span class="hljs-comment">// 解析 Base64 编码的密文</span><br>        &#125;,<br>        t, <span class="hljs-comment">// 解密密钥</span><br>        &#123;<br>            <span class="hljs-attr">mode</span>: p.<span class="hljs-property">a</span>.<span class="hljs-property">mode</span>.<span class="hljs-property">ECB</span>, <span class="hljs-comment">// 使用 ECB 模式</span><br>            <span class="hljs-attr">padding</span>: p.<span class="hljs-property">a</span>.<span class="hljs-property">pad</span>.<span class="hljs-property">Pkcs7</span> <span class="hljs-comment">// 使用 PKCS7 填充方式</span><br>        &#125;<br>    );<br><br>    <span class="hljs-comment">// 将解密后的内容解析为 UTF-8 字符串并转为 JSON</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(n.<span class="hljs-title function_">toString</span>(p.<span class="hljs-property">a</span>.<span class="hljs-property">enc</span>.<span class="hljs-property">Utf8</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Python 的 pycryptodome 库来实现解密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pycryptodome<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> DES<br><span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> unpad<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt_des_ecb</span>(<span class="hljs-params">ciphertext</span>):<br>    <span class="hljs-comment"># 密钥</span><br>    key = <span class="hljs-string">b&quot;IFROMC86&quot;</span><br>    <span class="hljs-comment"># Base64 解码</span><br>    encrypted_data = base64.b64decode(ciphertext)<br>    <br>    <span class="hljs-comment"># 初始化 DES 解密器</span><br>    cipher = DES.new(key, DES.MODE_ECB)<br>    <br>    <span class="hljs-comment"># 解密数据并移除填充</span><br>    decrypted_data = unpad(cipher.decrypt(encrypted_data), DES.block_size)<br>    <br>    <span class="hljs-comment"># 解密后的字符串转为 JSON 格式</span><br>    <span class="hljs-keyword">return</span> json.loads(decrypted_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>对网页发送请求，成功得到解密后的JSON文件：<br><img src="/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/2.png" alt=""></p>]]></content>
    
    
    <summary type="html">一个项目需要的爬虫记录</summary>
    
    
    
    <category term="开发心得" scheme="https://blog.yokumi.cn/categories/%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Python" scheme="https://blog.yokumi.cn/tags/Python/"/>
    
    <category term="爬虫" scheme="https://blog.yokumi.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>一文白嫖阿里云服务器+配置基本开发环境+博客等服务部署</title>
    <link href="https://blog.yokumi.cn/2025/01/17/%E4%B8%80%E6%96%87%E7%99%BD%E5%AB%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8+%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83+%E5%8D%9A%E5%AE%A2%E7%AD%89%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"/>
    <id>https://blog.yokumi.cn/2025/01/17/%E4%B8%80%E6%96%87%E7%99%BD%E5%AB%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8+%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83+%E5%8D%9A%E5%AE%A2%E7%AD%89%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</id>
    <published>2025-01-17T08:20:00.000Z</published>
    <updated>2025-05-11T09:16:47.511Z</updated>
    
    <content type="html"><![CDATA[<h1>零、~~（白嫖）~~步骤</h1><p>阿里云的学生优惠会送一张无门槛300元代金券（传送门： <a href="https://university.aliyun.com/">阿里云高校计划_云工开物_助力高校科研与教育加速-阿里云</a> ），刚好够白嫖用券专区中的小服务器一整年（还多出15块可以买个20g的流量包）；个人配置如下：</p><ul><li><strong>实例规格</strong>：<a href="https://help.aliyun.com/document_detail/25378.html?spm=5176.ecscore_server.0.0.38314df5CTmW3g#e">ecs.e-c1m1.large</a>；</li><li><strong>CPU&amp;内存</strong>：2核2G；</li><li><strong>操作系统</strong>：Ubuntu 22.04 LTS 64位；</li><li><strong>带宽计费方式</strong>：按使用流量；</li><li><strong>公网带宽</strong>：5 Mbps；</li></ul><blockquote><p><s><strong>注</strong>：别选固定带宽，这是另外的价钱；</s></p></blockquote><p>白嫖完后，进入配置；</p><h1>一、本地远程连接</h1><h2 id="1-1-密钥对认证">1.1 密钥对认证</h2><p>由于本人采用密钥对进行认证，在创建并绑定密钥对后会自动下载一个 <code>.pem</code> 的文件到本地，ssh连接需要采用以下方式：</p><ol><li>直接连接：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -i ~/.ssh/你的私钥文件 用户名@服务器IP<br></code></pre></td></tr></table></figure><ol start="2"><li>简化连接方式</li></ol><p>每次手动输入私钥文件显然过于不便了，我们可以将私钥文件添加到SSH配置文件中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.ssh/config<br></code></pre></td></tr></table></figure><p>增加配置如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host 服务器别名(随便取)<br>  HostName 服务器IP <br>  <span class="hljs-keyword">User</span> <span class="hljs-title">用户名 </span><br><span class="hljs-title">  IdentityFile</span> ~/.ssh/你的私钥文件 <br>  Port <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>按下 <code>^x</code> 和 <code>y</code> 保存后，可以直接采用服务器别名连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh 服务器别名<br></code></pre></td></tr></table></figure><h2 id="1-2-常见问题">1.2 常见问题</h2><ol><li>连接时报错：</li></ol><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">Warning: Permanently added <span class="hljs-string">&#x27;你的服务器IP&#x27;</span> (ED25519) to the list of known hosts. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions <span class="hljs-number">0644</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;你的私钥文件地址&#x27;</span> are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Load key <span class="hljs-string">&quot;你的私钥文件地址&quot;</span>: bad permissions 用户名@服务器IP: Permission denied (publickey).<br></code></pre></td></tr></table></figure><p>这是因为SSH出于安全考虑，要求私钥文件的权限必须足够严格，不允许其他用户访问。你需要修改私钥文件的权限，确保只有你自己可以读取和写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 ~/.ssh/你的私钥文件<br></code></pre></td></tr></table></figure><h1>二、基本环境配置</h1><h2 id="2-1-基本工具安装">2.1 基本工具安装</h2><ol><li>系统更新</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt upgrade -y<br></code></pre></td></tr></table></figure><ol start="2"><li>基本工具安装（有些已经自带）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install -y build-essential curl wget git vim htop net-tools<br></code></pre></td></tr></table></figure><ol start="3"><li>防火墙配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install -y ufw<br><span class="hljs-built_in">sudo</span> ufw allow ssh<br><span class="hljs-built_in">sudo</span> ufw allow http<br><span class="hljs-built_in">sudo</span> ufw allow https<br><span class="hljs-built_in">sudo</span> ufw <span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure><h2 id="2-2-安装Docker">2.2 安装Docker</h2><p>以下步骤也可以直接参考 <a href="https://docs.docker.com/engine/install/ubuntu/">Docker 官方文档</a>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装所需依赖</span><br><span class="hljs-built_in">sudo</span> apt install -y apt-transport-https ca-certificates gnupg lsb-release<br><br><span class="hljs-comment"># 添加 Docker 的官方 GPG 密钥（通过阿里云镜像）</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /etc/apt/keyrings &amp;&amp; \<br>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | <span class="hljs-built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg &amp;&amp; \<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null &amp;&amp; \<br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 安装最新的 Docker</span><br><span class="hljs-built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure><h3 id="常见问题">常见问题</h3><p>由于运营商网络等不稳定因素可能导致镜像加速器无法成功拉取到指定版本的容器镜像，阿里云提供了免费的镜像加速器，配置步骤如下：</p><ol><li>登录<a href="https://cr.console.aliyun.com/?spm=a2c4g.11186623.0.0.27881d82EVUzaG">容器镜像服务控制台</a>。</li><li>在左侧导航栏选择<strong>镜像工具</strong> &gt; <strong>镜像加速器</strong></li><li>在<strong>镜像加速器</strong>页面获取<strong>加速器地址</strong>。</li></ol><p>接下来，在云服务器上更新 Docker 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /etc/docker <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span> <br>&#123; <br><span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;你的镜像加速器地址&quot;</span>] <br>&#125; <br>EOF<br><span class="hljs-built_in">sudo</span> systemctl daemon-reload <br><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><p>最后，验证是否可以成功拉取 Docker Hub镜像：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><p>如果看到以下输出，说明成功拉取！</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Hello <span class="hljs-keyword">from</span> Docker!<br>This message shows <span class="hljs-keyword">that</span> your installation appears <span class="hljs-keyword">to</span> be working correctly.<br></code></pre></td></tr></table></figure><h2 id="2-3-配置-git">2.3 配置 git</h2><ol><li>这里采用使用 SSH 密钥认证，首先在云服务器上生成 SSH 密钥对；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>可以直接一路回车到底，默认情况下，密钥会保存到 <code>~/.ssh/id_rsa</code>；</p><ol start="2"><li>将公钥添加到 GitHub 账户</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看公钥内容</span><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>复制后，登录到 <strong>GitHub</strong>，进入 <strong>Settings</strong> -&gt; <strong>SSH and GPG keys</strong>，点击 <strong>New SSH key</strong>，将公钥复制到 GitHub 的文本框中并保存；</p><ol start="3"><li>验证连接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 测试连接</span><br>ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果配置成功，会观察到输出如下信息：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi username! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><h2 id="2-4-安装-Anaconda">2.4 安装 Anaconda</h2><ol><li>下载 Anaconda 的安装包</li></ol><p>你可以在 <a href="https://repo.anaconda.com/archive/">官网</a> 自行查找需要的版本，替换以下链接即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://repo.anaconda.com/archive/Anaconda3-2024.10-1-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><ol start="2"><li>安装anaconda</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 授予可执行权限</span><br><span class="hljs-built_in">chmod</span> +x Anaconda3-2024.10-1-Linux-x86_64.sh<br><br><span class="hljs-comment"># 执行</span><br>./Anaconda3-2024.10-1-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>然后疯狂回车（中间需要输入一次yes）即可；</p><ol start="3"><li>验证安装</li></ol><p>打开新的终端，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda --version<br></code></pre></td></tr></table></figure><p>如果输出正确的 conda 版本，则说明安装成功并且正确配置环境变量；</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> <span class="hljs-number">24</span>.<span class="hljs-number">9</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2-5-安装-MySQL">2.5 安装 MySQL</h2><ol><li>安装 MySQL APT 存储库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> wget https://dev.mysql.com/get/mysql-apt-config_0.8.33-1_all.deb<br></code></pre></td></tr></table></figure><ol start="2"><li>安装 MySQL 服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装 MySQL 服务器</span><br><span class="hljs-built_in">sudo</span> apt install -y mysql-server<br><span class="hljs-comment">#启动 MySQL 服务</span><br><span class="hljs-built_in">sudo</span> systemctl start mysql<br><span class="hljs-comment">#检查启动状态</span><br><span class="hljs-built_in">sudo</span> systemctl status mysql<br><span class="hljs-comment">#在系统启动时自动启动。</span><br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> mysql<br></code></pre></td></tr></table></figure><ol start="3"><li>安装安全向导（可选）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql_secure_installation<br></code></pre></td></tr></table></figure><p>它会让你自信选择安全策略，包括如下内容：</p><ul><li>Would you like to setup VALIDATE PASSWORD component?<ul><li>是否需要启用 <code>VALIDATE PASSWORD</code> 组件？</li></ul></li><li>There are three levels of password validation policy:<ul><li>LOW    Length &gt;= 8</li><li>MEDIUM Length &gt;= 8, numeric, mixed case, and special characters</li><li>STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary file</li><li>这里选择输入 2 ，表示设置密码策略要求密码至少包含一个大写字母、一个小写字母、一个数字和一个特殊字符，并且密码总长度至少为8个字符；</li></ul></li><li>Remove anonymous users?<ul><li>是否移除匿名用户？</li><li>这里输入 y ，表示移除；</li></ul></li><li>Disallow root login remotely?<ul><li>禁止MySQL的 <code>root</code> 用户从远程登录；</li><li>这里选择 y；</li></ul></li><li>Remove test database and access to it?<ul><li>是否需要移除MySQL自带的 <code>test</code> 数据库？</li><li>无所谓，删了吧；</li></ul></li><li>Reload privilege tables now?<ul><li>输入 y ，重新加载权限表，使得更改生效；</li></ul></li></ul><ol start="4"><li>配置安全组规则</li></ol><p>配置安全组时，MySQL 默认使用3306端口。确保实例安全组的入站规则开放3306端口。如果选择了不同的端口，请根据实际情况调整安全组设置。具体步骤请参考<a href="https://help.aliyun.com/zh/ecs/user-guide/add-a-security-group-rule#concept-sm5-2wz-xdb">添加安全组规则</a>。</p><ol start="5"><li>添加用于远程访问的用户</li></ol><p>将以下输入的 <code>&lt;username&gt;</code> 和 <code>&lt;password&gt;</code> 部分自行修改；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql -uroot -p \<br>-e <span class="hljs-string">&quot;CREATE USER &#x27;&lt;username&gt;&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;&lt;password&gt;&#x27;;&quot;</span> \<br>-e <span class="hljs-string">&quot;GRANT ALL PRIVILEGES ON *.* TO &#x27;&lt;username&gt;&#x27;@&#x27;%&#x27; WITH GRANT OPTION;&quot;</span> \<br>-e <span class="hljs-string">&quot;FLUSH PRIVILEGES;&quot;</span><br></code></pre></td></tr></table></figure><p>执行后需要输入 root 账户的密码；</p><ol start="6"><li>登录 mysql 账户验证</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql -u &lt;username&gt; -p<br></code></pre></td></tr></table></figure><p>输入密码后，进入 mysql 环境，成功！</p><p>输入以下内容可以退出 mysql 环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit;<br></code></pre></td></tr></table></figure><h2 id="2-6-配置-Node-js-开发环境">2.6 配置 Node.js 开发环境</h2><ol><li>下载 NVM 源码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://gitee.com/mirrors/nvm.git ~/.nvm &amp;&amp; <span class="hljs-built_in">cd</span> ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags`<br></code></pre></td></tr></table></figure><ol start="2"><li>配置环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&#x27;echo &quot;. ~/.nvm/nvm.sh&quot; &gt;&gt; /etc/profile&#x27;</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><ol start="3"><li>设置镜像源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node<br></code></pre></td></tr></table></figure><ol start="4"><li>自行下载所需版本，例如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install v23.3.0<br></code></pre></td></tr></table></figure><p>若观察到以下输出，说明安装成功：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Computing</span> checksum with sha256sum<br><span class="hljs-attribute">Checksums</span> matched!<br><span class="hljs-attribute">Now</span> using node v23.<span class="hljs-number">3</span>.<span class="hljs-number">0</span> (npm v10.<span class="hljs-number">9</span>.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">Creating</span> default alias: default -&gt; v23.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="2-7-配置-Java-环境">2.7 配置 Java 环境</h2><ol><li>安装所需版本的JDK（以Java 1.8 为例）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install -y openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>如果需要下载其他版本，可以运行以下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt search openjdk<br></code></pre></td></tr></table></figure><ol start="2"><li>验证安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version<br></code></pre></td></tr></table></figure><h2 id="2-8-Screen-工具">2.8 Screen 工具</h2><p>在通过 Scp 等远程传输文件时，特别是大文件时，往往因为 SSH 连接不稳定而导致中断。而 Screen 工具提供了从单个 SSH 会话中使用多个 shell 窗口的能力。当会话被分离或网络中断时 Screen 会话中启动的进程仍将运行，我们可以随时重新连接到 Screen 会话。</p><ol><li>安装 Screen</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install screen<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个会话</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><ol start="3"><li>挂起一个会话</li></ol><p>按下 <code>Ctrl</code> + <code>a</code> + <code>d</code> 即可保持这个 Screen 到后台并回到我们 SSH 的主终端；</p><ol start="4"><li>恢复一个会话</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -r -d <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>即可重新进入该 Screen；</p><ol start="5"><li>查看已经存在的 Screen 终端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -<span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><h2 id="2-9-安装-Nginx-环境">2.9 安装 Nginx 环境</h2><ol><li>使用 Nginx 官方源安装；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#更新系统已安装软件并更新包管理工具</span><br><span class="hljs-built_in">sudo</span> apt update -y<br><span class="hljs-comment">#Nginx安装前必要环境</span><br><span class="hljs-built_in">sudo</span> apt install -y curl gnupg2 ca-certificates lsb-release ubuntu-keyring<br><span class="hljs-comment">#导入官方Nginx签名密钥</span><br>curl https://nginx.org/keys/nginx_signing.key | gpg --dearmor | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /usr/share/keyrings/nginx-archive-keyring.gpg &gt;/dev/null<br><span class="hljs-comment">#设置apt仓库</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] http://nginx.org/packages/ubuntu `lsb_release -cs` nginx&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nginx.list<br><span class="hljs-comment">#安装nginx</span><br><span class="hljs-built_in">sudo</span> apt install -y nginx<br></code></pre></td></tr></table></figure><p>接下来根据实际需要修改配置文件；</p><h1>三、搭建 Cloudreve 云盘</h1><h2 id="3-1-快速部署">3.1 快速部署</h2><p>下载 Cloudreve 发布版本，你可以自行从 <a href="https://github.com/cloudreve/Cloudreve/releases">Release</a> 选择适合你的操作系统的；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/cloudreve/Cloudreve/releases/download/3.8.3/cloudreve_3.8.3_linux_amd64.tar.gz<br><br><span class="hljs-comment"># 创建程序目录</span><br><span class="hljs-built_in">mkdir</span> -p /usr/local/cloudreve<br><br><span class="hljs-comment"># 解压获取到的主程序到所在目录</span><br>tar -zxvf cloudreve_3.8.3_linux_amd64.tar.gz -C /usr/local/cloudreve<br><br><span class="hljs-built_in">cd</span> /usr/local/cloudreve<br><span class="hljs-comment"># 赋予执行权限</span><br><span class="hljs-built_in">chmod</span> +x ./cloudreve<br><br><span class="hljs-comment"># 启动 Cloudreve</span><br>./cloudreve<br></code></pre></td></tr></table></figure><p>观察到以下输出，说明启动成功：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504072229775.png" alt=""></p><p>在首次启动时，会创建初始管理员账号，请注意保管下方的管理员密码，<em><strong>此密码只会在首次启动时出现</strong></em>；</p><p>Cloudreve 默认会监听<code>5212</code>端口，你可以在浏览器中访问 <code>http://服务器IP:5212</code> 进入 Cloudreve。注意需要增加阿里云服务器的安全组规则。</p><h2 id="3-2-启动进程守护">3.2 启动进程守护</h2><ol><li>编辑配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /usr/lib/systemd/system/cloudreve.service<br><br>[Unit]<br>Description=Cloudreve<br>Documentation=https://docs.cloudreve.org<br>After=network.target<br>After=mysqld.service<br>Wants=network.target<br><br>[Service]<br>WorkingDirectory=/usr/local/cloudreve<br>ExecStart=/usr/local/cloudreve/cloudreve<br>Restart=on-abnormal<br>RestartSec=5s<br>KillMode=mixed<br><br>StandardOutput=null<br>StandardError=syslog<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ol start="2"><li>更新配置并启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新配置</span><br>systemctl daemon-reload<br><br><span class="hljs-comment"># 启动服务</span><br>systemctl start cloudreve<br><br><span class="hljs-comment"># 设置开机启动</span><br>systemctl <span class="hljs-built_in">enable</span> cloudreve<br></code></pre></td></tr></table></figure><ol start="3"><li>管理命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动服务</span><br>systemctl start cloudreve<br><br><span class="hljs-comment"># 停止服务</span><br>systemctl stop cloudreve<br><br><span class="hljs-comment"># 重启服务</span><br>systemctl restart cloudreve<br><br><span class="hljs-comment"># 查看状态</span><br>systemctl status cloudreve<br></code></pre></td></tr></table></figure><ol start="4"><li>访问前端服务</li></ol><p>通过  <code>https://你的服务器IP:5212</code> 即可访问；</p><h1>四、部署 hexo 博客</h1><blockquote><p>纯纯自用罢了；</p></blockquote><h2 id="4-1-服务端-git-的有关配置">4.1 服务端 git 的有关配置</h2><ol><li>创建一个单独的用户用于管理仓库；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> adduser git<br><span class="hljs-built_in">sudo</span> passwd git<br></code></pre></td></tr></table></figure><ol start="2"><li>设置 git 用户 sudo 权限；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 740 /etc/sudoers<br><span class="hljs-built_in">sudo</span> vim /etc/sudoers<br></code></pre></td></tr></table></figure><p>添加一行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>) <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>按下 <code>:wq</code> 保存更改，然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 400 /etc/sudoers<br></code></pre></td></tr></table></figure><ol start="3"><li>上传公钥到服务器并添加到 git 用户</li></ol><p>在本机执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp ~/.ssh/id_rsa.pub root@&lt;你的服务器IP&gt;:/home/git/tempkey.pub -i ~/.ssh/你的私钥文件.pem<br></code></pre></td></tr></table></figure><p>然后登录服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh 你的服务器别名<br><span class="hljs-built_in">sudo</span> su - git<br><span class="hljs-built_in">mkdir</span> -p ~/.ssh<br><span class="hljs-built_in">cat</span> ~/tempkey.pub &gt;&gt; ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>你同样可以在本机化简配置：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host 你的服务器别名_2<br>  HostName 你的服务器公网IP<br>  <span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br>  IdentityFile ~/.ssh/id_rsa<br>  Port <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><h2 id="4-2-配置-Git-仓库和部署钩子">4.2 配置 Git 仓库和部署钩子</h2><ol><li>初始化一个裸仓库；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">su git<br><span class="hljs-built_in">cd</span> ~<br>git init --bare hexo.git<br></code></pre></td></tr></table></figure><ol start="2"><li>添加 post-receive 自动部署钩子；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi ~/hexo.git/hooks/post-receive<br></code></pre></td></tr></table></figure><p>输入以下内容并保存退出（:wq）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>GIT_WORK_TREE=/data/hexo git checkout -f<br></code></pre></td></tr></table></figure><p>赋予执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ~/hexo.git/hooks/post-receive<br></code></pre></td></tr></table></figure><ol start="3"><li>创建部署目录并授权</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /data/hexo<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> -R git:git /data/hexo<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> -R 755 /data/hexo<br></code></pre></td></tr></table></figure><h2 id="4-3-Hexo-配置">4.3 Hexo 配置</h2><h3 id="4-3-x-关于资源文件夹的问题">4.3.x 关于资源文件夹的问题</h3><p>当然，使用图床等工具，直接在 markdown 中插入外链是最方便的，并且不用担心在博客迁移时发生问题。不过如果你想要保存图片在本地，那么可以参考如下方法：</p><ol><li>保存图片在 <code>source/</code> 文件夹下；</li></ol><p>这是肯定的，区别只是在于后面的引用格式问题；</p><ol start="2"><li>如果图片的目录为 <code>source/img/example.png</code> ；</li></ol><p>那么，默认配置下，你的引用格式应该为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">img/example.png</span>)<br></code></pre></td></tr></table></figure><p>如果你希望不同文章的图片保存在不同目录，你可以自行修改保存路径和相应的引用格式（<strong>注意是相对于 source 文件夹的路径</strong>）；当然，你也可以使用 Hexo 提供的配置方式，将配置文件 <code>config.yml</code> 修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>但你每次通过命令行新建一个文章时，它会自动在 <code>_posts</code> 文件夹下生成一个同名文件夹，你可以将文章图片都放在该文件夹中，此时引用格式为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">example.png</span>)<br></code></pre></td></tr></table></figure><p>但是，这并不是特别方便，特别是对于需要通过别的阅读器，比如 Typora 等进行阅读。如果你希望维持相对路径格式又能对图片进行分类，你可以通过修改 Typora 设置来进行，但我推荐使用插件 <code>hexo-asset-link</code> 插件，这个插件可以保留你原本写的路径结构，即：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">./文章名/example.png</span>)<br></code></pre></td></tr></table></figure><p>安装和配置方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-asset-link --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中添加：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">asset_link:</span><br>  <span class="hljs-params">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>重新生成并部署即可！</p><blockquote><p>其余部分暂略；</p></blockquote><h2 id="4-4-部署-Hexo-博客">4.4 部署 Hexo 博客</h2><h3 id="4-4-x-部署-Hexo-博客到云服务器">4.4.x 部署 Hexo 博客到云服务器</h3><ol><li>安装 <code>hexo-deployer-git</code> 插件；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ol start="2"><li>修改 <code>_config.yml</code> 中的 deploy 部分；</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@你的服务器别名_2:<span class="hljs-keyword">/home/</span>git/hexo.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><ol start="3"><li>运行以下命令进行部署；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><p>或直接写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo c &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ol start="4"><li>修改 Nginx 配置文件；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span>  nginx;<br><span class="hljs-attribute">worker_processes</span>  auto;<br><br><span class="hljs-attribute">error_log</span>  /var/log/nginx/<span class="hljs-literal">error</span>.log <span class="hljs-literal">notice</span>;<br><span class="hljs-attribute">pid</span>        /var/run/nginx.pid;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       /etc/nginx/mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] &quot;<span class="hljs-variable">$request</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;<br><br>    <span class="hljs-attribute">access_log</span>  /var/log/nginx/access.log  main;<br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-attribute">include</span> /etc/nginx/conf.d/<span class="hljs-regexp">*.conf</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>修改虚拟主机配置；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/nginx/conf.d/default.conf<br></code></pre></td></tr></table></figure><p>如果没有域名，则修改为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>        <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>   [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  你的公网IP;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /data/hexo;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果仅有域名，则修改为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>        <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>   [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  yourdomain.com;<br>  <br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /data/hexo;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你有域名并申请过 SSL 安全证书，则修改为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>        <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>   [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  yourdomain.com;<br><br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)$</span> https://<span class="hljs-variable">$&#123;server_name&#125;</span><span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span> yourdomain.com;<br><br>    <span class="hljs-attribute">ssl_certificate</span>     /path/to/your/cert.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /path/to/your/key.pem;<br><br>    <span class="hljs-attribute">ssl_session_cache</span>   shared:SSL:<span class="hljs-number">1m</span>;<br>    <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;<br>    <span class="hljs-attribute">ssl_ciphers</span>         HIGH:!aNULL:!MD5;<br>    <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /data/hexo;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>        <span class="hljs-attribute">proxy_set_header</span>   X-Real-IP        <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>   Host             <span class="hljs-variable">$http_host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>   X-Forwarded-For  <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意将上面的域名、SSL 证书的路径字段替换为你实际的。</p><ol start="5"><li>启动 Nginx 进程；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start nginx<br><span class="hljs-built_in">sudo</span> systemctl status nginx<br><span class="hljs-built_in">sudo</span> systemctl reload nginx<br></code></pre></td></tr></table></figure><p>阿里云服务器一般默认开放了 80 和 443 端口，如果服务商不同，请自行开放防火墙；</p><ol start="6"><li>配置域名解析（如果没有域名，则无需进行这一步）；</li></ol><p>如果你使用的是阿里云的 DNS，那么你需要登录域名管理后台，添加一条 A 记录：</p><table><thead><tr><th><strong>主机记录</strong></th><th><strong>类型</strong></th><th><strong>记录值</strong></th><th><strong>TTL</strong></th></tr></thead><tbody><tr><td>blog</td><td>A</td><td>你的公网IP</td><td>600(s)</td></tr></tbody></table><p>解析是否生效可以通过以下命令进行验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping yourdomain.com<br></code></pre></td></tr></table></figure><p>如果你的域名 DNS 指向了非服务商，比如我使用了 <strong>Cloudflare 的 DNS</strong>，那么你需要在 Cloudflare 的控制面板中设置，添加 A 记录：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>主机名</strong></th><th><strong>内容（IP 地址）</strong></th><th><strong>TTL</strong></th><th><strong>代理状态</strong></th></tr></thead><tbody><tr><td>A</td><td>blog</td><td>你的服务器公网IP</td><td>自动</td><td>关闭小云朵（点一下变灰）</td></tr></tbody></table><p>说明：如果你只是做博客访问，<strong>把“代理状态”的小云朵关闭（变灰）</strong>，否则 Nginx 会收到 Cloudflare 的 IP 而不是你用户的真实 IP；</p><p><strong>特别说明：</strong></p><blockquote><p>如果你使用的是中国大陆的服务器，那么需要提交备案申请，<strong>未备案域名将无法通过 HTTP/HTTPS 正常访问</strong>，云服务商会限制端口 80 和 443。如果你想通过云服务器部署个人博客，请遵循有关规定。<s>不过我懒。</s></p></blockquote><p><strong>补充：</strong></p><blockquote><p>备案时应该要求你的域名 DNS 指向阿里云 DNS，否则存在不通过的风险。（我记得备案的时候用途就不能写个人博客来着）</p></blockquote><h3 id="4-4-y-配置服务到-Github-Page-或其他托管平台">4.4.y 配置服务到 Github Page 或其他托管平台</h3><p>把 Hexo 部署到 GitHub Pages 或其他托管平台并绑定你的域名也同样可行且省事，而且完全免费、无需备案。</p><ol><li>新建一个 Github 仓库；</li></ol><p>命名为：（啥也不用勾选，空的公开仓库即可）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">XXX.github.<span class="hljs-built_in">io</span><br></code></pre></td></tr></table></figure><ol start="2"><li>修改 Hexo 的配置文件；</li></ol><p>将 deploy 部分改为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> 你的仓库地址<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><blockquote><p>如果你默认 GitHub 用 master 分支，那就把 branch 改为 master 即可；</p></blockquote><ol start="3"><li>绑定域名；</li></ol><p>首先，添加一个名为 CNAME 的文件到 source 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yourdomain.com&quot;</span> &gt; <span class="hljs-built_in">source</span>/CNAME<br></code></pre></td></tr></table></figure><p>登录 Cloudflare ，添加如下记录：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>名称</strong></th><th><strong>值</strong></th></tr></thead><tbody><tr><td>CNAME</td><td>blog</td><td><a href="http://XXX.github.io">XXX.github.io</a></td></tr></tbody></table><blockquote><p>确保开启了 <strong>小云朵（代理）图标</strong>，启用 CDN 与 HTTPS；</p></blockquote><p>重新部署博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ol start="4"><li>设置 GitHub Pages 部署配置；</li></ol><p>在你的仓库中打开「Settings」→「Pages」，设置以下内容：</p><ul><li><strong>Source</strong> 设为：main 分支（或者 master，看你哪个在用）</li><li><strong>Branch folder</strong> 选的是 / (root)</li><li><strong>Custom domain</strong> 应该已填写为：<a href="http://yourdomain.com">yourdomain.com</a></li></ul><p>在重新部署一次，如果 DNS 已生效，那么就可以正常浏览你的博客了！</p><blockquote><p><strong>注</strong>：不定期随缘更新中…</p></blockquote>]]></content>
    
    
    <summary type="html">白嫖阿里云服务器+配置基本开发环境+博客等服务部署</summary>
    
    
    
    <category term="开发心得" scheme="https://blog.yokumi.cn/categories/%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="云服务器" scheme="https://blog.yokumi.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：矩阵的LU分解</title>
    <link href="https://blog.yokumi.cn/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%9A%84LU%E5%88%86%E8%A7%A3/"/>
    <id>https://blog.yokumi.cn/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%9A%84LU%E5%88%86%E8%A7%A3/</id>
    <published>2025-01-15T12:16:00.000Z</published>
    <updated>2025-05-10T12:17:54.365Z</updated>
    
    <content type="html"><![CDATA[<h1>矩阵的LU分解</h1><h2 id="Gauss消元法">Gauss消元法</h2><p>在介绍LU分解之前，我们先通过Gauss消元法引入。</p><p>对于求解以下线性方程组的问题：</p><p>$$<br>\left{\begin{matrix}<br>a_{11}x_{11} + a_{12}x_{12} + \cdots + a_{1n}x_{1n} = b_1\<br>\vdots \<br>a_{n1}x_{n1} + a_{n2}x_{n2} + \cdots + a_{nn}x_{nn} = b_n \<br>\end{matrix}\right.<br>$$</p><p>其矩阵形式为：</p><p>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} &amp; b_1\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} &amp; b_n<br>\end{bmatrix} \triangleq (A \vdots  b)<br>$$</p><p><strong>Guass消元法</strong>的基本思想是将矩阵$ \boldsymbol{A}$通过初等行变换转化为阶梯型矩阵，我们假定该过程中不涉及“对换变换”，变换过程如下：</p><p>记</p><p>$$<br>A^{(1)} = A = \begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)}\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>a_{n1}^{(1)} &amp; a_{n2}^{(1)} &amp; \cdots &amp; a_{nn}^{(1)}<br>\end{bmatrix}<br>$$</p><p>若$a_{11}^{(1)} \ne 0$，则：</p><p>$$<br>A^{(1)} \xrightarrow{r_i - \frac{a_{21}^{(1)}}{a_{11}^{(1)}}r_1,i = 2,3,\cdots,n}<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)}\<br>0 &amp; a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)}\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; a_{n2}^{(2)} &amp; \cdots &amp; a_{nn}^{(2)}<br>\end{bmatrix} \triangleq A^{(2)}<br>$$</p><p>若$a_{22}^{(2)} \ne 0$，则：</p><p>$$<br>A^{(2)} \xrightarrow{r_i - \frac{a_{32}^{(2)}}{a_{22}^{(2)}}r_1,i = 3,4,\cdots,n}<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; a_{13}^{(1)}&amp; \cdots &amp; a_{1n}^{(1)}\<br>&amp; a_{22}^{(2)} &amp; a_{23}^{(2)}&amp; \cdots &amp; a_{2n}^{(2)}\<br>&amp; &amp; a_{33}^{(3)} &amp; \cdots &amp; a_{3n}^{(3)}\<br>&amp; &amp; \vdots &amp; &amp; \vdots\<br>&amp; &amp; a_{n3}^{(3)} &amp; \cdots &amp; a_{nn}^{(3)}<br>\end{bmatrix} \triangleq A^{(3)}<br>$$</p><p>如此继续，如果能进行$n-1$步，那么可以将矩阵$ \boldsymbol{A}$化为上三角矩阵：</p><p>$$<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)}\<br>&amp; a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)}\<br>&amp; &amp;  \ddots &amp; \vdots\<br>&amp; &amp; &amp; a_{nn}^{(n)}<br>\end{bmatrix} \triangleq A^{(n)}<br>$$</p><p>上述过程就是Guass消元法的矩阵描述。</p><p>在上述过程进行的过程中，易得，如果Guass消元法能进行到底：</p><p>$$<br>\Leftrightarrow a_{11}^{(1)}a_{22}^{(2)}\cdots a_{n-1n-1}^{(n-1)} \ne 0<br>$$</p><p>那么问题是，如何判断$ \boldsymbol{A}$的前$n-1$个主元$\ne 0$？</p><p>回溯上述过程可知：</p><p>$$<br>\begin{aligned}<br>&amp; a_{11}^{(1)} = a_{11}\<br>&amp; a_{11}^{(1)}a_{22}^{(2)} =<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)}\<br>0 &amp; a_{22}^{(22)}<br>\end{bmatrix} =<br>\begin{bmatrix}<br>a_{11} &amp; a_{12}\<br>a_{21} &amp; a_{22}<br>\end{bmatrix}\<br>&amp; \cdots \<br>&amp; a_{11}^{(1)}a_{22}^{(2)}\cdots a_{kk}^{(k)} =<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1k}^{(1)}\<br>&amp; a_{22}^{(2)} &amp; \cdots &amp; a_{2k}^{(2)}\<br>&amp; &amp;  \ddots &amp; \vdots\<br>&amp; &amp; &amp; a_{kk}^{(k)}<br>\end{bmatrix} =<br>\begin{bmatrix}<br>a_{11} &amp; \cdots &amp; a_{1k}\<br>\vdots &amp; &amp; \vdots\<br>a_{k1} &amp; \cdots &amp; a_{kk}<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>记：</p><p>$$<br>\begin{aligned}<br>&amp; \Delta_1 = a_{11} \<br>&amp; \Delta_2 = \begin{bmatrix}<br>a_{11} &amp; a_{12}\<br>a_{21} &amp; a_{22}<br>\end{bmatrix} \<br>&amp; \cdots \<br>&amp; \Delta_{n-1} = \begin{bmatrix}<br>a_{11} &amp; \cdots &amp; a_{1n-1}\<br>\vdots &amp; &amp; \vdots\<br>a_{n-11} &amp; \cdots &amp; a_{n-1n-1}<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>可以发现，$\Delta_k$即为$ \boldsymbol{A}$的$k$阶<strong>顺序主子式</strong>。</p><p>所以，得到如下命题：</p><p><strong>命题 1</strong><br>当$\Delta_k \ne 0,k = 1,2,\cdots,n-1\Leftrightarrow a_{kk}^{(k)} \ne 0$</p><p>于是，自然得到：</p><p><strong>定理 1</strong><br>Guass消元法能进行到底 $\Leftrightarrow$ $\boldsymbol{A}$的前$n-1$个顺序主子式$\ne 0$；</p><h2 id="矩阵LU分解的步骤推导">矩阵LU分解的步骤推导</h2><p>从高斯消元法的过程，每一步初等行变换的过程相当于一个<strong>高斯变换</strong>，即左乘一个矩阵：</p><p>$$<br>L_1 = \begin{bmatrix}<br>1 &amp; &amp; &amp; \<br>l_1 &amp; 1 &amp; &amp;\<br>l_2 &amp;  &amp; 1 &amp; &amp; \<br>\vdots &amp;  &amp;  &amp; \ddots &amp; \<br>l_n &amp; &amp; &amp; &amp; 1<br>\end{bmatrix}<br>$$</p><p>其中，$l_i = -\frac{a_{i1}^{(1)}}{a_{11}^{(1)}},i = 2,3,\cdots,n$。</p><p>易得，高斯消元法的过程可以表示为：</p><p>$$<br>L_{n-1}L_{n-2}\cdots L_{1}A = U<br>$$</p><p>其中，$\boldsymbol{L}_i$为下三角矩阵，$\boldsymbol{U}$为上三角矩阵。</p><p>令 $\boldsymbol{L} = L_1^{-1}\cdots L_{n-2}^{-1}L_{n-1}^{-1}$，则有：</p><p>$$<br>\boldsymbol{A} =  \boldsymbol{L} \boldsymbol{U}<br>$$</p><p>这就是矩阵的<strong>LU分解</strong>。</p><p>求得 $\boldsymbol{L}$ 和 $\boldsymbol{U}$ 后，如何计算 $x$？</p><p>$$<br>Ax = LUx = b<br>$$</p><p>取中间变量 $y = Ux$，则 $Ly = b$。</p><p>那么，为什么LU分解能加速线性方程组的求解呢？</p><p>实际上，虽然从矩阵形式上看，$\boldsymbol{L}$ 需要计算 $n-1$ 个 $L_i$ 的逆，但是实际算法求解过程中，三角型的矩阵的乘法和逆是容易计算的，并且甚至不需要额外的空间存储开销 \cite{Matrix_Computations}：算法会将 $\boldsymbol{L}$ 和 $\boldsymbol{U}$ 的元素直接存储到原矩阵 $\boldsymbol{A}$ 的相应位置上：</p><ul><li>$\boldsymbol{L}$ 的下三角部分（不包括对角线）会存储在 $\boldsymbol{A}$ 的下三角部分。</li><li>$\boldsymbol{U}$ 的上三角部分和对角线会存储在 $\boldsymbol{A}$ 的上三角部分和对角线上。</li></ul><p>例如，对于矩阵</p><p>$$<br>\boldsymbol{A} =\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; a_{13} \<br>a_{21} &amp; a_{22} &amp; a_{23} \<br>a_{31} &amp; a_{32} &amp; a_{33}<br>\end{bmatrix}<br>$$</p><p>经过 LU 分解后，它的存储会变为：</p><p>$$<br>\boldsymbol{A} =\begin{bmatrix}<br>u_{11} &amp; u_{12} &amp; u_{13} \<br>l_{21} &amp; u_{22} &amp; u_{23} \<br>l_{31} &amp; l_{32} &amp; u_{33}<br>\end{bmatrix}<br>$$</p><p>其中：</p><ul><li>$l_{ij}$ 为第 $i$ 行，第 $j$ 列的乘子；</li><li>$u_{ij}$ 为第 $i$ 行，第 $j$ 列的上三角元素；</li></ul><p>通过这种方式，所有分解信息都存储在原矩阵中，无需额外空间。LU分解既降低了时间复杂度又降低了空间复杂度。</p><p>不过，从我们进行高斯消元法的过程就可以发现，要保证高斯消元法能进行到底，需要避免乘子中的除数（$A_{kk}$）出现 0（实际应用中，很小的情况也应该避免），所以一般不直接应用LU分解，而是应用<strong>列主元PLU分解</strong>，它通过交换行来避免出现相对很小的主元，实现稳定的LU分解 \cite{数值分析5}，其伪代码如算法 \ref{列选主元PLU分解法} 所示。</p><h3 id="算法：列选主元PLU分解法">算法：列选主元PLU分解法</h3><p><strong>输入：</strong> 矩阵 $A \in \mathbb{R}^{n \times n}$<br><strong>输出：</strong> 矩阵 $P, L, U$，使得 $P A = L U$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs algorithm">初始化：<br>U = A, L = I, P = I<br><br>for k = 1 to n-1 do:<br>    1. 寻找主元：<br>       pivot = max_&#123;i=k, ..., n&#125; |U[i, k]|<br>       记录主元行号 row<br>       <br>    2. 若 row ≠ k:<br>       构造置换矩阵 P_k，交换 U 的第 k 行与第 row 行：<br>       P_k = 交换 k 行与 row 行的单位矩阵<br>       <br>       更新 U: U = P_k U<br>       更新 P: P = P_k P<br>       <br>       若 k &gt; 1，则更新 L: L = P_k L<br>    <br>    3. 对于 i = k+1 到 n:<br>       计算消元因子：<br>       L[i, k] = U[i, k] / U[k, k]<br>       <br>       更新 U：<br>       U[i, :] = U[i, :] - L[i, k] * U[k, :]<br>       <br>返回 P, L, U<br></code></pre></td></tr></table></figure><p>$$<br>\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}<br>$$</p><p>其中，若矩阵 $\boldsymbol{A}$ 满秩，即 $\operatorname{rank} A = r$，则可利用 LU 分解或 PLU 分解构造其满秩分解：</p><p>• <strong>LU 分解构造满秩分解</strong></p><p>若 $\boldsymbol{A}$ 可分解为 $\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}$，则从 $\boldsymbol{L}$ 提取前 $r$ 列，从 $\boldsymbol{U}$ 提取前 $r$ 行：<br>$$<br>\boldsymbol{F} = \boldsymbol{L}[:, 0:r],\quad \boldsymbol{G} = \boldsymbol{U}[0:r, :]<br>$$</p><p>其中，$\boldsymbol{F}$ 为列满秩矩阵（$m \times r$），$\boldsymbol{G}$ 为行满秩矩阵（$r \times n$），从而得到矩阵的满秩分解。</p><p>• <strong>PLU 分解构造满秩分解</strong></p><p>设 $\boldsymbol{A}$ 通过列主元 LU 分解得：</p><p>$$<br>\boldsymbol{A} = \boldsymbol{P} \boldsymbol{L} \boldsymbol{U}<br>$$</p><p>同样取：<br>$$<br>\boldsymbol{B} = \boldsymbol{L}[:, 0:r],\quad \boldsymbol{C} = \boldsymbol{U}[0:r, :]<br>$$</p><p>代入分解式可得：<br>$$<br>\boldsymbol{A} = \boldsymbol{P} \boldsymbol{B} \boldsymbol{C}<br>$$</p><p>其中，$\boldsymbol{P}$ 为置换矩阵，显然满秩。</p><p>进一步推广，若方阵 $\boldsymbol{A}$ 可分解为：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \boldsymbol{D} \boldsymbol{U}<br>$$</p><p>其中，$\boldsymbol{D}$ 为对角矩阵，则称其为 <strong>LDU 分解</strong>。</p><p>由高斯消元法的推导，可得如下定理及推论：</p><p><strong>定理</strong>：矩阵 $\boldsymbol{A} = (a_{i j})_{n \times n}$ 存在唯一分解：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \boldsymbol{D} \boldsymbol{U}<br>$$</p><p>其中：</p><p>• $\boldsymbol{L}$ 为单位下三角矩阵，</p><p>• $\boldsymbol{U}$ 为单位上三角矩阵，</p><p>• $\boldsymbol{D}$ 为对角矩阵，其对角元：$d_{k} = \frac{\Delta_{k}}{\Delta_{k-1}}, \quad k=1,2,\dots,n \quad (\Delta_0 = 1)$</p><p>其中 $\Delta_k$ 为 $\boldsymbol{A}$ 的顺序主子式。</p><p><strong>推论</strong>：若 $\boldsymbol{A}$ 为非奇异矩阵，则其可进行三角分解：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}<br>$$</p><p>当且仅当 $\boldsymbol{A}$ 的顺序主子式：$\Delta_k \neq 0, \quad k=1,2,\dots,n$</p><p><strong>进一步推广</strong>：对 <strong>Doolittle、Crout、Cholesky 分解</strong>，定义如下：</p><p>• <strong>Doolittle 分解</strong>：设 $\boldsymbol{A}$ 具有唯一 LDU 分解，令：<br>$$<br>\hat{\boldsymbol{U}} = \boldsymbol{D} \boldsymbol{U}<br>$$</p><p>则有：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \hat{\boldsymbol{U}}<br>$$</p><p>• <strong>Crout 分解</strong>：令：<br>$$<br>\hat{\boldsymbol{L}} = \boldsymbol{L} \boldsymbol{D}<br>$$</p><p>则有：<br>$$<br>\boldsymbol{A} = \hat{\boldsymbol{L}} \boldsymbol{U}<br>$$</p><p>• <strong>Cholesky 分解</strong>（平方根分解）：设 $\boldsymbol{A}$ 为实对称正定矩阵，则其可分解为：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \widetilde{\boldsymbol{D}}^2 \boldsymbol{U}<br>$$</p><p>其中：<br>$$<br>\widetilde{\boldsymbol{D}} = \operatorname{diag}(\sqrt{d_1},\sqrt{d_2},\dots,\sqrt{d_n})<br>$$</p><p>进一步，可得：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \widetilde{\boldsymbol{D}}^2 \boldsymbol{L}^\top<br>$$</p><p>令：<br>$$<br>\boldsymbol{G} = \boldsymbol{L} \widetilde{\boldsymbol{D}}<br>$$</p><p>则有：<br>$$<br>\boldsymbol{A} = \boldsymbol{G} \boldsymbol{G}^\top<br>$$</p><p>这被称为 <strong>Cholesky 分解</strong>（对称三角分解）。</p>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：矩阵函数和矩阵求导</title>
    <link href="https://blog.yokumi.cn/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0%E5%92%8C%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"/>
    <id>https://blog.yokumi.cn/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0%E5%92%8C%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</id>
    <published>2025-01-15T08:50:00.000Z</published>
    <updated>2025-05-10T12:17:54.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵函数介绍">矩阵函数介绍</h2><p>矩阵函数与通常的函数类似，但是因变量和自变量都为 $n$ 阶矩阵。定义如下：</p><h3 id="定义">定义</h3><p>设一元函数 $f(z)$ 能展开为 $z$ 的幂级数：<br>$$<br>f(z) = \sum_{k = 0}^{\infty} c_k z^k, \quad (|z| &lt; r)<br>$$<br>其中 $r &gt; 0$ 表示该幂级数的收敛半径。当 $n$ 阶矩阵 $A$ 的谱半径 $\rho (A) &lt; r$ 时，把收敛矩阵幂级数 $\sum_{k = 0}^{\infty} c_k A^k$ 的和称为 <strong>矩阵函数</strong>，记为 $f(A)$，即：<br>$$<br>f(A) = \sum_{k = 0}^{\infty} c_k A^k<br>$$</p><p>通过以上定义和一些基本函数，可以导出 <strong>矩阵指数函数</strong> 和 <strong>矩阵三角函数</strong>，并推得一系列等式。</p><hr><h2 id="函数矩阵对矩阵的导数">函数矩阵对矩阵的导数</h2><p>我们已经在上一节中引入了矩阵函数的概念，类似地，也有微分和导数的定义。相较于标量导数，对矩阵函数的求导和微分较为复杂。在具体应用中，如梯度下降等算法，这部分内容具有重要意义，因此需要深入理解。</p><p>首先，我们将标量求导拓展到向量，对于 $\frac{\partial y}{\partial x}$，存在以下几种情况：</p><ol><li>$y$ 是标量：<ul><li>$x$ 是标量</li><li>$\boldsymbol{x}$ 是向量（默认为列向量，即 $\boldsymbol{x} = (x_1, x_2, x_3)^\top$）</li><li>$\boldsymbol{X}$ 是矩阵</li></ul></li><li>$\boldsymbol{y}$ 是向量，例如 $f_{3\times 1}(x) = (f_1, f_2, f_3)^\top$：<ul><li>标量变元</li><li>向量变元</li><li>矩阵变元</li></ul></li><li>$\boldsymbol{Y}$ 是矩阵，同样有三种变元。</li></ol><p>简单理解：</p><ul><li><strong>分子布局</strong>：分子是列向量形式，分母是行向量形式</li><li><strong>分母布局</strong>：分子是行向量形式，分母是列向量形式</li></ul><h3 id="向量化操作">向量化操作</h3><p>在具体分析之前，先介绍矩阵的 <strong>向量化操作</strong>。例如，对矩阵 $\boldsymbol{X} \in \mathbb{R}^{m \times n}$ 进行列优先展开：<br>$$<br>\text{vec}(\boldsymbol{X}) =<br>\begin{bmatrix}<br>x_{11} &amp; x_{21} &amp; \dots &amp; x_{m1} &amp; \dots &amp; x_{1n} &amp; x_{2n} &amp; \dots &amp; x_{mn}<br>\end{bmatrix}^\top<br>$$</p><h3 id="向量变元的实值标量函数">向量变元的实值标量函数</h3><ol><li><strong>行向量偏导（分子布局）</strong><br>$$<br>\boldsymbol{D}_{\boldsymbol{x}} f = \frac{\partial f}{\partial \boldsymbol{x}^\top} =<br>\begin{bmatrix}<br>\frac{\partial f}{\partial x_1} &amp; \frac{\partial f}{\partial x_2} &amp; \dots &amp; \frac{\partial f}{\partial x_n}<br>\end{bmatrix}<br>$$</li><li><strong>梯度向量偏导（分母布局）</strong><br>$$<br>\nabla_{\boldsymbol{x}} f = \frac{\partial f}{\partial \boldsymbol{x}} =<br>\begin{bmatrix}<br>\frac{\partial f}{\partial x_1} \<br>\frac{\partial f}{\partial x_2} \<br>\vdots \<br>\frac{\partial f}{\partial x_n}<br>\end{bmatrix}<br>$$</li></ol><h3 id="矩阵变元的实值标量函数">矩阵变元的实值标量函数</h3><p>从标量求导到矩阵求导，就是分子的 <strong>转置、向量化</strong> 和分母的 <strong>转置、向量化</strong> 的各种组合。</p><p>对于 <strong>分子布局</strong>：</p><ul><li>分子：标量、列向量、矩阵向量化后的列向量</li><li>分母：标量、列向量转置后的行向量、矩阵的转置矩阵、矩阵向量化后的列向量转置后的行向量</li></ul><p>对于 <strong>分母布局</strong>：</p><ul><li>分子：标量、列向量转置后的行向量、矩阵向量化后的列向量转置后的行向量</li><li>分母：标量、列向量、矩阵自身、矩阵向量化后的列向量</li></ul><p>在机器学习领域，常见的主要有以下三种形式：</p><ol><li><strong>梯度</strong>：<br>$$<br>\nabla_{\boldsymbol{x}} \overset{\mathrm{def}}{=} \left[\frac{\partial}{\partial x_{1}},\frac{\partial}{\partial x_{2}},\cdots,\frac{\partial}{\partial x_{n}}\right]^{T}=\frac{\partial}{\partial\boldsymbol{x}}<br>$$</li><li><strong>Hesse矩阵</strong>：<br>$$<br>H(f) =<br>\begin{bmatrix}<br>\frac{\partial^2f}{\partial x_1^2} &amp; \frac{\partial^2f}{\partial x_1\partial x_2} &amp; \cdots &amp; \frac{\partial^2f}{\partial x_1\partial x_n} \<br>\frac{\partial^2f}{\partial x_2\partial x_1} &amp; \frac{\partial^2f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2f}{\partial x_2\partial x_n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>\frac{\partial^2f}{\partial x_n\partial x_1} &amp; \frac{\partial^2f}{\partial x_n\partial x_2} &amp; \cdots &amp; \frac{\partial^2f}{\partial x_n^2}<br>\end{bmatrix}<br>$$</li><li><strong>Jacobi矩阵</strong>：<br>$$<br>\begin{bmatrix}<br>\frac{\partial y_1}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_1}{\partial x_n} \<br>\vdots &amp; \ddots &amp; \vdots \<br>\frac{\partial y_m}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_m}{\partial x_n}<br>\end{bmatrix}<br>$$</li></ol><p>不难发现：</p><ul><li>若 $f(x)$ 是一个标量函数，则 <strong>Jacobi矩阵是一个向量</strong>，等于 $f(x)$ 的梯度，Hesse矩阵是一个二维矩阵</li><li>若 $f(x)$ 是一个向量值函数，则 <strong>Jacobi矩阵是一个二维矩阵</strong>，Hesse矩阵是一个三维矩阵</li><li><strong>梯度是 Jacobi 矩阵的特例</strong>，梯度的 Jacobi 矩阵就是 Hesse 矩阵，这其实就是 <strong>一阶偏导与二阶偏导的关系</strong></li></ul><hr><h2 id="自动求导与链式法则">自动求导与链式法则</h2><p>在实际应用问题中，标量求导中的 <strong>链式法则</strong> 也可以拓展到向量乃至矩阵。在使用程序计算时，库函数一般采用 <strong>自动求导</strong> 方式，而不是一般的符号求导或数值求导。自动求导应用了链式法则，并将整个计算过程表示成一个 <strong>无环图</strong>，其中包括两种模式：</p><ol><li><strong>正向积累</strong>：<br>$$<br>\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{x}} =<br>\frac{\partial \boldsymbol{z}^{(i-1)}}{\partial \boldsymbol{x}} \cdot<br>\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{z}^{(i-1)}}<br>$$</li><li><strong>反向传递</strong>：<br>$$<br>\frac{\partial f}{\partial \boldsymbol{z}^{(i-1)}} =<br>\frac{\partial f}{\partial \boldsymbol{z}^{(i)}} \cdot<br>\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{z}^{(i-1)}}<br>$$</li></ol><p>反向传递过程需要存储中间变量，导致内存复杂度比正向积累高。</p><p>其在实际场景中的主要应用就是神经网络，在神经网络的正向传播中，我们将输入数据通过网络层逐层传递，计算出最终的输出值。我们的目标是计算神经网络的输出$\hat{y}$和损失函数$\mathcal{L}$的值。而反向传播用于计算损失函数对所有网络参数的梯度。</p><p>在实际应用问题中，由于反向传播的链路过长，涉及到多次激活函数关于净输入的偏导数矩阵、当前层输入关于净输入的偏导数矩阵的连乘，如果这个矩阵的谱半径小于一，那么随着反向传播的进行，回传的梯度信号衰减地越厉害，这使得越是网络浅层的参数地梯度越微弱，那么其越难得到很好地更新。这就是<strong>梯度消失</strong>问题。</p>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：矩阵级数</title>
    <link href="https://blog.yokumi.cn/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%A7%E6%95%B0/"/>
    <id>https://blog.yokumi.cn/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%A7%E6%95%B0/</id>
    <published>2025-01-14T08:48:00.000Z</published>
    <updated>2025-05-10T12:17:54.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="矩阵级数介绍">矩阵级数介绍</h3><p>在数学分析中，级数（特别是幂级数）的理论占有重要地位。在建立矩阵分析的理论时，矩阵级数，特别是幂级数，是建立矩阵函数的理论基础。</p><p>类似数列级数，我们给出其收敛、发散以及和的定义。</p><h4 id="定义-1">定义 1</h4><p>把矩阵序列所形成的无穷和 $A^{(0)} + A^{(1)} + A^{(2)} + \cdots + A^{(k)} + \cdots$ 称为 <strong>矩阵级数</strong>，记为 $\sum_{k = 0}^{\infty} A^{(k)}$。则有：<br>$$<br>\sum_{k=0}^\infty A^{(k)} = A^{(0)} + A^{(1)} + A^{(2)} + \cdots + A^{(k)} + \cdots<br>$$</p><h4 id="定义-2">定义 2</h4><p>记 $S^{(N)} = \sum_{k=0}^N A^{(k)}$，称其为矩阵级数的部分和。如果矩阵序列 ${S^{(N)}}$ <strong>收敛</strong>，且有极限 $S$，则有：<br>$$<br>\lim_{N \to \infty} S^{(N)} = S<br>$$<br>那么就称矩阵级数收敛，并且有 $S$，记为：<br>$$<br>S = \sum_{k=0}^\infty A^{(k)}<br>$$<br>不收敛的矩阵称为 <strong>发散</strong> 的。</p><p>若用 $s_{ij}$ 表示 $S$ 的第 $i$ 行第 $j$ 列元素，那么，和 $\sum_{k=0}^N A^{(k)} = S^{(N)}$ 的意义是：<br>$$<br>\sum_{k = 0}^{\infty}a_{ij}^{(k)} = s_{ij}, \quad (i=1,2,\dots,m; \quad j=1,2,\dots,n)<br>$$</p><h4 id="定义-3">定义 3</h4><p>如果上述级数中 $mn$ 个数项级数都是绝对收敛的，则称矩阵级数是 <strong>绝对收敛</strong> 的。</p><p>我们不再赘述有关矩阵级数绝对收敛的一些判别和性质，而是将重点放在矩阵的幂级数上。</p><p>首先，我们看一个比较简单的方阵幂级数。</p><h4 id="定理-1">定理 1</h4><p>方阵 $A$ 的 <strong>幂级数（Neumann 级数）</strong><br>$$<br>\sum_{k = 0}^{\infty} A^k = I + A + A^2 + \dots + A^k + \dots<br>$$<br>收敛的充要条件是 $A$ 为收敛矩阵，并且在其收敛时，其和为 $(I - A)^{-1}$。</p><p>如果用级数和来估算部分和矩阵，会存在一定误差：</p><h4 id="定理-2">定理 2</h4><p>设方阵 $A$ 对某一矩阵范数 $\Vert \cdot \Vert$ 有 $\Vert A\Vert &lt; 1$，则对任何非负整数 $N$，以 $(I-A)^{-1}$ 为部分和 $I + A + A^2 + \dots + A^N$ 的近似矩阵时，其误差为：<br>$$<br>\Vert (I-A)^{-1} - (I + A + A^2 + \dots + A^N)\Vert \le \frac{\Vert A\Vert ^{N+1}}{1 - \Vert A\Vert}<br>$$</p><p>现在，我们继续将矩阵幂级数 $\sum_{k = 0}^{\infty} c_kA^k$ 与对应的纯量幂级数 $\sum_{k = 0}^{\infty} c_kz^k$ 建立联系。</p><h4 id="定理-3">定理 3</h4><p>设幂级数<br>$$<br>f(z) = \sum_{k = 0}^{\infty}c_kz^k<br>$$<br>的收敛半径为 $r$，如果方阵 $A$ 满足 $\rho (A) &lt; r$，则矩阵幂级数<br>$$<br>\sum_{k = 0}^{\infty}c_kA^k<br>$$<br>是绝对收敛的；如果 $\rho (A) &gt; r$，则矩阵幂级数是发散的。</p>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：矩阵序列</title>
    <link href="https://blog.yokumi.cn/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BA%8F%E5%88%97/"/>
    <id>https://blog.yokumi.cn/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BA%8F%E5%88%97/</id>
    <published>2025-01-14T08:44:00.000Z</published>
    <updated>2025-05-10T12:17:54.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵序列介绍">矩阵序列介绍</h2><p>在《线性代数》课程中主要学习了矩阵的代数运算，我们继续将《数学分析》中的理论推广至矩阵空间，对于矩阵的分析，类似数列，我们同样从极限理论开始，介绍矩阵序列的极限运算。</p><h3 id="定义">定义</h3><p>设 ${A^{(k)}}<em>{k=1}^\infty$ 是一个矩阵序列，其中 $A^{(k)} \in \mathbb{C}^{m \times n}$。当 $a</em>{ij}^{(k)} \to a_{ij}(k \to \infty)$ 时，称 ${A^{(k)}}$ 收敛，或成矩阵 $A = (a_{ij})<em>{m \times n}$ 为 ${A^{(k)}}$ 的极限，或称 ${A^{(k)}}$ 收敛于 $A$，记为<br>$$<br>\lim</em>{k \to \infty} A^{(k)} = A, A^{(k)} \to A<br>$$<br>不收敛的矩阵序列称为 <strong>发散</strong>。</p><p>同样，矩阵序列收敛有很多与数列收敛类似的性质，此处不再赘述，继续往下研究其收敛的等价条件。</p><h3 id="定理">定理</h3><p><strong>定理 1</strong> 设 $A^{(k)} \in \mathbb{C}^{m \times n}$，则</p><ol><li>$A^{(k)} \to O$ 的充要条件是 $\Vert A^{(k)}\Vert \to 0$；</li><li>$A^{(k)} \to A$ 的充要条件是 $\Vert A^{(k)} - A \Vert \to 0$；</li></ol><p>这里，$\Vert \cdot \Vert$ 是 $\mathbb{C}^{m \times n}$ 上任何一种矩阵范数。</p><p>至此，我们将矩阵收敛的判断与范数建立了联系。</p><h3 id="定义-2">定义</h3><p><strong>定义 1</strong> 矩阵序列 ${A^{(k)}}$ 称为 <strong>有界</strong> 的，如果存在常数 $M &gt; 0$，使得对于一切 $k$ 都有<br>$$<br>\left | a_{ij}^{(k)}\right | &lt; M(i = 1,2,\dots,m;j = 1,2,\dots,n)<br>$$</p><p><strong>定义 2</strong> 设 $A$ 为方阵，且 $A^k \to O(k \to \infty)$，则称 $A$ 为 <strong>收敛矩阵</strong>。</p><h3 id="定理-2">定理</h3><p><strong>定理 2</strong> $A$ 为收敛矩阵的充要条件是 $\rho(A) &lt; 1$。</p><p><strong>定理 3</strong> $A$ 为收敛矩阵的充分条件是只要有一种矩阵范数 $\left|\cdot\right|$，使得 $\Vert A \Vert &lt; 1$。</p>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：矩阵可逆性条件、条件数和谱半径介绍</title>
    <link href="https://blog.yokumi.cn/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%8F%AF%E9%80%86%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%80%81%E6%9D%A1%E4%BB%B6%E6%95%B0%E5%92%8C%E8%B0%B1%E5%8D%8A%E5%BE%84%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.yokumi.cn/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%8F%AF%E9%80%86%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%80%81%E6%9D%A1%E4%BB%B6%E6%95%B0%E5%92%8C%E8%B0%B1%E5%8D%8A%E5%BE%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-01-13T08:40:00.000Z</published>
    <updated>2025-05-10T12:17:54.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵可逆性条件、条件数和谱半径介绍">矩阵可逆性条件、条件数和谱半径介绍</h2><p>在明确了范数的定义后，我们对它的几点应用进行列举。</p><h3 id="定理-2-6">定理 2.6</h3><p>设 $A\in \mathbb{C}^{n \times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A \Vert  &lt; 1$，则矩阵 $I-A$ 可逆（非奇异），且有：</p><p>$$<br>\Vert (I - A)^{-1} \Vert  \leq \frac{\Vert  I \Vert }{1 - \Vert  A \Vert }<br>$$</p><h3 id="定理-2-7">定理 2.7</h3><p>设 $A\in \mathbb{C}^{n \times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A \Vert  &lt; 1$，则有：</p><p>$$<br>\Vert I - (I - A)^{-1} \Vert  \leq \frac{\Vert  A \Vert }{1 - \Vert  A \Vert }<br>$$</p><h3 id="逆矩阵的摄动">逆矩阵的摄动</h3><p>在实际应用问题中，矩阵参数往往为非准确值，即带有误差 $\delta$，我们希望其构成的近似矩阵 $A$ 的逆矩阵 $A^{-1}$ 与准确矩阵 $A + \delta a_{ij}(i,j = 1,2,\dots,n)$ 的逆矩阵 $(A + \delta a_{ij})^{-1}$ 尽量接近。</p><p>一般称 $\delta a_{ij}$ 为 <strong>扰动</strong>，$\delta A$ 为 $A$ 的 <strong>摄动矩阵</strong>。</p><h3 id="摄动定理">摄动定理</h3><p><strong>定理 2.8</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$ 且 $A$ 可逆，$B\in \mathbb{C}^{n\times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A^{-1}B \Vert  &lt; 1$，则有：</p><ul><li>$A + B$ 可逆；</li><li>记 $F = I - (I + A^{-1}B)^{-1}$，则 $\Vert F \Vert \leq \frac{\Vert A^{-1}B \Vert }{1 - \Vert A^{-1}B \Vert }$；</li><li>$\frac{\Vert A^{-1} - (A + B)^{-1} \Vert }{A^{-1}} \leq \frac{\Vert  A^{-1}B \Vert }{1 - \Vert  A^{-1}B \Vert }$。</li></ul><p>若令 $\delta$ 是个小量，并且令</p><p>$$<br>cond(A) = \Vert A \Vert \Vert A^{-1}\Vert<br>$$</p><p>则当 $\Vert A^{-1}\Vert \Vert \delta A \Vert &lt; 1$ 时，</p><p>$$<br>\frac{\Vert A^{-1} - (A + \delta A)^{-1}\Vert}{\Vert A^{-1}\Vert}\leq \frac{cond(A)\frac{\Vert \delta A\Vert}{\Vert A\Vert}}{1 - cond(A)\frac{\Vert\delta A\Vert}{\Vert A\Vert}}<br>$$</p><p>称 $cond(A)$ 为矩阵 $A$ 的 <strong>条件数</strong>，一般情况下，条件数越大，$(A + \delta A)^{-1}$ 和 $A^{-1}$ 的相对误差就越大。往往在用算法进行矩阵求逆时，先计算条件数，判断矩阵的逆是否“好求”。</p><h3 id="矩阵谱半径">矩阵谱半径</h3><p><strong>定义</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$ 的 $n$ 个特征值为 $\lambda_1,\lambda_2,\dots,\lambda_n$，称</p><p>$$<br>\rho (A) = \max\limits_{i}\left|\lambda_i\right|<br>$$</p><p>为 $A$ 的 <strong>谱半径</strong>。</p><p><strong>定理 2.9</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$，则对 $\mathbb{C}^{n\times n}$ 上任何一种矩阵范数 $\Vert  \cdot  \Vert $，都有</p><p>$$<br>\rho (A) \leq \Vert  A \Vert<br>$$</p><p><strong>定理 2.10</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$，对 $\forall \epsilon &gt; 0,\exists \Vert  \cdot  \Vert ,s.t.$</p><p>$$<br>\Vert  A  \Vert _M \leq \rho (A) + \epsilon<br>$$</p><p>由上述定理可见，谱半径小于等于任意矩阵范数，同时也必存在一个算子范数，小于等于谱半径加上一个很小的正数。</p><h3 id="谱半径在迭代法中的应用">谱半径在迭代法中的应用</h3><p>谱半径在数值分析和迭代法中起到了关键作用，尤其是在矩阵幂法、迭代求解线性方程组的收敛性分析等领域。例如，当利用迭代法解线性方程组时，谱半径决定了迭代矩阵是否收敛。</p><p><strong>定理 2.11</strong></p><p>在数值线性代数中，迭代法通常用于求解线性方程组 $Ax = b$。设迭代法的一般形式为：</p><p>$$<br>x^{(k+1)} = B x^{(k)} + c,<br>$$</p><p>其中，$B$ 为迭代矩阵，$c$ 为常向量，$k$ 为迭代次数。</p><p>迭代法的收敛性由迭代矩阵 $B$ 的谱半径决定：</p><ol><li><strong>必要条件</strong>：如果迭代法收敛，即 $x^{(k)} \to x^<em>$ ($x^</em>$ 为精确解)，则迭代矩阵 $B$ 的谱半径必须满足：$\rho(B) &lt; 1$；</li><li><strong>充分条件</strong>：如果 $\rho(B) &lt; 1$，则对于任意初始值 $x^{(0)}$，迭代法都会收敛到线性方程组的唯一解 $x^*$。</li></ol>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：向量范数与矩阵范数</title>
    <link href="https://blog.yokumi.cn/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/"/>
    <id>https://blog.yokumi.cn/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/</id>
    <published>2025-01-13T08:31:00.000Z</published>
    <updated>2025-05-10T12:17:54.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="向量范数与矩阵范数">向量范数与矩阵范数</h2><h3 id="向量范数介绍">向量范数介绍</h3><p>我们知道，对于数列极限，我们有</p><p>$$<br>\lim_{n \to \infty} a_n = M \iff \forall \epsilon &gt; 0,\exists N &gt; 0,s.t. \forall n&gt;N,\left |  {a_n - M}  \right | &lt; \epsilon.<br>$$</p><p>在 $n$ 维向量空间 $R^n$ 内，我们希望对于一个向量序列 ${x^{(k)}}$，其中 $x^{(k)}= (\xi_1^{(k)},\xi_2^{(k)},\dots, \xi_n^{(k)})(k = 1,2,3,\dots)$。如果对于每一个分量 $\xi_i^{(k)}$，都有 $\lim_{k \to \infty} \xi_i^{(k)} = \xi_i$，即</p><p>$$<br>\lim_{k \to \infty} x^{(k)} = (\xi_1, \xi_2, \dots, \xi_n) = x<br>$$</p><p>则称向量序列 ${x^{(k)}}$ 收敛于 $x$。</p><p>但是，我们还是无法解决 $\left| x^{(k)} - x\right|$ 该如何定义和计算，显然它不能用向量 $x^{(k)} - x$ 的长度来刻画。为此，我们定义向量范数如下。</p><h4 id="定义-2-1">定义 2.1</h4><p>如果 $V$ 是数域 $K$ 上的线性空间，且对于 $\forall x \in V$，定义一个实值函数 $\Vert  x \Vert $，它满足以下三个条件:</p><ol><li><strong>非负性</strong>: 当 $x \ne 0$ 时，$\Vert  x \Vert  &gt; 0$，当且仅当 $x = 0$ 时为 $0$;</li><li><strong>齐次性</strong>: $\forall a \in K, \forall x \in V, \Vert  ax \Vert  = \left| a \right| \Vert  x \Vert$;</li><li><strong>三角不等式</strong>: $\forall x, y \in V, \Vert  x + y \Vert  \leq \Vert  x \Vert  + \Vert  y \Vert$;</li></ol><p>则称 $\Vert  x \Vert$ 为向量 $x$ 的范数。</p><p>我们要判断某个实值函数 $\Vert  x \Vert$ 是否是范数，即验证其是否满足上述三条性质即可。以下列举几种常见的范数(在线性空间 $\mathbb{C}^n$，即酉空间中)：</p><ul><li><strong>1-范数</strong>: $\Vert  x \Vert  = \sum \left| \xi_i \right|$</li><li><strong>2-范数</strong>: $\Vert  x \Vert  = \sqrt{(x,x)}$</li><li><strong>$\infty$-范数</strong>: $\Vert  x \Vert  = \max \left| x_i\right|$</li><li><strong>p-范数</strong>: $\Vert  x \Vert <em>p = (\sum</em>{i = 1}^{n} {\left|x_i\right|}^p)^{\frac{1}{p}}, (1 \leq p &lt; \infty)$</li></ul><h4 id="定理-2-1">定理 2.1</h4><p>设有限维线性空间 $V^n$ 中任意两个向量范数 $\Vert  x_\alpha \Vert ,\Vert  x_\beta \Vert$，如果 $\exists c_1, c_2,s.t.$</p><p>$$<br>{c_1\Vert  x_\beta \Vert  \leq \Vert  x_\alpha \Vert  &lt; c_2\Vert  x_\beta \Vert }<br>$$</p><p>则称向量范数 $\Vert  x_\alpha \Vert ,\Vert  x_\beta \Vert$ 等价。</p><h3 id="矩阵范数介绍">矩阵范数介绍</h3><p>对于矩阵空间 $\mathbb{C}^{m\times n}$，如果类似地将矩阵 $A_{m\times n}$ 看作“向量”，可以类似向量范数定义矩阵范数。但矩阵之间还有乘法运算，需要补充定义如下：</p><h4 id="定义-2-3">定义 2.3</h4><p>设 $A \in \mathbb{C}^{m\times n}$，定义一个实值函数 $\Vert  A \Vert$，它满足以下四个条件:</p><ol><li><strong>非负性</strong>: 当 $A \ne 0$ 时，$\Vert  A \Vert  &gt; 0$，当且仅当 $A = 0$ 时为 $0$;</li><li><strong>齐次性</strong>: $\forall \alpha \in C, \Vert  {\alpha A} \Vert  = \left| {\alpha} \right| \Vert  A \Vert$;</li><li><strong>三角不等式</strong>: $\Vert  A + B \Vert  \leq \Vert  A \Vert  + \Vert  B \Vert$;</li><li><strong>相容性</strong>: $\Vert  AB \Vert  \leq \Vert  A \Vert  \Vert  B \Vert$ (对于 $B \in \mathbb{C}^{n\times l}$)。</li></ol><p>则称 $\Vert  A \Vert$ 为矩阵 $A$ 的范数。</p><p>在数值方法中进行某种估计时，多数情况下，矩阵范数与向量范数常混合使用，而矩阵经常是作为两个线性空间上的线性变换出现的，为此引入矩阵范数和向量范数相容的概念如下：</p><h4 id="定理2-2">定理2.2</h4><p>对于$\mathbb{C}^{m \times n}$的矩阵范数$\Vert {\cdot} \Vert _M$和$\mathbb{C}^m,\mathbb{C}^n$上的同类向量范数$\Vert {\cdot} \Vert _V$，如果有</p><p>$$</p><p>\Vert Ax \Vert _V \leq \Vert A \Vert _M \Vert x \Vert _V(\forall A \in \mathbb{C}^{m \times n}, \forall x \in \mathbb{C}^n)</p><p>$$</p><p>则称矩阵范数$\Vert {\cdot} \Vert _M$与向量范数$\Vert {\cdot} \Vert _V$是相容的。</p><p>以下列举几种常用的矩阵范数：</p><ul><li><strong>F-范数</strong>: $\Vert  A \Vert <em>F = (\sum</em>{i = 1}^{m}\sum_{j = 1}^{n}\left|a_{ij}\right|^2)^{\frac{1}{2}} = (tr(A^H A))^{\frac{1}{2}}$</li></ul><p>其中，F-范数有一定理如下：</p><h4 id="定理-2-3">定理 2.3</h4><p>设 $A \in \mathbb{C}^{m \times n}$，且 $P \in \mathbb{C}^{m\times m}, Q\in \mathbb{C}^{n \times n}$ 都是酉矩阵，则有</p><p>$$<br>\Vert PA \Vert _F = \Vert A \Vert _F = \Vert AQ \Vert _F<br>$$</p><p>即 $A$ 左乘或右乘酉矩阵后，其 $\Vert {\cdot} \Vert$ 不变。</p><p>矩阵函数可以通过如下方法进行定义，并且定义的矩阵函数与已知的向量范数相容。</p><h4 id="定理2-4">定理2.4</h4><p>已知$\mathbb{C}^{m},\mathbb{C}^{n}$上的同类向量范数$\Vert {\cdot} \Vert$。设$A\in \mathbb{C}^{m\times n}$，则函数<br>$$<br>\Vert {A} \Vert = \max\limits_{\Vert x \Vert = 1}{\Vert {Ax} \Vert }<br>$$</p><p>是$\mathbb{C}^{m\times n}$上的矩阵范数，且与已知的向量范数相容。</p><p>分别取向量$x$的范数为$\Vert x \Vert _1,\Vert x \Vert _2,\Vert x \Vert _{\infty}$时，就可以得到以下三种矩阵范数：</p><h4 id="定理-2-5">定理 2.5</h4><p>设 $A = (a_{ij})_{m\times n} \in \mathbb{C}^{m\times n}$，可以得到以下三种矩阵范数的计算公式分别为:</p><ol><li><strong>列和范数</strong>: $\Vert A \Vert <em>1 = \max\limits</em>{j} \sum_{i = 1}^{m}\left|a_{ij}\right|$;</li><li><strong>谱范数</strong>: $\Vert A \Vert _2 = \sqrt{\max{\lambda(A^HA)}}$;</li><li><strong>行和范数</strong>: $\Vert A \Vert <em>{\infty} = \max\limits</em>{i} \sum_{j=1}^{n}\left|a_{ij}\right|$;</li></ol><p>在机器学习中，范数作为数学优化的重要工具，广泛应用于高维优化问题中，其具体表现和影响在模型的性能、计算复杂度、正则化等方面有重要体现。</p><p>在高维优化中，目标函数往往包含范数，用于度量模型参数或残差的大小；在机器学习模型训练中，损失函数通常衡量预测值与真实值之间的差距，而范数决定了误差的度量方式，例如L-1损失、L-2损失；正则化通过添加范数约束减少模型复杂度，缓解高维数据中的过拟合问题，例如L-1正则化，L-2正则化。</p><p>以上应用场景中，范数的引入通过度量大小、限制复杂性和提升泛化能力，影响了模型的性能和稳定性。选择合适的范数类型能有效在稀疏性、平滑性和数值稳定性之间实现权衡。</p>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：欧式空间中线性变换的求法</title>
    <link href="https://blog.yokumi.cn/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E6%B1%82%E6%B3%95/"/>
    <id>https://blog.yokumi.cn/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E6%B1%82%E6%B3%95/</id>
    <published>2025-01-12T08:27:00.000Z</published>
    <updated>2025-05-10T12:17:54.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欧式空间中线性变换的求法">欧式空间中线性变换的求法</h2><p>有了前两节的铺垫，下面，我们正式介绍欧式空间中线性变换的求法。</p><p>我们将问题描述如下：</p><p><strong>问题描述：</strong></p><ul><li>在欧式空间中给定线性变换 $T: \mathbb{V}^n \to \mathbb{V}^n$，比如：$T( \boldsymbol{X}) =  \boldsymbol{X} \boldsymbol{B}(\forall  \boldsymbol{X} \in \mathbb{V})$，其中 $\boldsymbol{B}$ 给定。</li><li><strong>目标：</strong> 寻找一组新基，使得 $T$ 在这组基下的矩阵表示为对角矩阵 $\boldsymbol{\Lambda}$ 或 Jordan 标准型 $\boldsymbol{J}$。</li></ul><p>首先，我们以课本 [矩阵论] 中的例题 1.36 为例，说明对称变换的求法：</p><h3 id="例-1-36">例 1.36</h3><p>在欧氏空间 $\mathbb{R}^{2 \times 2}$ 中，矩阵 $\boldsymbol{A}$ 与 $\boldsymbol{B}$ 的内积定义为 $$( \boldsymbol{A},  \boldsymbol{B})=tr ( \boldsymbol{A}^\top  \boldsymbol{B})$$，子空间</p><p>$$<br>V=\left{ \boldsymbol{X} =\begin{bmatrix} x_{1} &amp; x_{2}\ x_{3} &amp; x_{4} \end{bmatrix} \mid x_{3}-x_{4}=0\right}<br>$$</p><p>$V$ 中的线性变换为</p><p>$$<br>T( \boldsymbol{X})= \boldsymbol{X}  \boldsymbol{B}<em>{0}\quad (\forall  \boldsymbol{X} \in V), \boldsymbol{B}</em>{0}=\begin{bmatrix} 1 &amp; 2 \ 2 &amp; 1 \end{bmatrix}<br>$$</p><ol><li>求 $V$ 的一个标准正交基；</li><li>验证 $T$ 是 $V$ 中的对称变换；</li><li>求 $V$ 的一个标准正交基，使 $T$ 在该基下的矩阵为对角矩阵。</li></ol><h3 id="解：">解：</h3><h4 id="1-先找到一组普通的基，再进行-Schmidt-正交化">(1) 先找到一组普通的基，再进行 Schmidt 正交化</h4><p>$$<br>\boldsymbol{X}=\begin{bmatrix} x_{1} &amp; x_{2} \ x_{3} &amp; x_{4} \end{bmatrix}=x_{1}\begin{bmatrix} 1 &amp; 0 \ 0 &amp; 0 \end{bmatrix}+x_{2}\begin{bmatrix} 0 &amp; 1 \ 0 &amp; 0 \end{bmatrix}+x_{3}\begin{bmatrix} 0 &amp; 0 \ 1 &amp; 1 \end{bmatrix}<br>$$</p><p>一组标准正交基为：</p><p>$$<br>\boldsymbol{X}_1 = \begin{bmatrix} 1 &amp; 0\ 0 &amp; 0 \end{bmatrix} \quad \boldsymbol{X}_2 = \begin{bmatrix} 0 &amp; 1\ 0 &amp; 0 \end{bmatrix} \quad \boldsymbol{X}_3 = \frac{1}{\sqrt{2}}\begin{bmatrix} 0 &amp; 0\ 1 &amp; 1 \end{bmatrix}<br>$$</p><h4 id="2-计算-T-在这组基下的矩阵表示">(2) 计算 $T$ 在这组基下的矩阵表示</h4><p>$$<br>T(\boldsymbol{X}_1 , \boldsymbol{X}_2, \boldsymbol{X}_3) = (\boldsymbol{X}_1 , \boldsymbol{X}_2, \boldsymbol{X}_3)\boldsymbol{A} \Rightarrow \boldsymbol{A} = \begin{bmatrix} 1 &amp; 2 &amp; 0\ 2 &amp; 1 &amp; 0\ 0 &amp; 0 &amp; 3 \end{bmatrix}<br>$$</p><h4 id="3-计算新的正交基，使-T-在该基下为对角矩阵">(3) 计算新的正交基，使 $T$ 在该基下为对角矩阵</h4><p>$$<br>\boldsymbol{A} =  \boldsymbol{Q}  \boldsymbol{\Lambda}  \boldsymbol{Q}^\top<br>$$</p><p>其中：</p><p>$$<br>\boldsymbol{\Lambda}= \begin{bmatrix} 3 &amp; &amp; \ &amp; 3 &amp; \ &amp; &amp; -1 \end{bmatrix} \quad \boldsymbol{Q}=\begin{bmatrix} 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} \ 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} \ 1 &amp; 0 &amp; 0 \end{bmatrix}<br>$$</p><p>计算得到的新基：</p><p>$$<br>\boldsymbol{Y}_1 = \frac{1}{\sqrt{2}}\begin{bmatrix} 0 &amp; 0\ 1 &amp; 1 \end{bmatrix} \quad \boldsymbol{Y}_2 = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1\ 0 &amp; 0 \end{bmatrix} \quad \boldsymbol{Y}_3 = \frac{1}{\sqrt{2}}\begin{bmatrix} -1 &amp; 1\ 0 &amp; 0 \end{bmatrix}<br>$$</p><h2 id="线性变换的一般求法">线性变换的一般求法</h2><p>若 $V$ 是欧式空间，$T$ 是 $V$ 上的一个线性变换：</p><ol><li><p>任意找到 $V$ 的一个基，并通过 Schmidt 正交化法得到 $V$ 的一个标准正交基，记为 $e_1,e_2,\cdots,e_n$；</p></li><li><p>求 $T$ 在该标准正交基下的矩阵表示 $\boldsymbol{A}_0$：</p><p>$$ T(e_1,e_2,\cdots,e_n) = (e_1,e_2,\cdots,e_n)\boldsymbol{A}_0 $$</p></li><li><p>将 $\boldsymbol{A}_0$ 化为 Jordan 标准型 $\boldsymbol{J}$：</p><p>$$ \boldsymbol{A}_0 = \boldsymbol{P}\boldsymbol{J} \boldsymbol{P}^{-1} $$</p></li><li><p>右乘 $\boldsymbol{P}$：</p><p>$$ T(e_1,e_2,\cdots,e_n)\boldsymbol{P} = (e_1,e_2,\cdots,e_n)\boldsymbol{P}\boldsymbol{J} $$</p></li><li><p>取新基 $(\boldsymbol{E}_1, \boldsymbol{E}_2, \cdots, \boldsymbol{E}_n) = (\boldsymbol{e}_1 , \boldsymbol{e}_2, \cdots, \boldsymbol{e}_n)\boldsymbol{P}$，则线性变换在新基下的矩阵表示为 $\boldsymbol{J}$。</p></li></ol><p>以上方法可用于简化计算，使得多项式函数 $z = (T^k)(x),x\in V$ 的求解更加简便。</p>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：若尔当标准型</title>
    <link href="https://blog.yokumi.cn/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B/"/>
    <id>https://blog.yokumi.cn/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B/</id>
    <published>2025-01-12T08:18:00.000Z</published>
    <updated>2025-05-10T12:17:54.365Z</updated>
    
    <content type="html"><![CDATA[<p>线性变换既然有矩阵表示，我们希望其应用到向量上得到的象能方便得到，即我们希望线性变换对应的矩阵尽量简单，比如能变为对角矩阵。为此，我们首先引入线性变换的特征值和特征向量，它和普通方阵类似。</p><h4 id="特征值与特征向量">特征值与特征向量</h4><p><strong>定义 1</strong> 设 $T: V \to V$ 是一个线性变换，如果存在 $\lambda_0 \in K$，使得存在非零向量 $x \in V$ 满足：<br>$$ T x = \lambda_0 x$$<br>那么我们称 $\lambda_0$ 是 $T$ 的<strong>特征值</strong>，$x$ 是 $T$ 属于 $\lambda_0$ 的<strong>特征向量</strong>。</p><p><strong>定义 2</strong> 设 $\boldsymbol{A} = (a_{ij})<em>{n\times n}$ 是数域 $K$ 上的 $n$ 阶矩阵，$\lambda$ 是参数，$\boldsymbol{A}$ 的特征矩阵 $\lambda I - A$ 的行列式：<br>$$<br>\det (\lambda I-A) = \begin{vmatrix}<br>\lambda-a</em>{11} &amp; -a_{12} &amp; \cdots &amp; -a_{1n} \<br>-a_{21} &amp; \lambda-a_{22} &amp; \cdots &amp; -a_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>-a_{n1} &amp; -a_{n2} &amp; \cdots &amp; \lambda-a_{nn}<br>\end{vmatrix}<br>$$<br>称为矩阵 $\boldsymbol{A}$ 的<strong>特征多项式</strong>，记为 $\varphi(\lambda)$。它的根 $\lambda_0$ 称为 $\boldsymbol{A}$ 的<strong>特征值</strong>，而对应的非零解向量 $(\xi_1, \xi_2, \dots, \xi_n)^T$ 称为 $\boldsymbol{A}$ 的属于特征值 $\lambda_0$ 的<strong>特征向量</strong>。</p><h3 id="最小多项式">最小多项式</h3><p><strong>定义 3</strong> 设 $\boldsymbol{A}$ 的首项系数为 $1$，次数最小，且以 $\boldsymbol{A}$ 为根的 $\lambda$ 的多项式，称为 $\boldsymbol{A}$ 的<strong>最小多项式</strong>，记为 $m(\lambda)$。</p><h3 id="最小多项式与特征多项式的关系">最小多项式与特征多项式的关系</h3><p><strong>定理 1</strong> 设矩阵 $\boldsymbol{A}$ 的最小多项式 $m(\lambda)$ 可整除以 $\boldsymbol{A}$ 为根的任一首 $1$ 多项式 $\psi(\lambda)$，且 $m(\lambda)$ 是唯一的。</p><p><strong>定理 2</strong> 矩阵 $\boldsymbol{A}$ 的最小多项式 $m(\lambda)$ 与其特征多项式 $\varphi(\lambda)$ 的零点相同（不计重数）。</p><p><strong>定理 3</strong> 设 $n$ 阶矩阵 $\boldsymbol{A}$ 的特征多项式为 $\varphi(\lambda)$，特征矩阵 $\lambda I - A$ 的全体 $n-1$ 阶子式的最大公因式为 $d(\lambda)$，则 $\boldsymbol{A}$ 的最小多项式为：<br>$$ m(\lambda) = \frac{\varphi(\lambda)}{d(\lambda)} $$</p><h3 id="Jordan-标准型">Jordan 标准型</h3><p><strong>定义 4</strong> 设矩阵 $\boldsymbol{J}$ 由以下 Jordan 块构成：<br>$$<br>\boldsymbol{J} = \begin{bmatrix}<br>\boldsymbol{J}_1(\lambda_1) &amp; &amp; &amp; \<br>&amp; \boldsymbol{J}_2(\lambda_2) &amp; &amp; \<br>&amp; &amp; \ddots &amp; \<br>&amp; &amp; &amp; \boldsymbol{J}_s(\lambda_s)<br>\end{bmatrix}<br>$$<br>其中，Jordan 块的形式如下：<br>$$<br>\boldsymbol{J}_i(\lambda_i) =<br>\begin{bmatrix}<br>\lambda_i &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \<br>0 &amp; \lambda_i &amp; 1 &amp; \cdots &amp; 0 \<br>0 &amp; 0 &amp; \lambda_i &amp; \cdots &amp; 0 \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 1 \<br>0 &amp; 0 &amp; 0 &amp; \cdots &amp; \lambda_i<br>\end{bmatrix}<br>$$<br>称 $\boldsymbol{J}$ 为矩阵 $\boldsymbol{A}$ 的<strong>Jordan 标准型</strong>。</p><h3 id="计算-Jordan-标准型的步骤">计算 Jordan 标准型的步骤</h3><ol><li><p><strong>求矩阵 $\boldsymbol{A}$ 的初等因子组</strong>，设为：<br>$$ (\lambda - \lambda_1)^{m_1}, (\lambda - \lambda_2)^{m_2}, \dots, (\lambda - \lambda_s)^{m_s} $$<br>且 $m_1 + m_2 + \cdots + m_s = n$。</p></li><li><p><strong>写出每个初等因子对应的 Jordan 块</strong>。</p></li><li><p><strong>构造 Jordan 标准型</strong>：<br>$$ \boldsymbol{J} = \begin{bmatrix}<br>\boldsymbol{J}_1(\lambda_1) &amp; &amp; &amp; \<br>&amp; \boldsymbol{J}_2(\lambda_2) &amp; &amp; \<br>&amp; &amp; \ddots &amp; \<br>&amp; &amp; &amp; \boldsymbol{J}_s(\lambda_s)<br>\end{bmatrix}$$</p></li></ol><h3 id="计算工具">计算工具</h3><p>在实际计算中，Python 提供了强大的 <code>NumPy</code> 和 <code>SymPy</code> 库，可以用于快速计算 Jordan 标准型。</p>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>矩阵论：欧式空间与线性变换介绍</title>
    <link href="https://blog.yokumi.cn/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.yokumi.cn/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-01-12T07:45:00.000Z</published>
    <updated>2025-05-10T12:17:54.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欧式空间与线性变换介绍">欧式空间与线性变换介绍</h2><p>欧式（Euclid）空间作为一种特殊的线性空间，我们先引入线性空间的概念。</p><h3 id="定义-1-线性空间">定义 1: 线性空间</h3><p>设 $V$ 是一个非空集合，它的元素用 $x, y, z$ 等表示，称为向量；$K$ 是一个数域，它的元素用 $k, l, m$ 表示，如果 $V$ 满足以下条件：</p><ol><li><p>在 $V$ 中定义一个加法运算，即当 $x,y\in V$ 时，有唯一的和 $x + y\in V$，且满足以下性质：</p><ul><li><strong>结合律</strong>: $x + (y + z) = (x + y) + z$;</li><li><strong>交换律</strong>: $x + y = y + x$;</li><li><strong>零元素存在性</strong>: $\exists 0, s.t. x + 0 = x$;</li><li><strong>负元素存在性</strong>: $\forall x\in V,\exists y\in V, s.t.x + y = 0$，记 $y = -x$;</li></ul></li><li><p>在 $V$ 中定义数乘运算，即当 $x\in V,k \in K$ 时，有唯一的乘积 $kx\in V$，且满足以下性质：</p><ul><li><strong>因子分配律</strong>: $k(x+y) = kx + ky$;</li><li><strong>分配律</strong>: $(k+l)x = kx + lx$;</li><li><strong>结合律</strong>: $k(lx) = (kl)x$;</li><li><strong>中性元</strong>: $1 x = x$;</li></ul></li></ol><p>则称 $V$ 是数域 $K$ 上的线性空间。</p><p>定义中的 8 条性质非常重要。如果对于数域 $K$，向量空间 $V$，设加群 $(V, +)$（$+$ 为 $V$ 上满足交换律的运算），不难验证其满足群的定义。定义 $K \times V \rightarrow V: (k, \alpha) \rightarrow k\alpha$（即 $V$ 上的数乘运算），可以验证 $V$ 是一个 $K$-模。即，线性空间是一类特殊的模。</p><p>为借助数量运算以实现向量的运算，还要引入向量的坐标。</p><h3 id="定义-2-线性空间的基">定义 2: 线性空间的基</h3><p>设 $V$ 是数域 $K$ 上的线性空间，$x_1,x_2,\cdots,x_r\in V$，如果它满足：</p><ol><li>$x_1,x_2,\cdots,x_r$ 线性无关;</li><li>$\forall x \in V$ 都是 $x_1,x_2,\cdots,x_r$ 的线性组合;</li></ol><p>则称 $x_1,x_2,\cdots,x_r$ 是 $V$ 的一个 <strong>基</strong>，称 $x_i(i=1,2,\cdots,r)$ 为 <strong>基向量</strong>。</p><h3 id="定义-3-坐标系">定义 3: 坐标系</h3><p>称线性空间 $V^n$ 上的一个基 $x_1, x_2, \cdots, x_n$ 为 $V^n$ 的一个 <strong>坐标系</strong>。设向量 $x \in V^n$，它在该基下的线性表示式为</p><p>$$<br>x = \xi_1x_1 + \xi_2x_2 + \cdots + \xi_nx_n<br>$$</p><p>则称 $\xi_1,\xi_2,\cdots,\xi_n$ 为 $x$ 在该基下的 <strong>坐标</strong> 或 <strong>分量</strong>，记为</p><p>$$<br>(\xi_1,\xi_2,\cdots,\xi_n)^\top<br>$$</p><p>显然，线性空间 $V^n$ 存在多个不同的基，对应多个不同的坐标系，我们希望研究当基改变时，向量的坐标如何改变。</p><h3 id="基变换">基变换</h3><p>首先介绍 <strong>基变换</strong>，即 $V^n$ 的一个基 $\boldsymbol{X} = ( \boldsymbol{x}_1,  \boldsymbol{x}_2, \cdots,  \boldsymbol{x}_n)$ 变为另一个基 $\boldsymbol{Y} = ( \boldsymbol{y}_1,  \boldsymbol{y}_2, \cdots,  \boldsymbol{y}_n)$。</p><p>由基的定义可知：</p><p>$$<br>\boldsymbol{y}<em>i = c</em>{1i} \boldsymbol{x}<em>1 + c</em>{2i}  \boldsymbol{x}<em>2 + \cdots + c</em>{1n}  \boldsymbol{x}_n(i = 1,2,\cdots,n)<br>$$</p><p>上式可以写成矩阵乘法形式：</p><p>$$<br>( \boldsymbol{y}_1,  \boldsymbol{y}_2, \cdots,  \boldsymbol{y}_n) =<br>( \boldsymbol{x}_1,  \boldsymbol{x}_2, \cdots,  \boldsymbol{x}_n) \boldsymbol{C}<br>\tag{2.5.1}<br>$$</p><p>其中矩阵</p><p>$$<br>\boldsymbol{C} = \begin{bmatrix}<br>c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n}\<br>c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n}\<br>\vdots &amp; \vdots &amp; &amp; \vdots\<br>c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn}<br>\end{bmatrix}<br>$$</p><p>称为基变换的 <strong>过渡矩阵</strong>，式 (2.5.1) 称为 <strong>基变换公式</strong>。</p><p>显然，过渡矩阵是可逆矩阵，因为新基能变换为旧基。</p><h2 id="内积与欧式空间">内积与欧式空间</h2><p>在线性空间中，向量的基本运算仅为线性运算。例如，在熟悉的二维或三维向量空间中，我们发现向量的模长、向量间的夹角等度量概念未能被线性空间直接表达。因此，我们引入<strong>内积</strong>与<strong>内积空间</strong>的概念。</p><h3 id="内积的定义">内积的定义</h3><p><strong>定义</strong><br>设 $V$ 是实数域 $\mathbb{R}$ 上的线性空间，若对 $\forall x,y \in V$，按照某种规则定义一个实数 $(x,y)$，满足以下条件：</p><ol><li><strong>交换律</strong>：$(x,y) = (y,x)$；</li><li><strong>分配律</strong>：$(x,y+z) = (x,y) + (x,z)$；</li><li><strong>齐次性</strong>：$(kx,y) = k(x,y) = (x,ky), \forall k\in \mathbb{R}$；</li><li><strong>非负性</strong>：$(x,x) \geq 0$，且 $(x,x) = 0 \iff x = 0$。</li></ol><p>则称 $(x,y)$ 为向量 $x,y$ 的<strong>内积</strong>，称 $V$ 为<strong>欧式空间</strong>（Euclidean Space）。</p><h3 id="内积的性质">内积的性质</h3><p>内积具有以下基本性质：</p><ul><li>$( \boldsymbol{x}, k \boldsymbol{y}) = k( \boldsymbol{x}, \boldsymbol{y})$；</li><li>$( \boldsymbol{x}, \boldsymbol{0}) = 0$。</li></ul><h3 id="向量的模长">向量的模长</h3><p>在欧式空间中，我们可以定义向量的<strong>长度</strong>（模、范数）如下：</p><p><strong>定义</strong><br>在欧式空间 $V$ 中，非负实数<br>$$<br>\left|  \boldsymbol{x} \right| = \sqrt{( \boldsymbol{x}, \boldsymbol{x})}<br>$$<br>称为向量 $\boldsymbol{x}$ 的<strong>长度</strong>（或 <strong>2-范数</strong>，下一节将介绍）。</p><p><strong>单位向量与单位化</strong><br>在二维或三维向量空间中，通常选取 $(1,0,0)$ 等为坐标轴，这些长度为 $1$ 的向量称为<strong>单位向量</strong>。如果 $\boldsymbol{x} \neq 0$，可以通过<strong>单位化（规范化）</strong> 得到单位向量：<br>$$<br>\boldsymbol{x}_0 = \frac{\boldsymbol{x}}{\left|  \boldsymbol{x} \right|}<br>$$</p><h3 id="向量夹角">向量夹角</h3><p>在低维空间中，向量的夹角概念较直观。为了在欧式空间中定义向量夹角，我们利用 <strong>Cauchy–Schwarz 不等式</strong>：<br>$$<br>\left| \frac{( \boldsymbol{x}, \boldsymbol{y})}{\left|  \boldsymbol{x}\right|\left|  \boldsymbol{y}\right|} \right| \leq 1<br>$$<br>进而定义两个非零向量 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 的夹角 $\left\langle  \boldsymbol{x},  \boldsymbol{y} \right\rangle$ 的<strong>余弦值</strong>：<br>$$<br>\cos \left\langle  \boldsymbol{x},  \boldsymbol{y} \right\rangle = \frac{( \boldsymbol{x}, \boldsymbol{y})}{\left|  \boldsymbol{x} \right| \left|  \boldsymbol{y} \right|}<br>$$</p><h3 id="向量正交">向量正交</h3><p><strong>定义</strong><br>若欧式空间中的两个向量 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 满足：<br>$$<br>(x,y) = 0<br>$$<br>则称它们<strong>正交（垂直）</strong>。</p><p><strong>定理</strong><br>在欧式空间中，若向量组 ${x_1, x_2, \dots, x_n}$ 互相正交，则它们必然线性无关。</p><h3 id="正交基与标准正交基">正交基与标准正交基</h3><p><strong>定义</strong><br>在欧式空间 $V^n$ 中，由 $n$ 个非零向量组成的<strong>正交向量组</strong>称为 $V^n$ 的<strong>正交基</strong>。若正交基中的向量均为单位向量，则称为<strong>标准正交基</strong>。</p><h3 id="Schmidt-正交化">Schmidt 正交化</h3><p>如何从一组普通的基构造标准正交基？一种方法是<strong>Schmidt 正交化法（Gram-Schmidt 过程）</strong>。</p><h4 id="施密特正交化步骤">施密特正交化步骤</h4><p>给定线性无关的向量组 ${ \boldsymbol{v}_1,  \boldsymbol{v}_2, \dots,  \boldsymbol{v}_n}$，施密特正交化的目标是构造正交向量组 ${ \boldsymbol{u}_1,  \boldsymbol{u}_2, \dots,  \boldsymbol{u}_n}$：</p><ol><li><p><strong>初始向量处理</strong>：<br>令第一个正交向量：<br>$$<br>\boldsymbol{u}_1 = \boldsymbol{v}_1<br>$$<br>由于 $\boldsymbol{v}_1 \neq 0$，则 $\boldsymbol{u}_1 \neq 0$。</p></li><li><p><strong>构造第 $i$ 个向量的正交化</strong>：<br>从第二个向量开始，为了从 $\boldsymbol{v}_i$ 中去掉前面向量 $\boldsymbol{u}<em>1, \dots, \boldsymbol{u}</em>{i-1}$ 的分量，定义投影：<br>$$<br>\frac{( \boldsymbol{v}_i,  \boldsymbol{u}_k)}{( \boldsymbol{u}_k,  \boldsymbol{u}_k)}  \boldsymbol{u}_k<br>$$<br>表示 $\boldsymbol{v}_i$ 在 $\boldsymbol{u}_k$ 上的投影。</p><p>去掉与 $\boldsymbol{u}<em>1, \dots, \boldsymbol{u}</em>{i-1}$ 重叠的部分，得到：<br>$$<br>\boldsymbol{u}_i = \boldsymbol{v}<em>i - \sum</em>{k=1}^{i-1} \frac{( \boldsymbol{v}_i,  \boldsymbol{u}_k)}{( \boldsymbol{u}_k,  \boldsymbol{u}_k)}  \boldsymbol{u}_k<br>$$</p></li><li><p><strong>归一化</strong>：<br>将每个 $\boldsymbol{u}_i$ 归一化为单位向量：<br>$$<br>\boldsymbol{e}_i = \frac{ \boldsymbol{u}_i}{\left| \boldsymbol{u}_i\right|}<br>$$</p></li></ol><p>最终得到一组<strong>正交归一向量</strong>：<br>$$<br>{ \boldsymbol{e}_1,  \boldsymbol{e}_2, \dots,  \boldsymbol{e}_n}<br>$$</p><p>有了以上的铺垫，接下来我们正式引入线性变换的概念。线性变换提供了一种在线性空间之间进行映射的框架，其本质在于保持向量空间中的线性结构。通过线性变换，我们可以将一个线性空间的元素映射到另一个线性空间中，并保持加法和标量乘法的运算法则。</p><h3 id="线性变换">线性变换</h3><p>首先，我们引入 <strong>变换</strong> 的概念如下：</p><p><strong>定义 4:</strong> 设 $V$ 是属于 $K$ 上的线性空间，$T$ 是 $V$ 到自身的一个映射，使对任意向量 $x\in V$，$V$ 中都有唯一向量 $y$ 与之对应，则称 $T$ 是 $V$ 的一个 <strong>变换</strong> 或 <strong>算子</strong>，记为 $Tx = y$，称 $y$ 为 $x$ 在 $T$ 下的象，$x$ 是 $y$ 的原象。</p><p><strong>定义 5:</strong> 如果数域 $K$ 上的线性空间 $V$ 的一个变换 $T$ 具有以下性质：</p><p>$$<br>T(kx + ly) = k(Tx) + l(Ty)<br>$$</p><p>其中，$x,y \in V,k,l\in K$，则称 $T$ 为 $V$ 的一个 <strong>线性变换</strong> 或 <strong>线性算子</strong>。</p><h4 id="线性变换的性质">线性变换的性质</h4><p>不难验证，线性变换有如下性质，且线性空间 $V$ 上所有的线性变换的集合，在所论的线性运算下，构成一个新的线性空间，记为 $\text{Hom}(V, V)$，称为线性空间 $V$ 的 <strong>同态</strong>。</p><ol><li><strong>线性变换的加法</strong>：$(T_1+ T_2)x = T_1x+T_2x, \forall x\in V$，和仍为线性变换。<ul><li>$T_1 + T_2 = T_2 + T_1$;</li><li>$(T_1 + T_2) + T_3 = T_1 + (T_2 + T_3)$;</li><li>$T + T_0 = T$;</li><li>$T + (-T) = T_0$;</li><li>线性变换 $T$ 的 <strong>负变换</strong> $-T$ 定义为： $$<br>(-T)x = -(Tx), \forall x\in V<br>$$</li></ul></li><li><strong>线性变换的数乘</strong>：$(kT)x = k(Tx), \forall x\in V$，线性变换的数乘仍是线性变换。<ul><li>$k(T_1 + T_2) = kT_1 + kT_2$;</li><li>$(k+l)T = kT + lT$;</li><li>$(kl)T = k(lT)$;</li><li>$1 T = T$;</li></ul></li></ol><h4 id="线性变换的矩阵表示">线性变换的矩阵表示</h4><p>诸如二维平面上的旋转、微分和积分等都是线性变换。考虑到有限维线性空间的向量可以用坐标表示出来，进一步考虑则可以通过坐标把线性变换用矩阵表示出来，从而可以把抽象的变换转化成具体的矩阵来处理。故引入线性变换的 <strong>矩阵表示</strong>。</p><p>设 $T$ 是线性空间 $V^n$ 的线性变换，$x \in V^n$，且 $x_1, x_2, \dots, x_n$ 是 $V^n$ 的一个基，则有：<br>$$<br>x = a_1x_1 + a_2x_2 + \dots + a_nx_n<br>$$<br>$$<br>Tx = a_1(Tx_1) + a_2(Tx_2) + \dots + a_n(Tx_n)<br>$$</p><p>这表明，$V^n$ 的任一向量 $x$ 的像可以由基像组 $Tx_1,Tx_2,\dots,Tx_n$ 唯一确定，因为基像组仍 $\in V^n$，所以有：<br>$$<br>\left.<br>\begin{matrix}<br>Tx_1 = a_{11}x_1 + a_{21}x_2 + \dots + a_{n1}x_n\<br>Tx_2 = a_{12}x_1 + a_{22}x_2 + \dots + a_{n2}x_n\<br>\cdots \<br>Tx_n = a_{1n}x_1 + a_{2n}x_2 + \dots + a_{nn}x_n\<br>\end{matrix}<br>\right}<br>\tag{2.6.1}<br>$$<br>即：<br>$$<br>Tx_i = \sum_{j=1}^{n} a_{ji}x_j, \quad i = 1,2,\dots,n<br>$$<br>用矩阵乘法表示式 (2.6.1) 为：<br>$$<br>T(x_1,x_2,\dots,x_n) = (Tx_1,Tx_2,\dots,Tx_n) = (x_1,x_2,\dots,x_n) \boldsymbol{A}<br>\tag{2.6.2}<br>$$<br>其中：<br>$$<br>\boldsymbol{A} = \begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\<br>\cdots &amp; \cdots &amp; &amp; \cdots\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\<br>\end{bmatrix}<br>$$<br>即矩阵 $\boldsymbol{A}$ 的第 $i$ 列为 $Tx_i$ 的坐标。</p><p><strong>定义 3</strong> 式 (2.6.2) 中的矩阵 $\boldsymbol{A}$ 称为 $T$ 在 $V^n$ 的基 $x_1, x_2, \dots, x_n$ 下的矩阵，称 $\boldsymbol{A}$ 为线性变换 $T$ 的矩阵表示。</p><h4 id="特殊的线性变换">特殊的线性变换</h4><ol><li><strong>零变换</strong>：$T_0(x) = \boldsymbol{0}, \forall x\in V$</li><li><strong>恒等变换</strong>：$T_1(x) = x, \forall x\in V$</li></ol><h3 id="正交变换">正交变换</h3><p><strong>定义 4</strong> 设 $V$ 为欧式空间，$T$ 是 $V$ 上的一个线性变换，如果 $T$ 保持 $V$ 中任意向量 $\boldsymbol{x}$ 的长度不变，则有：<br>$$<br>(T \boldsymbol{x},T \boldsymbol{x}) = ( \boldsymbol{x}, \boldsymbol{x})<br>$$<br>那么称 $T$ 是 $V$ 的一个 <strong>正交变换</strong>。</p><p><strong>定理 1</strong> 欧式空间上的线性变换是正交变换 $\Leftrightarrow$ 它对于标准正交基的矩阵是正交矩阵。</p><h3 id="对称变换">对称变换</h3><p><strong>定义 5</strong> 设 $V$ 为欧式空间，$T$ 是 $V$ 上的一个线性变换，且对 $V$ 中任意两个向量 $\boldsymbol{x}, \boldsymbol{y}$，都有：<br>$$<br>(T \boldsymbol{x}, \boldsymbol{y}) = ( \boldsymbol{x},T \boldsymbol{y})<br>$$<br>那么称 $T$ 是 $V$ 的一个 <strong>对称变换</strong>。</p><p><strong>定理 2</strong> 欧式空间上的线性变换是对称变换 $\Leftrightarrow$ 它对于标准正交基的矩阵是实对称矩阵。</p><p>对于线性变换的进一步求解，将在下一节中叙述。</p>]]></content>
    
    
    <summary type="html">《矩阵理论与方法》课程学习笔记</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="矩阵论" scheme="https://blog.yokumi.cn/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数字逻辑与数字系统相关记背知识点</title>
    <link href="https://blog.yokumi.cn/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://blog.yokumi.cn/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2025-01-08T14:10:00.000Z</published>
    <updated>2025-05-10T12:17:54.308Z</updated>
    
    <content type="html"><![CDATA[<h1>Verilog</h1><h2 id="标识符">标识符</h2><ul><li>命名规则与C语言相同；</li><li>关键字必须小写；</li><li><strong>存盘文件名应与设计的模块名相同</strong>；</li></ul><h2 id="概述">概述</h2><ul><li><strong>四值逻辑</strong>：0、1、X(不定)、Z(高阻)；</li><li>模块由两部分构成：<strong>描述接口、描述功能</strong>；<img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/1.png" alt=""></li></ul><h2 id="数据类型">数据类型</h2><ul><li>数据I/O类型；<img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/2.png" alt=""></li><li><strong>always中被赋值的信号必须用reg类型的变量</strong>；</li><li>输入和双向端口不能声明为reg型；</li><li>parameter：符号常量，其定义只在本模块内有效；</li></ul><h2 id="运算符">运算符</h2><ul><li>位连接运算符{  } ，将两个或多个信号的某些位拼接起来。<strong>不允许连接非定长常数</strong>；</li><li>自动调整位宽。运算表达式结果的长度由最长的操作数决定；</li><li>操作结果的长度:  由赋值左端目标长度决定；</li></ul><h2 id="功能描述语句">功能描述语句</h2><ul><li><strong>assign , always , 元件例化，是并发语句</strong>；</li></ul><h3 id="assign">assign</h3><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/3.png" alt=""></p><h3 id="always">always</h3><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/4.png" alt=""></p><h3 id="敏感信号表">敏感信号表</h3><ul><li>敏感信号的变化才能启动进程；</li><li>组合逻辑中，所有输入都作为敏感信号,否则仿真结果和综合结果会不一致；</li></ul><h3 id="注意点">注意点</h3><ul><li><strong>不要在一个aways 中同时使用= ，&lt;=赋值</strong>；</li><li>if、case、for 语句必需在 always 块中；</li></ul><h2 id="设计组合电路">设计组合电路</h2><h3 id="要求">要求</h3><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/5.png" alt=""></p><h2 id="设计时序电路">设计时序电路</h2><h4 id="要求-2">要求</h4><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/6.png" alt=""></p><h4 id="注意点-2">注意点</h4><ul><li><strong>异步信号必须放在敏感信号表中；必须都是边沿</strong>；</li><li>锁存器的所有输入都放在敏感信号表中；锁存器敏感信号都是电平。</li></ul><h2 id="元件例化">元件例化</h2><ul><li>一个元件是一段结构完整的 module 模块；</li><li><strong>不能在always语句内部引用子模块</strong>；</li></ul><h1>存储系统</h1><h2 id="寄存器堆">寄存器堆</h2><ul><li>由多个寄存器构成的集合。常用于数据寄存。 有三组外部信号：地址（短地址）、数据、读/写控制；</li><li>多端口寄存器；</li><li>可同时读、写， 可同时输出两个数；</li></ul><h2 id="寄存器队列">寄存器队列</h2><ul><li>FIFO（First In First Out，先进先出），用若干个移位寄存器构建的 小型存储部件。用于指令队列；</li><li>无地址线，双端口存储器，可同时读写；</li><li>FIFO用于两个不同系统通信、数据采集传送、串并转换；</li></ul><h2 id="寄存器栈">寄存器栈</h2><ul><li>LIFO（ Last In First Out，后进先出）方式，用若干个双向移位 寄存器构建的小型存储部件；</li><li>用于减少函数调用时对内存的访问；</li></ul><h2 id="RAM">RAM</h2><ul><li>特性：能读能写、易失；</li><li>作用：存放编写的程序和数据</li><li>逻辑结构：<img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/7.png" alt=""></li><li><strong>逻辑结构包括：地址译码器、存储矩阵和读写控制电路</strong>；</li><li>分为SRAM(Static RAM)和DRAM(Dynamic RAM)；<img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/8.png" alt=""><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/9.png" alt=""><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/10.png" alt=""></li></ul><h2 id="ROM">ROM</h2><ul><li>ROM的逻辑构成＝ <strong>与门阵列（地址译码器）＋或门阵列（存储矩阵）</strong>；</li><li>分为PROM、EPROM等；</li></ul><h2 id="存储器容量计算">存储器容量计算</h2><ul><li>单元数$\times$每单元的位数；即字数$\times$字长；</li></ul><h1>可编程逻辑器件PLD</h1><h2 id="概述-2">概述</h2><ul><li>现代数字系统由三种积木块构成：CPU＋PLD＋RAM；</li></ul><h2 id="编程部位">编程部位</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/11.png" alt=""></p><h2 id="编程方法">编程方法</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/12.png" alt=""></p><h2 id="CPLD">CPLD</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/13.png" alt=""></p><h2 id="FPGA">FPGA</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/14.png" alt=""><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/15.png" alt=""></p><h3 id="在系统可编程ISP">在系统可编程ISP</h3><ul><li>传统的PLD在用于生产时，是先编程后装配；</li><li><strong>isp则可以在装配之前、装配过程中和装配之后再编程</strong>；</li></ul><h1>数字系统</h1><h2 id="概述-3">概述</h2><ul><li>具有存储、传输、处理信息能力的逻辑系统集合；</li><li>由“<strong>数据通路+控制逻辑</strong>”构成，其工作具有周期性；</li><li><strong>数字系统与逻辑功能部件的区别：有无控制器</strong>；</li><li>在各部件之间传送信息的公共通路，称为<strong>数据通路</strong>。由总线连接的运算单元（组合电路）和存储单元构成；</li></ul><h2 id="总线">总线</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/16.png" alt=""></p><h2 id="设计方法">设计方法</h2><ul><li>自顶向下方法（from top to down ）：是将规模较大的系统从逻辑上划分为控制电路＋受控电路；</li><li>步骤：<ol><li>划分子系统、子模块；</li><li>数据通路；</li><li>用数学语言(工具)，描述控制器的控制过程；</li><li>设计控制器；</li><li>设计数据处理器；</li></ol></li></ul><h1>END</h1><blockquote><p>希望别出太偏捏</p></blockquote>]]></content>
    
    
    <summary type="html">数字逻辑与数字系统相关记背知识点</summary>
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机基础" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="硬件" scheme="https://blog.yokumi.cn/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
</feed>
