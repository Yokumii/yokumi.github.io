<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YokumiのBlog</title>
  
  <subtitle>Here&#39;s an Yokumi...</subtitle>
  <link href="https://blog.yokumi.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.yokumi.cn/"/>
  <updated>2025-05-11T15:42:25.935Z</updated>
  <id>https://blog.yokumi.cn/</id>
  
  <author>
    <name>Yokumi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo博客的一些进阶配置</title>
    <link href="https://blog.yokumi.cn/2025/05/11/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.yokumi.cn/2025/05/11/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE/</id>
    <published>2025-05-11T11:51:33.000Z</published>
    <updated>2025-05-11T15:42:25.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Hexo 的基础配置，已经在 <a href="https://blog.yokumi.cn/2025/01/17/%E4%B8%80%E6%96%87%E7%99%BD%E5%AB%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8+%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83+%E5%8D%9A%E5%AE%A2%E7%AD%89%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/">一文白嫖阿里云服务器+配置基本开发环境+博客等服务部署</a>文章中介绍。</p></blockquote><h1>一、添加 RSS 外链</h1><ol><li>安装 <code>hexo-generator-feed</code> 插件；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-feed --save<br></code></pre></td></tr></table></figure><ol start="2"><li>修改 <code>_config.yml</code> 配置文件；</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 订阅 RSS</span><br><span class="hljs-symbol">feed:</span><br><span class="hljs-symbol">  type:</span> atom<br><span class="hljs-symbol">  path:</span> atom.xml<br><span class="hljs-symbol">  limit:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">  hub:</span><br><span class="hljs-symbol">  content:</span><br><span class="hljs-symbol">  content_limit:</span> false<br><span class="hljs-symbol">  content_limit_delim:</span> <span class="hljs-string">&#x27; &#x27;</span><br><span class="hljs-symbol">  order_by:</span> -date<br></code></pre></td></tr></table></figure><p>其中，<code>limit</code> 表示限制文章数量，可根据需要自行配置；</p><ol start="3"><li>重新生成并部署；</li><li>通过 <code>http://你的域名/atom.xml</code> 就可以访问你的 RSS 了；</li><li>在你需要的地方添加即可；</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;关于 Hexo 的基础配置，已经在 &lt;a href=&quot;https://blog.yokumi.cn/2025/01/17/%E4%B8%80%E6%96%87%E7%99%BD%E5%AB%96%E9%98%BF%E9%87%8C%E4%BA%91</summary>
      
    
    
    
    
    <category term="博客搭建" scheme="https://blog.yokumi.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>计网学习笔记(5)：网络层</title>
    <link href="https://blog.yokumi.cn/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://blog.yokumi.cn/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2025-05-08T14:00:00.000Z</published>
    <updated>2025-05-11T15:52:11.252Z</updated>
    
    <content type="html"><![CDATA[<h1>网络层的位置和功能</h1><p><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/1.png" alt=""></p><blockquote><p>网络层是处理<strong>端到端(end-to-end)传输</strong>的最底层！</p></blockquote><p><strong>Hop(跳)</strong>：</p><blockquote><p>主机之间通信，经过一个路由器就是一跳。</p></blockquote><p><strong>网络层的主要功能</strong>：</p><ol><li><strong>Internetworking 网络互联</strong>：将异构的网络实现互联，向上(传输层)提供统一的接口；</li><li><strong>Addressing 编址</strong>：保证设备之间接口地址（IP Address）唯一且格式统一；</li><li><strong>Packeting 组包</strong>：将上层需要传输的数据封装为包(Packet)；</li><li><strong>Routing 路由</strong>：选路，决定数据包的下一条，通过路由器(Router)实现；</li><li><strong>Fragmenting 分段/分片</strong>：由于不同数据链路层支持的最大数据长度不同，需要适应不同的数据链路层，对数据包进行分段；</li></ol><h1>网络层提供的服务</h1><p>网络层需要向上(传输层)提供服务，要求：</p><ul><li>路由技术独立：即传输层不需要知道路由器的技术，网络层提供的接口是透明且统一的；</li><li>传输层对路由完全透明：不需要看到路由技术和数据包是如何路由的；</li><li>传输层获得的网络地址的格式是统一的；</li></ul><p>又分为：</p><ul><li><strong>Virtual Circuit 虚电路</strong>：Connection-Oriented，面向连接的；</li><li><strong>Datagram 数据报</strong>：Connectionless，无连接的；</li></ul><p>两者都属于分组交换 <strong>Packet Switching</strong>，区别是：</p><ul><li><strong>Datagram 数据报</strong>：<ul><li>每一个包需要携带目的地的完整地址；</li><li>路由器通过路由表转发包，路由表是动态更新的；</li><li>包到达目的地可能是乱序的，即每个包选择的路径可能不相同；</li></ul></li><li><strong>Virtual Circuit 虚电路</strong>：<ul><li>在数据包进行传输之前，网络先建立了一条端到端的虚拟电路；</li><li>传输过程中，数据包携带<strong>虚拟电路地址 VCI(Virtual Circuit Identifier)</strong>，作为地址标识，这比标准的地址短的多；</li><li>VC建立后，所有包需要遵循VC的路径进行路由，所以包到达目的地是一定是按序的；</li></ul></li></ul><h1>路由</h1><p>路由表 = 路由算法 + 路由协议；根据路由算法和路由协议产生和更新路由表(Routing Tables)，根据路由表进行选路，转发数据包</p><h2 id="1-路由算法">1. 路由算法</h2><h3 id="1-1-设计路由算法的原则">1.1 设计路由算法的原则</h3><ul><li>正确性；</li><li>简单性；</li><li>健壮性；</li><li>可快速收敛到稳定状态；</li><li>公平性；</li><li>最优策略：最小化转发延时、最大化网络吞吐量；</li></ul><h3 id="1-2-路由算法的分类">1.2 路由算法的分类</h3><ul><li><strong>静态路由 Nonadaptive/Static Routing</strong>：<ul><li>提前计算出路由表；</li><li>往往不会改变，需要手动维护；</li><li>不能根据网络实时流量和拓扑结构的变化动态调整；</li></ul></li><li><strong>动态/自适应路由 Adaptive Routing</strong>：<ul><li>能适应<strong>网络拓扑 Topology</strong> 和<strong>业务量 Traffic</strong> 的变化；</li></ul></li></ul><h3 id="1-3-一些概念">1.3 一些概念</h3><ul><li><strong>最优化原则</strong>：最优路径上的任意两点间的路径也是最优的；</li><li><strong>宿树/汇集树 Sink Tree</strong>：以目的地节点为根，由所有源节点到目的节点的最优路径路由构成；<ul><li>由于是树，显然是无环的，不存在无限的跳数；</li></ul></li></ul><h3 id="1-4-路由思想和策略">1.4 路由思想和策略</h3><blockquote><p>以下阐述的只是一些路由思想，或者说寻找最优路径的思想，但在实际环境中并不能有效工作；</p></blockquote><ul><li>最短路算法：Dijkstra 算法<ol><li>建立有向加权图；<ul><li>节点为路由器，注意没有主机；</li><li>边为通信线路；</li><li>边权可以为跳数、传输时延、物理距离等等；</li></ul></li><li>通过 Dijkstra 算法寻找最短路；</li></ol></li><li>一些选路策略：<ul><li>固定查表选路 Fixed Routing；</li><li><strong>泛洪 Flooding</strong>：<ul><li>其基本过程如下：<ul><li>将数据包转发给每个邻居；</li><li>邻居再将收到的数据包转发给除了来路之外的所有链路(防止数据包原路返回)；</li></ul></li><li>优点：<ul><li>泛洪显然不需要路由表，简单粗暴；</li><li>不需要网络信息；</li><li>具有鲁棒性，所有路径都会被尝试，所有节点都会被到达，所以至少有一个数据包会按照最短的路由达到目的地；</li><li>在建立路由表时可能较为有用；</li></ul></li><li>缺点：<ul><li>产生大量重复的数据包；</li><li>最终可能有一个或多个重复的数据包到达目的节点；</li></ul></li><li>限制泛滥手段：<ul><li>跳计数器 Hop Counter：<ul><li>每个数据包携带一个 Hop Counter，一般由发送方初始化为源地址到目的地址的距离或子网的网络半径；</li><li>每经过一跳，Hop Counter 减 1；</li><li>当 Hop Counter 为 0 时，丢弃该包；</li></ul></li><li>序列号 Sequence Number：<ul><li>发送方在每个包前添加序列号；</li><li>每个路由器会记录每个发送方目前的最大序列表，表示该序列号已经通过该路由，从而避免重复转发；</li></ul></li></ul></li></ul></li><li>随机选路；</li><li>自适应选路；</li></ul></li></ul><h3 id="1-5-DVR-距离矢量选路-Distance-Vector-Routing">1.5 DVR(距离矢量选路 Distance Vector Routing)</h3><h4 id="1-5-1-执行步骤">1.5.1 执行步骤</h4><ul><li>每个路由维持一个路由表，包括：<ul><li>到其他路由的最短距离；</li><li>到该路由使用的下一条的接口；</li></ul></li><li>每个路由会<strong>周期性</strong>（RIP：30s）地播报自己的路由表；</li><li>路由器会根据收到的邻居的路由表更新自己的路由表；</li><li>如果在一段时间内（RIP：180s）都没有收到某个路由器的路由表，则将该路由器从自己的路由表中删除（将距离设置为 $\infty$ ）；</li><li>当迭代至各个路由器的路由表均不发生变化后，则认为构建路由表结束；</li></ul><h4 id="1-5-2-特点">1.5.2 特点</h4><ol><li>邻接节点之间共享网络信息（路由表）；</li><li>只和初始邻接节点共享信息；</li><li>对所有接口广播信息；</li><li>周期性地广播；</li></ol><blockquote><p>用一句话概括，就是路由器<strong>周期性</strong>地向<strong>所有邻居</strong> <strong>广播</strong>整个<strong>路由表</strong>；</p></blockquote><h4 id="1-5-3-问题">1.5.3 问题</h4><ul><li>收敛速度较慢；</li><li>“好消息”迅速传遍整个网络，但对“坏消息”反应慢；（React rapidly to good news but leisurely to bad news）；即<strong>无穷计数 Count-to-Infinity</strong> 问题；</li><li>按传闻进行路由；（Rumor based routing）</li></ul><p><strong>无穷计数问题</strong>：<br><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/2.png" alt=""></p><p>大致的情况就是，节点A下线后，其余节点之间由于<strong>只知道距离，不知道路径</strong>，相互传递距离，反复更新距离（比如上图B没收到A但收到C的路由表，认为可以通过C到达A，于是更是路由表中到达A 的距离为 1 + 2 = 3，然后C又认为可以通过B到达A，如此循环更新，直到 $\infty$ ）；</p><blockquote><p>RIP协议中规定：权重(按跳数 Hop 计) &gt; 16，则认为是 $\infty$，即认为节点已经断开；</p></blockquote><blockquote><p><strong>注</strong>：上面提到的<strong>RIP</strong>，<s>并非R.I.P(Rest in Peace)</s>，全称是 Routing Information Protocol，属于一种路由协议，该协议使用 <strong>DVR</strong> 路由算法；</p></blockquote><h3 id="1-6-LSR-链路状态选路-Link-State-Routing">1.6 LSR(链路状态选路 Link State Routing)</h3><p>与DVR不同，DVR只会向领接路由器发送路由表，而 LSR 中，每个路由器向网络中的所有路由器共享信息；当路由器在本地构建已知的最优网络拓扑图后，发送一个<strong>链路状态包 Link-State Packet</strong> 给所有路由器（Flooding）；主要特点如下：</p><ol><li>共享整个网络的拓扑结构信息；</li><li>向网络中的所有路由器共享；</li><li>当网络拓扑结构改变时进行共享；</li></ol><h4 id="1-6-1-执行步骤">1.6.1 执行步骤</h4><p>对于每个路由器：</p><ol><li>从相邻的节点学习：<ol><li>本路由器广播(用于广播网络)/多播(用于点对点链路)一个 <strong>HELLO Packet</strong> 给邻接节点；</li><li>邻接节点收到 Hello 包后，回复一个包含自己名字(Route IDs，全网唯一)的包；</li></ol></li><li>测量通信线路开销：<ol><li>通过 <strong>Echo Packet</strong> 测量<strong>往返延时RTT</strong>；</li><li>或测量信道带宽等参数；</li></ol></li><li>构建 <strong>Link-State Packet</strong>：<ol><li><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/3.png" alt=""></li><li>Seq 字段表示序列编号，用于检查路由器收到的 LSP 是否是新的：<ol><li>如果是新序列编号的 LSP，则继续 Flooding；</li><li>如果是重复编号的或序列编号比已经收到的最大编号小的 LSP，则丢弃；</li></ol></li><li>Age 字段表示寿命，目的是为了避免 LSP 包无限泛滥，用于删除循环的路由；</li><li>当周期性地或监听到某些时间（比如某节点下线）等事件后构建 LSP 包；</li></ol></li><li>发送 <strong>Link-State Packet</strong>：<ol><li>由于需要实现可靠发送，所以采用前面提到的泛洪策略；</li><li>每个节点都有错误侦测机制，收到正确的数据包后会回复确认包；</li></ol></li><li>计算新的路由：<ol><li>本路由器收到所有的 LSP 包后，在本地运行 Dijkstra 算法，计算出通往每个目的节点的最短路径，并保存到路由表中；</li></ol></li></ol><h4 id="1-6-2-采用-LSR-的协议">1.6.2 采用 LSR 的协议</h4><ul><li>IS-IS 协议；</li><li>OSPF 协议；</li></ul><h3 id="1-7-层次-分级选路-Hierachical-Routing">1.7 层次/分级选路 Hierachical Routing</h3><p>将距离较近的比如同一单位内的路由划分为同一个<strong>域 Region</strong>，在整个网络内先按照域进行路由，进入域后，才选路至路由器；</p><h1>拥塞控制 Congestion Control</h1><h2 id="1-拥塞">1. 拥塞</h2><p>简单来说，拥塞 Congestion 就是网络的负载（同一时间发送到网络的数据包）超过了网络的可用资源（ CPU 处理速度，Buffer 缓冲队列长度，Bandwidth 链路带宽）；拥塞的症状（判断网络拥塞的指标）主要有：</p><ul><li>Long Delay；</li><li>Lost Packet 较高的丢包率；</li></ul><blockquote><p>上述症状并不能用来判断所有网络是否出现拥塞；无线网络产生丢包还要考虑误码等情况；</p></blockquote><p>注意与流量控制进行区分，流量控制只是两个站点（发送方和接收方）之间进行本地的协调；但是拥塞控制的范围是整个网络，是一个全局的问题；</p><h2 id="2-解决方式">2. 解决方式</h2><p>解决方式主要分为以下5种：</p><ol><li><strong>网络供给 Networking Provision</strong>；</li><li><strong>业务感知路由 Traffic aware-routing</strong>；</li><li><strong>准入控制 Admission control</strong>；</li><li><strong>流量限制 Traffic throttling</strong>；</li><li><strong>负载掉落 Load shedding</strong>；</li></ol><p>从产生拥塞的问题来看，前两种属于增加资源，后三种属于减少负债；<br>从作用的时间节点来看，前三种属于预防性控制，后两种属于反应性(Reactive)措施；</p><h4 id="2-1-流量调节-业务量减速-Traffic-throttling">2.1 流量调节/业务量减速 Traffic throttling</h4><p>这是基于反馈的解决方案，需要路由器能够感知拥塞；其基本步骤如下：</p><ol><li>拥塞检测：<ol><li>检测输出链路利用率：不够精确；</li><li>排队分组，即计算路由器中缓存的数据包数量；</li><li>计算分组丢包数量：但是太迟；</li><li>估计<strong>队列延时 queuing delay</strong>：通过EWMA(Exponentially Weighted Moving Average 指数加权移动平均)计算，即$d_{new} = \alpha d_{old} + (1-\alpha)s$，其中 $\alpha$ 是平滑因子（越大越平滑），$s$ 是最近采样的队列长度；</li></ol></li><li>拥塞通知：路由器需要通知数据包的发送方产生拥塞，让发送方降低业务量，主要有以下几种方式：<ol><li><strong>抑制分组 Choke Packet</strong>：路由器会发送一个 Choke Packet 给源节点（发送方），包含产生拥塞的目的节点信息；<ul><li>发送方发出的原始数据包会被标记，避免产生更多的 Choke Packet；</li><li>实际应用中效果并不好，因为网络已经拥塞了还需要产生 Choke Packet 并在路由间传输；</li></ul></li><li><strong>ECN(Explicit Congestion Notification 显式拥塞通知)</strong>：<ul><li>在 IP 和 TCP 协议中被使用；</li><li>在 IP Packet Header 中专门设置了 2bits 作为拥塞控制比特位；<ul><li>默认设置为 00；</li><li>在传输过程中，如果路由器检测到拥塞，将其设置为 11；</li><li>当该数据包发送到目的端节点后，目的端节点通过传输层（端到端通信）发送 Congestion Signal 给源端节点；</li></ul></li></ul></li></ol></li><li>业务量限制/调节：收到 Choke Packet 后，源节点会减少发送到某个目的地节点的业务量；<ul><li>减少业务量的方式包括但不限于减小发送窗口；</li></ul></li></ol><p>问题：当拥塞恢复时，路由器不会通知端节点恢复业务量？</p><blockquote><p>需要发送方自身进行推测和试探；比如 TCP 的 AIMD 机制（慢启动 + 加性增大），当拥塞时，TCP 会将发送窗口大小减半，然后逐步增加发送窗口大小，如果没有再次丢包，则继续慢慢加大发送窗口，如果丢包则再次降速。</p></blockquote><h4 id="2-2-Loading-Shedding-负载掉落">2.2 Loading Shedding 负载掉落</h4><p>关键问题是选择丢弃哪些数据，需要根据不同的应用场景进行选择。</p><p><strong>RED(Random Early Detection 随机早期检测)</strong>：</p><ul><li>路由器在路由完全失效前，就随机丢弃一部分包；</li><li>路由器并不会（显式）通知源节点，而是直接丢弃选中的包，但是源节点因为没有收到 ACK，检测到丢包后，会感知到拥塞的信息，并降低发送速度。</li><li>上述方法即属于<strong>隐式通知</strong>；</li></ul><p>举个例子：</p><ol><li>发送方此时发送了窗口内的 4、5、6 三个序号的数据帧；</li><li>路由器收到序号为 4 的数据帧时，接收并回复 ACK 4；</li><li>路由器收到序号为 5 的数据帧时，因为 RED 机制选中而被丢弃；</li><li>路由器收到序号为 6 的数据帧时，它选择缓存该帧，但由于它期望收到序号为 5 的帧，所以它会回复 ACK 4；</li><li>发送方收到了两个重复的 ACK 4，那么它会知道，后面发送的数据可能丢包了。</li></ol><blockquote><p><strong>注</strong>：TCP协议中，规定源节点如果收到 3 个及以上相同的 ACK，则认为发生拥塞；</p></blockquote><h1>服务质量 Quality of Service</h1><h2 id="1-QoS-参数">1. QoS 参数</h2><p>第一章 计算机网络概述中已经讲过，QoS主要包括以下4个参数：</p><ul><li>Reliability：可靠性，包括错误率和丢包率；</li><li>Delay；</li><li>Jitter；</li><li>Bandwidth；</li></ul><p>针对不同的应用场景，对参数的要求各不相同，需要提供个性化的服务。</p><h2 id="2-提升服务质量的技术">2. 提升服务质量的技术</h2><h3 id="2-1-流量整形-Traffic-shaping">2.1 流量整形 Traffic shaping</h3><p>实际网络中，往往会出现<strong>突发流量 Traffic Burst</strong>。平均流量基本固定，但是短时间内的瞬时流量可能非常大。而流量整形的作用就是去除或减少突发流量，使得实时传输速率接近平均速率，其主要涉及以下2个算法。</p><h4 id="漏桶-Leaky-Bucket">漏桶 Leaky Bucket</h4><p>事实上，桶就是一个 Buffer 队列，通过匀速从队列中拿出数据分组，实现匀速传输。如果桶满，则丢弃新来的数据或等待队列空。</p><h4 id="令牌桶-Token-Bucket">令牌桶 Token Bucket</h4><ul><li>路由器匀速产生令牌，如果令牌桶满则丢弃多余的令牌；</li><li>数据包到达路由器的队列后，需要消耗令牌进行发送，一个 Token 对应 一个 Packet；</li><li>令牌桶并没有数据队列的缓存限制，不会丢弃数据帧；</li><li>令牌桶能接受一定的突发流量，比如突发流量到达，可以一次性消耗所有令牌（跟令牌桶的大小有关）；</li></ul><p>如何计算经过令牌桶后的突发数据的持续时间？</p><p>令：</p><ul><li>突发数据的持续时间为 $S$ sec；</li><li>令牌桶的容量为 $B$ Bytes；</li><li>令牌的产生速率为 $R$ Bytes/s；</li><li>最大的输出速率为 $M$ Bytes/s；</li></ul><p>则有以下关系：</p><p>$$<br>B + R \times S = M \times S<br>$$</p><p>即：</p><p>$$<br>S = \frac{B}{M - R}<br>$$</p><h3 id="2-2-分组调度-Packet-Scheduling">2.2 分组调度 Packet Scheduling</h3><h4 id="先进先出队列-FIFO-Queuing">先进先出队列 FIFO Queuing</h4><ul><li>先到达的包先发出；</li><li>后到达的包可能会因为队列空间不够而被丢弃；</li></ul><h4 id="优先级队列-Priority-Queuing">优先级队列 Priority Queuing</h4><ul><li>到达的数据包先经过一个<strong>分类器 Classifier</strong>，按照优先级不同存入不同的队列；</li><li>同样，后到达的包如果对应的优先级队列已满，同样丢弃；</li><li>如果空闲，那么高优先级队列中的数据包先被处理和发送；</li><li>对低优先级的数据不公平，如果高优先级队列一直有数据需要发送，那么低优先级的数据无法发出；</li></ul><h4 id="公平队列-Fair-Queuing">公平队列 Fair Queuing</h4><ul><li>对于每一个流（如果一系列包经过相同的路由，那么称其为<strong>流 Flow</strong>）都有一个队列，循环处理和发送每个队列中的数据包；</li></ul><h4 id="公平加权队列-Weighted-Fair-Queuing">公平加权队列 Weighted Fair Queuing</h4><ul><li>根据优先级对数据进行加权，一般高优先级对应较大的权重；</li><li>循环按照权值处理每个优先队列，比如权值为3的则一次发送3个包，权值为2的一次发送2个包；</li></ul><p>以下是教材的一个实现示例，实际上这种思想的实现方式并不唯一。</p><p><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/4.png" alt=""></p><p>每个包的到达时间和长度是路由器已知的，发送完成的时间根据以下公式给出：</p><p>$$<br>Finsh_time_i = max(Arrival_time_i, Finish_time_{i-1}) + \frac{Lengh_i}{Weight_i}<br>$$</p><h3 id="2-3-Admission-Control">2.3 Admission Control</h3><p>暂略；</p><h3 id="2-4-Integrated-Services">2.4 Integrated Services</h3><p>暂略；</p><h3 id="2-5-Differentiated-Services">2.5 Differentiated Services</h3><p>暂略；</p><h2 id="3-QoS的一个例子——保证转发-Assured-Forwarding">3. QoS的一个例子——保证转发 Assured Forwarding</h2><p><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/5.png" alt=""></p><ol><li>所有的业务被划分为4个优先级；</li><li>通过 Traffic Policer 的令牌桶机制进行流量整形；</li><li>在经过 Traffic Policer 时，每个优先级下又被分类为3种优先级，或者说丢弃优先级，即丢包的可能性大小；</li><li>所以最终实际上有12种服务等级；</li><li>在每个 Packet 的 IP Header 的 <strong>ToS 字段(Type of Service 服务类型)</strong> 会携带 DSCP(6bits) + ECN(2bits)，其中：<ul><li><strong>DSCP(Differentiated Services Code Point 服务等级)</strong>；</li><li><strong>ECN(Explicit Congestion Notification 拥塞控制)</strong>；</li></ul></li><li>路由器接收到被划分后的包，根据以下2种机制进行分组调度：<ul><li><strong>WFQ(Weighted Fair Queuing 加权公平队列)</strong>：按照优先级进行公平调度；</li><li><strong>RED(Random Early Detection 随机早期检测)</strong>：采用主动丢弃机制，这里被丢弃的概率就是前面划分的丢弃优先级；</li></ul></li></ol><h1>互联 Internetworking</h1><p>不同网络的协议不同，在不同网络间传输信息，需要实现网络互联。</p><h3 id="1-分段-分片-Fragmentation">1. 分段/分片 Fragmentation</h3><p>不同的网络的 <strong>MTU(Maximun Transmission Unit 最大传输单元)</strong> 不同，在网络层传输数据时，需要进行分片处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;网络层的位置和功能&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/1.</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计组学习笔记(7)：中央处理器II</title>
    <link href="https://blog.yokumi.cn/2025/05/08/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8II/"/>
    <id>https://blog.yokumi.cn/2025/05/08/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8II/</id>
    <published>2025-05-08T05:30:00.000Z</published>
    <updated>2025-05-11T15:52:11.268Z</updated>
    
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机组成原理" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - 期中复习</title>
    <link href="https://blog.yokumi.cn/2025/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
    <id>https://blog.yokumi.cn/2025/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</id>
    <published>2025-04-25T01:00:00.000Z</published>
    <updated>2025-05-11T15:48:16.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：</p><blockquote><p>以下是笔者为应付期中考试的一些复习和总结，由于复习地比较仓促，可能存在错误和遗漏，仅供后来者参考！主要是参考往年题按照题型进行了总结。刷题部分是手写，不传在这里了，晚点可能补充链接；简答题部分由于往年题参考答案不全，本人参考了PPT进行总结，可能存在错误；</p></blockquote><h1>题型</h1><h2 id="一、计算题">一、计算题</h2><h3 id="1-1-CRC检错码计算">1.1 CRC检错码计算</h3><ul><li>看给出的多项式$G(x)$的最高位$r$，则在数据位后添加$r$个$0$后再进行除法；</li><li>这里的除法不同于常规的多项式除法，是<em><strong>模2除法，即按位异或</strong></em>；</li><li>往往和HDLC协议结合出题，只需注意：<ul><li>HDLC协议采用比特填充；</li><li>HDLC等协议差错校验和成帧的顺序是：<ul><li>发送方处理步骤：<ul><li>计算并添加校验码 -&gt; 0比特填充 -&gt; 添加收尾标记01111110</li></ul></li><li>接受方处理步骤：<ul><li>收到物理层的01比特串 -&gt; 首先根据首尾标记位提出帧 -&gt; 删除发送方添加的零比特，就是进行比特删除 -&gt; 最后，进行差错校验</li></ul></li></ul></li></ul></li></ul><h3 id="1-2-帧填充与识别">1.2 帧填充与识别</h3><ul><li>熟悉比特填充、字符填充两种方式即可，会填充和识别；</li><li>HDLC使用比特填充法；</li><li>PPP使用字符填充法；</li></ul><h3 id="1-3-汉明编码">1.3 汉明编码</h3><ul><li>在2的幂次位插入校验码；</li></ul><h3 id="1-4-最大传输速率问题">1.4 最大传输速率问题</h3><ul><li>熟悉三个公式：比特率和波特率的换算、Nyquist定理和香农定理。</li><li>注意后两者计算的是理论上限；</li></ul><h3 id="1-5-分组交换和电路交换延时计算">1.5 分组交换和电路交换延时计算</h3><ul><li>电路交换<ul><li>步骤如下：<ul><li>建立连接 -&gt; 传输数据 -&gt; 连接中止，释放资源；</li></ul></li><li>时延的计算公式如下：<ul><li>$T_{circuit} = T_{establish} + T_{trans} + h_{hop} * T_{prop} + T_{release}$</li></ul></li><li>优点：<ul><li>稳定，时延低（Small Delay, Good Quality）；</li><li>交换过程中控制方式简单；</li></ul></li><li>缺点：<ul><li>连接建立的时间较长；</li><li>带宽固定，不适用于多样的传输服务；</li><li>当两端都没有数据要发送时，造成信道资源浪费；</li></ul></li></ul></li><li>分组交换<ul><li>步骤如下：<ul><li>将较大的数据包分为多个 Packet 进行传输；</li><li>每个 Packet 都有独立的路由（即可能需要携带额外的控制信息）；</li><li>每个 Packet 经过一跳到达中继节点时，都需要进行存储 - 转发 Store-and-Forward；</li></ul></li><li>忽略排队和处理时延，时延的计算公式如下：<ul><li>Let size of date = $M$，size of each packet = $P$，the date rate of the channel = $B$；</li><li>So num of packets $n = \left \lceil \frac{M}{P} \right \rceil$，each packet’s transmission delay $T_{trans} = \frac{P}{B}$，each hop’s propagation delay $T_{prop} = \frac{s}{v_{prop}}$；</li><li>$T_{packet} = (n - 1) * t_{trans} + h * (T_{prop} + T_{trans})$；</li></ul></li><li>优点：<ul><li>信道效率提高；</li><li>速率适配；</li><li>Packet 可以在节点较忙时先被缓存再发送（排队制，不过可能造成传送速率减慢，但可以引入优先级机制）；</li></ul></li><li>缺点：<ul><li>网络更加复杂；</li><li>传播过程中的时延更长；</li><li>没有 QoS，即服务质量保证；</li></ul></li></ul></li></ul><h3 id="1-6-最小帧长度的计算">1.6 最小帧长度的计算</h3><ul><li>以太网或其他使用CSMA/CD技术的LAN，都需要满足条件：$\frac{M_{min}}{B} = 2\tau$；确保有足够的时间检测冲突；</li><li>对于10M以太网，$2\tau = 51.2us$；据此得到最小帧长度为64Bytes；</li><li>事实上，对于10兆以太网，数据帧长度范围为46Bytes ～ 1500Bytes，加上18位控制字符，最终帧长度范围为64Bytes ～ 1518Bytes；</li><li>帧的地址字段长度为6Bytes；</li></ul><h2 id="二、简答题">二、简答题</h2><h3 id="2-1-物理层相关">2.1 物理层相关</h3><ol><li>（2012/2014/2015年期中）请写出采用调制解调器 MODEM 拨号上网时，什么因素限制了调制解调器的带宽？为什么拨号上网的上行和下载速度不相同？</li></ol><blockquote><p>上行受到模拟信号转数字信号的信噪比影响，根据香农公式，最大数据率受到限制，而下行并不会受到限制，</p></blockquote><ol start="2"><li>（2019年期中）两台计算机使用调制解调器利用电话线进行通信，不适合成帧的方法有哪些？说明原因。</li></ol><blockquote><p>调制解调器接受和传送数据的单位是字节而不是位/比特，所以不适合用比特填充法成帧；</p></blockquote><ol start="3"><li>（2015年期中）为什么普通电话线无法传送计算机网络数据，而采用 ADSL 电话线就可以传送？</li></ol><blockquote><p>ADSL 使用的电缆扩展了普通电话线的带宽到3400Hz以上。</p></blockquote><ol start="4"><li>（2020年期中）ADSL用户线的传输介质？复用技术？ADSL用户到端局的数据链路层采用的协议？其向上层提供的服务？成帧技术？</li></ol><blockquote><p><strong>传输介质</strong>：普通电话线，即3类双绞线 Twisted Pair UTP3，但相较于普通电话线扩展了带宽到3400Hz以上。普通电话线有滤波器，它没有。</p><p><strong>复用技术</strong>：模拟信号，采用频分复用 FDM；</p><p><strong>用户到端局的数据链路层采用的协议</strong>：端到端，采用PPP协议，以字符为单位；</p><p><strong>其向上层提供的服务</strong>：非对称数据传输，下行速率远高于上行速率，适用于家庭用户“多下载少上传”的需求；为网络层的多种不同的协议提供支持、提供身份认证、协商IP等（即PPP协议的服务）。</p><p><strong>成帧技术</strong>：字符填充法；</p></blockquote><ol start="5"><li>（2012年期中）传输介质速率比较。</li></ol><blockquote><p>传输速率/带宽：双绞线 &lt; 细缆 &lt; 粗缆 &lt; 光纤；</p></blockquote><h3 id="2-2-滑动窗口协议部分">2.2 滑动窗口协议部分</h3><ol><li>（2013年期中）在滑动窗⼝协议中，采⽤重发计时器和ACK计时器各有什么作⽤？这两者在数值上有什么关系？ (6分）</li></ol><blockquote><p><strong>重发计时器 Frame_Timer</strong>，在发送方发送一个帧时启动，如果在规定时间内未收到该帧对应的ACK，则进行超时重传，每一个帧对应一个计时器；用于确保数据最终被可靠地传送到接收方；</p><p><strong>ACK计时器 ACK_Timer</strong>，一般只在选择重传协议中使用。它的工作机制如下，在接收方从接收窗口下沿依次提交收到的帧并向前滑动时，会启动 ACK_Timer；在 ACK_Timer的规定时间内，如果有接收方有数据要发送，则停止 ACK_Timer，采用 Piggybacking 将 ACK 和数据一起发送给发送方；如果 ACK_Timer 超时，则单独发送 ACK 给 发送方，同时停止计时器。ACK_Timer 通过延时确认，提高了网络效率，减少了单独的 ACK 报文数量。由于采用累积 ACK 的方式，所以接收方只需要一个 ACK_Timer。</p><p>在时间关系上，书上给出了以下关系：$2t_{prop} + ack_timer &lt; frame_timer$，不等式左边表示从发送方发送数据帧到接收方发送 ACK 并返回 ACK 所需的最大时间，不等式右边表示发送方的重传计时器的超时时间，即等待 ACK 的最大时间。小于关系避免了发送方在 ACK 尚未到达前误判数据帧丢失并进行不必要的重传。</p></blockquote><h3 id="2-3-共享信道协议">2.3 共享信道协议</h3><ol><li>（2018年期中）共享信道协议中，评价一个协议优劣的两个主要指标是什么？</li></ol><blockquote><p>低负载情况下的时延和高负载下的吞吐量（或信道利用率）；</p><p>低负载下适合用竞争的方法（即 1-persistent CSMA）；而 p 越小，负载高时，发送帧的随机化越好，冲突越小，吞吐量越高；</p></blockquote><ol start="2"><li>（2020年期中）简述什么是隐蔽站问题？802.11(CSMA/CA)如何解决？</li></ol><blockquote><p>隐蔽站问题，即假如A需要向B发送数据，但此时站点C位于A的监听范围之外，但出于B的范围内，C同时也要向B发送数据。由于A无法监听到C，仍会发送数据造成冲突；<br>CSMA/CA技术</p></blockquote><ol start="3"><li>（2015年期中）提高信道利用率的措施？</li></ol><blockquote><p>增加发送字节的长度、采用滑动窗口技术等；</p></blockquote><h3 id="2-4-参考模型">2.4 参考模型</h3><ol><li>OSI参考模型</li></ol><blockquote><p>应用层：提供应用相关的服务；<br>表示层：信息的表示、加密、压缩等；<br>会话层：进程会话控制、令牌管理、同步；<br>（以上三层的数据单元为 <strong>Message 消息</strong>）；<br>传输层：实现可靠的端到端的传输，数据单元为 <strong>Segment 段</strong>；<br>网络层：进行路由转发，实现拥塞控制、服务质量管理和网络互联，数据单元为 <strong>Packet 分组</strong>；<br>数据链路层：数据单元是 <strong>Frame 帧</strong>；<br>物理层：数据单元是 <strong>Bit 比特</strong>；</p></blockquote><ol start="2"><li>TCP/IP参考模型</li></ol><blockquote><p>网际层：分组交换、路由，采用IP协议；<br>传输层：分为TCP(可靠的面向连接的服务)和UDP(不可靠的无连接的服务)</p></blockquote><ol start="3"><li>IEEE 802 参考模型</li></ol><blockquote><p>将数据链路层又划分为以下两个子层：</p><p>逻辑链路控制子层（LLC）：为网络层提供统一的接口；流量控制；差错控制；网桥；<br>介质访问控制子层（MAC）：成帧；差错检查；MAC地址；介质访问多路控制；局域网交换，VLAN；</p></blockquote><ol start="4"><li>（2013年期中）针对OSI参考模型和TCP/IP参考模型，各写出两点不足；</li></ol><blockquote><p>OSI模型的缺点：<br>（1）实现复杂度高：七层划分过于细致，导致协议实现成本高，尤其在会话层和表示层功能重复（如加密、压缩等），实际应用中常被合并；<br>（2）缺乏灵活性：属于理论标准，未充分考虑实际网络需求（如互联网的IP协议）；</p><p>TCP/IP模型的缺点：<br>（1）层次划分粗糙：可能导致协议功能边界模糊；<br>（2）无明确服务/接口定义：OSI模型严格区分服务、接口和协议，而TCP/IP模型仅关注协议实现，缺乏标准化接口描述，不利于系统集成；</p></blockquote><ol start="4"><li>（2013年期中）解释协议和服务概念，并说明⼆者之间的关系。协议数据单元（PDU）和服务原语有什么区别和联系？</li></ol><blockquote><p><strong>协议</strong>：两个系统同一层的对等实体之间进行通信需要共同遵守的规则；<br><strong>服务</strong>：某层实体对于上一层实体的支持，即对上一层提供的功能集合；<br><strong>协议与服务的关系</strong>：一层协议的实现需要下层的服务，本层服务的实现需要协议的支持，协议是水平的，服务是垂直的。但注意，本层协议改变不一定会导致本层服务改变，本层服务不变、协议改变不会影响上一层服务，但是本层服务改变会影响相邻上一层的服务；<br><strong>接口</strong>：定义某层实体对于上一层提供的服务原语操作；</p><p><strong>服务原语</strong>：用户与层间服务交互的命令，用于请求或响应服务；<br><strong>协议数据单元PDU</strong>：是同层对等实体之间交换的数据单元，包含<strong>协议头</strong>（即对上层数据进行封装的操作）和<strong>上层数据</strong>；<br><strong>PDU和服务原语的区别和联系</strong>：区别上，PDU为同层之间的水平通信，服务原语为层间的垂直通信，属于用户与服务的交互命令；PDU是实现协议的载体，而服务原语触发协议动作，用户通过服务原语间接使用协议功能；</p></blockquote><ol start="5"><li>（2015年期中）请写出计算机网络层次化设计方法的设计原则。</li></ol><blockquote><p>（1）<strong>各层应执行定义明确的函数 (Each layer should perform a well-defined function)</strong></p><blockquote><p>这意味着每一层需要专注于解决特定类型的问题或提供特定的服务。功能的划分应该清晰，避免不同层次的任务相互混淆。这有助于简化设计和实现，并使各层能够独立开发和维护。</p></blockquote><p>（2）<strong>层间边界的选择应使接口处的信息流最小化 (The layer boundaries should be chosen to minimize the information flow across the interfaces)</strong></p><blockquote><p>相邻层之间的交互（通过服务访问点 SAP）应该尽可能简单。理想情况下，一层应该只向其上一层提供必要的、最小化的服务，减少不必要的依赖和信息传递。这有助于降低协议开销，并提高系统的效率和模块化程度。</p></blockquote><p>（3）<strong>层次的数量应适中 (The number of layers should be…)</strong></p><blockquote><p>层次的数量既不能太多，也不能太少。应该足够多，以确保不同的功能不会被不恰当地合并到同一层中，保持每层的职责单一和清晰。 应该足够少，以避免架构过于庞大和复杂，减少不必要的开销（如每层添加头部信息）。 需要在功能清晰度和整体复杂性之间找到平衡。</p></blockquote></blockquote><h3 id="2-5-无线通信">2.5 无线通信</h3><ol><li>（2019年期中）简要解释WLAN中的TXOP机制。</li></ol><blockquote><p>TXOP，即Transmission Opportunity，传统的信道分配方式是站点每次发送一帧，即“你发一帧我发一帧”这种形式，但这对于数据率大的站点并不公平，并且低速站点会拉低吞吐量。使用TXOP机制时，每个站点获得相等的发送时间，比如假如有$n$个站点，每个站点的速率为$c_i$，那实际传输过程中，每个站点的速率为$\frac{c_i}{n}$，保证了每个站点都获得相等的发送时间；</p></blockquote><ol start="2"><li>（2019年期中）无线局域网的协议标准是什么？什么是虚拟载波监听技术？</li></ol><blockquote><p><strong>协议标准</strong>：IEEE 802.11；</p><p><strong>虚拟载波监听技术</strong>：<br>（1）每个站点都维持一个 NAV（Network Allocation Vector，网络分配向量）；<br>（2）发送方在发送帧时，携带一个 NAV，表示信道将被占用的时长；<br>（3）接收方在接收到帧后，更新本地的 NAV，根据 NAV 确定需要的退避时间，以避免冲突。</p></blockquote><h3 id="2-6-一些设备">2.6 一些设备</h3><ul><li>Repeater：互联设备，属于物理层；用于将两个总线型的以太网进行连接；</li><li>Bridge：网桥，属于数据链路层；用于将两个局域网进行互联；</li></ul><ol><li>网桥和交换机的共同点和区别：</li></ol><blockquote><p>共同点：都是数据链路层设备；<br>不同点：<br>（1）网桥主要用软件处理；而交换机的处理是硬件层面的；<br>（2）网桥同时只能分析和处理一帧，而交换机一次性可以处理大量帧；<br>（3）网桥采用存储转发方式，而交换机还可以通过直通 Cut-Through 等方式加快传输速率；</p></blockquote><ol start="2"><li>（2018年期中）能隔离广播风暴的设备有？</li></ol><blockquote><p>路由器 and VLAN交换机，两者分别工作在不同的层；</p></blockquote><h3 id="2-7-虚拟局域网VLAN">2.7 虚拟局域网VLAN</h3><ul><li>将局域网在逻辑上划分为多个广播域；</li><li>每个 VLAN 都有一个唯一的标识符 VLAN ID；通过这个实现区分；</li><li>不支持 VLAN 的交换机无法识别帧中的 VLAN ID；</li></ul><ol><li>（2019年期中）使用 VLAN 交换机可构建逻辑上相互隔离的多个网络，广播和组播报文也会被隔离吗？ 说明原因？</li></ol><blockquote><p>可以隔离。VLAN通过在数据链路层进行逻辑隔离，默认情况下会<strong>隔离广播和未知组播</strong>报文，将其限制在各自的VLAN内部，从而提高网络性能和安全性。</p></blockquote><h1>考后回忆和复盘</h1><blockquote><p>题量比较大，一共9道大题，考试时间是85分钟，还是有一些往年题的，你邮经典藏往年题然后吃老本。懒得回忆具体数据了，和上面整理的内容重合度还蛮高的。好好看PPT和作业题即可。当然，如果我的整理对你有帮助，那么就更好了。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是笔者为应付期中考试的一些复习和总结，由于复习地比较仓促，可能存在错误和遗漏，仅供后来者参考！主要是参考往年题按照题型进行了总结。刷题部分是手写，不传在这里了，晚点可能补充链接；简答题部分</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计组学习笔记(6)：中央处理器I</title>
    <link href="https://blog.yokumi.cn/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/"/>
    <id>https://blog.yokumi.cn/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/</id>
    <published>2025-04-13T11:12:00.000Z</published>
    <updated>2025-05-11T15:52:11.252Z</updated>
    
    <content type="html"><![CDATA[<h1>处理器功能</h1><ol><li>指令控制：控制程序严格按照规定顺序执行；</li><li>操作控制：处理器根据从内存取出的每条指令产生相应的操作信号，送往相应的部件，控制这些部件按指令的要求进行动作；</li><li>时间控制：对各种操作实施时间进行控制；</li><li>数据加工；</li><li>中断处理；</li></ol><h1>CPU模型及其组成</h1><p><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/1.png" alt=""></p><p>CPU组成部分如下：</p><ul><li><strong>控制器</strong>：从指令cache中读取当前指令，并指出下一条指令在指令cache中的位置；对指令进行译码，产生操作控制信号；指挥并控制CPU、内存和IO设备之间的数据流动；<ul><li><strong>程序计数器PC</strong>；<ul><li>保存将要执行的下一条指令的地址；</li></ul></li><li><strong>指令寄存器IR</strong>；<ul><li>保存当前正在执行的一条指令；</li><li>保存的操作码字段就是指令译码器的输入；</li></ul></li><li><strong>指令译码器</strong>；</li><li>操作控制器OC；<ul><li>根据指令的操作码和时序性好，产生各种操作的控制信号；</li><li>根据设计方法不同可分为：<ul><li>硬布线控制器：采用时序逻辑；</li><li>微程序控制器：采用存储逻辑；</li></ul></li></ul></li><li>时序产生器；<ul><li>对各种操作信号进行执行时间先后顺序控制；</li></ul></li></ul></li><li><strong>运算器</strong>：对数据进行加工处理，是执行部件，执行所有算术运算、逻辑运算和测试运算；<ul><li>算数逻辑单元ALU；</li><li>累加寄存器；</li><li><strong>数据缓冲寄存器DR</strong>；<ul><li>用来暂存从数据cache中读出的或来自外部接口的一个数据字，或ALU 的运算结果；</li><li>从图上就可以看出，它是ALU运算结果和通用寄存器组之间的缓冲；</li><li>用来补偿CPU、内存和外设在操作速度上的差异；</li></ul></li><li><strong>程序状态字寄存器PSWR</strong>；<ul><li>保存运算结果标志，比如进位标志、零标志、溢出标志、负标志；</li><li>保存中断和系统工作状态等信息；</li></ul></li></ul></li><li>其他主要寄存器：<ul><li><strong>地址寄存器AR</strong>；<ul><li>存放处理器当前访问的数据cache中数据单元的地址；</li></ul></li><li>通用寄存器R0 ～ R3；<ul><li>暂存ALU的运算结果；</li></ul></li></ul></li><li><strong>数据通路</strong>：寄存器之间、寄存器与ALU之间传送数据通路的总称；</li></ul><h1>指令周期</h1><h2 id="执行程序">执行程序</h2><p>在冯诺依曼结构，即存储程序式计算机中，在程序运行之前，需要将程序和数据均放到内存中，具体执行程序的顺序如下：</p><ol><li>将程序首地址送入程序计数器PC；</li><li>从内存(cache)中取出该指令并执行；</li><li>形成下一条待执行指令的地址，保存到PC中；</li><li>自动连续执行指令，直至最后一条指令；</li></ol><p>即一个取指令 + 执行指令的过程；</p><h2 id="指令周期">指令周期</h2><p>指令周期就是取指令 + 分析指令 + 执行指令所需的总时间；</p><p>显然，由于各种指令的执行时间是不同的，所以各种指令的指令周期也不相同；</p><p>一个指令周期包含若干个CPU周期；</p><h2 id="CPU周期-机器周期">CPU周期 / 机器周期</h2><p>CPU周期又称机器周期，一个机器周期又包含若干个时钟周期；</p><h2 id="时钟周期；">时钟周期；</h2><p>时钟周期是处理操作的基本单位，也称节拍脉冲；</p><h2 id="指令的执行步骤">指令的执行步骤</h2><h3 id="MOV指令">MOV指令</h3><p>MOV指令作用是数据传送，属于RR型指令，假设指令为 <code>MOV R1 R0</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令（1个CPU周期）<ol><li>读取寄存器R0中的数；</li><li>通过ALU以及三态门读到数据总线DBUS上；</li><li>将取出来的数写入数据缓冲寄存器DR；</li><li>将数据缓冲寄存器DR中的数写入寄存器R1；</li></ol></li></ol><p>MOV指令周期 = 2个CPU周期；</p><h3 id="LAD指令">LAD指令</h3><p>LAD指令作用是从内存上加载数据到寄存器中，属于RS型指令，假设指令为 <code>LAD R1 A</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令<ol><li>送操作数地址（1个CPU周期）<ol><li>操作数的直接地址即为 A，将其装入地址寄存器AR；</li></ol></li><li>取出操作数，装入通用寄存器（1个CPU周期）<ol><li>从数据存储器中读出 A 地址上的数，发送至数据总线；</li><li>将取出来的操作数写入数据缓冲寄存器DR；</li><li>将数据缓冲寄存器DR中的数写入寄存器R1；</li></ol></li></ol></li></ol><p>LAD指令周期 = 3个CPU周期；</p><h3 id="ADD指令">ADD指令</h3><p>ADD指令属于RR型指令，假设指令为 <code>ADD R1 R2</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令（1个CPU周期）<ol><li>读取寄存器R1和R2上的数；</li><li>通过ALU执行加法运算，结果通过三态门发送至数据总线；</li><li>将运算结果暂存至数据缓冲寄存器DR；</li><li>将数据缓冲寄存器DR暂存的运算结果写入寄存器R1；</li></ol></li></ol><p>ADD指令 = 2个CPU周期；</p><h3 id="STO指令">STO指令</h3><p>STO指令的作用是将寄存器中的数写入内存，属于RS型指令，假设指令为 <code>STO R2(R3)</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令<ol><li>送操作数地址（1个CPU周期）<ol><li>从寄存器R3中取出操作数的直接地址，将其装入地址寄存器AR；</li></ol></li><li>送操作数地址，执行写操作（1个CPU周期）<ol><li>从寄存器R2中的数读出，发送到数据总线上；</li><li>发出写命令，将数据总线上的的数写入地址寄存器AR对应的地址单元；</li></ol></li></ol></li></ol><p>STO指令 = 3个CPU周期；</p><h3 id="JMP指令">JMP指令</h3><p>JMP指令是无条件转移指令，假设指令为 <code>JMP A</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令（1个CPU周期）<ol><li>转移地址即为A，将转移地址A送往程序计数器PC；</li></ol></li></ol><p>JMP指令 = 2个CPU周期；</p><h3 id="执行步骤总结">执行步骤总结</h3><ol><li>读取指令（1次访存）；（公共操作）</li><li>分析指令；</li><li>执行指令：不同指令操作步骤不同；</li><li>检查有无中断请求；（公共操作）</li></ol><p>方框图表示如下，其中1个方框代表1个CPU周期；<img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/2.png" alt=""></p><h1>时序产生器和控制方式</h1><h2 id="控制器分类">控制器分类</h2><ul><li>硬布线控制器：时序信号一般采用 <strong>主状态周期 —— 节拍电位 —— 节拍脉冲</strong> 的三级体制，节拍电位 = CPU周期时间；</li><li>微程序控制器：时序信号较简单，采用 <strong>节拍电位 —— 节拍脉冲</strong> 的二级体制；<ul><li>组成包括：<ul><li>时钟源；</li><li>环形脉冲发生器；</li><li>节拍脉冲和读写时序译码；</li><li>启停控制逻辑；</li></ul></li></ul></li></ul><h2 id="控制方式">控制方式</h2><ul><li>同步控制：执行各指令所需的机器周期数和时钟周期数固定不变；</li><li>异步控制：<ul><li>每条指令和操作控制信号按需占用时间；</li><li>每条指令的指令周期可以由多个不等长的机器周期构成；</li></ul></li><li>联合控制；</li></ul><h1>微程序控制器</h1><h2 id="与硬布线控制器对比">与硬布线控制器对比</h2><ul><li>微程序控制器按照软件设计的思想设计硬件；</li><li>相较于硬布线控制器，具有规整性、灵活性、可维护性等优点；</li></ul><h2 id="基本概念">基本概念</h2><ul><li>微命令：控制部件通过控制线向执行部件发出的各种控制信号；</li><li>微操作：执行部件接收到微命令后执行的的特定操作；<ul><li>相容性操作：同时在一个CPU周期内可以并行的操作；</li><li>相斥性操作：不能同时在一个CPU周期内并行的操作；</li></ul></li><li>反馈信息：执行部件使用反馈线向控制部件报告操作情况，控制部件根据反馈信息发出新的微命令；</li><li>微指令：在一个CPU周期内，实现某个操作功能的一组微命令构成了微指令。<ul><li>即，用一条微指令对应一个机器指令的一个执行步骤；</li><li>微指令需要提供：<ul><li>执行该步骤所需的控制信号；</li><li>提供下一条需要执行的微指令的地址；</li></ul></li></ul></li><li>微程序：一条机器指令对应一段微程序，微程序即实现一条机器指令所需的多条微指令序列；</li></ul><h2 id="微指令的基本格式">微指令的基本格式</h2><p>微指令包括操作控制字段和顺序控制字段：</p><ul><li>操作控制字段用于发出控制信号，每一位对应一个微命令；</li><li>顺序控制字段用于产生下一条微指令的地址；</li></ul><p><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/3.png" alt=""></p><h2 id="微程序控制器原理">微程序控制器原理</h2><p><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/4.png" alt=""></p><p>一个基本的原理框图如上图所示：</p><ul><li>控制存储器：用来存放全部指令系统的微程序的<strong>只读存储器</strong>；<ul><li>从控制存储器中读出一条微指令并执行的时间总和称为<strong>微指令周期</strong>；</li></ul></li><li>微指令寄存器：用于存放由控制存储器读出的一条微指令；<ul><li>微地址寄存器：用于决定将要访问的下一条微指令的地址；</li></ul></li><li>地址转移逻辑：<ul><li>正常情况下，由微指令的顺序控制字段直接给出下一条微指令的地址并存放在微地址寄存器中；</li><li>当微程序出现分支，则需要根据状态条件、指令寄存器IR等计算地址转移；</li></ul></li></ul><p>一个基本的执行过程如下：</p><ol><li>执行“取指”指令，即取出指令，这是所有机器指令的共用微指令，所以一般存放在地址0000处；并且所有机器指令的最后一条微指令的直接地址都指向0000，用于取下一条指令；</li><li>进入 P1 测试，即操作码测试，产生对应的微程序入口指令，送入微地址寄存器；</li><li>该条微指令执行完毕后，进入 P2 测试，用于计算下一条微指令的地址，读取微指令，重复上述操作；</li><li>当微程序对应的所有微指令均被执行完后，返回到0000处，即取指微指令，用于执行下一段微程序；</li></ol><h2 id="机器指令与微指令的关系">机器指令与微指令的关系</h2><p>注意区分程序与微程序、机器指令与微指令、地址与微地址的对应关系。前者与主存有关，而后者与控制存储器有关，如下图：<br><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/5.png" alt=""></p><h2 id="微程序设计">微程序设计</h2><h3 id="微命令编码">微命令编码</h3><ol><li>直接表示法：微指令的控制字段中每一位对应一个微命令（即控制信号）；</li><li>编码表示法：把一组相斥的微命令合并成一个小组，对应一个字段，通过小组译码器对微命令信号进行译码，译码输出作为控制信号。$n$ 位二进制译码后可以表示 $2^{n} - 1$个微命令。比如3个互斥的微命令，原本需要3位，现在只需要合并为一个2位的字段，通过2:4译码器进行译码；如下图：</li></ol><p><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/6.png" alt=""></p><p><strong>注：为什么用 $n$ 位二进制可以表示 $2^n - 1$$ 个微命令，而不是 $2^n$ 个？</strong></p><blockquote><p>注意<strong>编码表示法中用“全 0 码不表示任何有效微命令”</strong>，即全0表示无操作，所以剩下 $2^n - 1$ 个微命令才是有效的；</p></blockquote><ol start="3"><li>混合表示法：更灵活；</li></ol><h3 id="产生后继地址的方法">产生后继地址的方法</h3><ol><li>计数器方式</li></ol><ul><li>与程序计数器PC类似：<ul><li>顺序执行微指令时，下一条微指令的地址通过当前微地址 + 一个增量产生；</li><li>非顺序执行时需要通过一定的转移方式产生下一条微地址；</li></ul></li><li>优点：<ul><li>需要的顺序控制字段少；</li></ul></li><li>缺点：<ul><li>多路并行转移功能弱，速度慢、灵活性差；</li></ul></li></ul><ol start="2"><li>多路转移方式</li></ol><ul><li>程序运行时：<ul><li>不产生分支时：后继微地址直接由本条微地址的顺序控制字段给出；</li><li>产生分支时：根据本条微地址的顺序控制字段的P字段（即<strong>判别测试位</strong>）和<strong>状态条件位</strong>来从若干“候选”微地址中选择；</li></ul></li><li>状态条件有 $n$ 位 $\Rightarrow$ 可以实现 $2^n$ 路转移（即对应 $2^n$ 个微程序入口） $\Rightarrow$ 涉及微地址寄存器的 $n$ 位（ $n$ 位状态条件直接存入微地址寄存器，微地址寄存器的高位相当于”基地址“）；</li><li>优点：多路并行转移功能强， 速度快，更灵活；</li><li>缺点：多路转移需要复杂的组合逻辑；</li></ul><h3 id="微指令格式">微指令格式</h3><ul><li>水平型微指令：一次能定义并执行多个并行操作的微命令的微指令；<ul><li>包含控制字段、判别测试字段（P字段）、下地址字段；</li></ul></li><li>垂直型微指令：类似机器指令，通过设置微操作码字段规定微指令的功能，长度较短，但一条微指令只有 1 ～ 2 个微操作命令，实现一条机器指令对应的微程序需要的垂直型微指令更多；</li></ul><p>两者对比：</p><ul><li>水平型微指令并行操作能力强，灵活，效率高；</li><li>水平型微指令执行一条指令的用时较短；</li><li>水平型微指令组成的微程序微指令较长但微程序较短；</li><li>水平型微指令难以掌握，垂直型微指令容易掌握；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;处理器功能&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;指令控制：控制程序严格按照规定顺序执行；&lt;/li&gt;
&lt;li&gt;操作控制：处理器根据从内存取出的每条指令产生相应的操作信号，送往相应的部件，控制这些部件按指令的要求进行动作；&lt;/li&gt;
&lt;li&gt;时间控制：对各种操作实施时间进行控制；&lt;/</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机组成原理" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一些有关Game Theory(博弈论)的学习记录</title>
    <link href="https://blog.yokumi.cn/2025/04/05/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Game%20Theory(%E5%8D%9A%E5%BC%88%E8%AE%BA)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.yokumi.cn/2025/04/05/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Game%20Theory(%E5%8D%9A%E5%BC%88%E8%AE%BA)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2025-04-05T08:22:00.000Z</published>
    <updated>2025-05-10T12:17:54.193Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：</p><blockquote><p>以下是笔者学习<a href="https://www.bilibili.com/video/BV1xY411Y7Wj/">【耶鲁大学】博弈论</a> 课程中整理的内容，因为笔者实在是懒的自己找书啃。有些内容可能结合自己的研究方向（Multiple-Agent-System）简单拓展；至于数模感觉能用到的几率比较小。</p></blockquote><h1>一、Prisoner’s Dilemma 囚徒困境</h1><h2 id="1-1-四个重要结论">1.1 四个重要结论</h2><p><strong>定义 1.1</strong>：<strong>Strictly Dominant Strategy 严格优势策略</strong></p><blockquote><p>假如策略$\alpha$在无论对手选择何种应对的情况下的收益都高于策略$\beta$，则称策略$\alpha$为相对$\beta$的严格优势策略；</p></blockquote><p><strong>结论 1.1</strong>：<strong>不要使用严格劣势策略</strong></p><blockquote><p>我们假设参与博弈的行为人都是理性的（和经济学中定义的理想经济人类似），都希望追求更高的收益（当前，每个人衡量收益大小的标准有不同，对收益的看法显然也会影响决策）；</p></blockquote><p><strong>结论 1.2</strong>：<strong>理性的选择可能导致更糟的结果</strong></p><blockquote><p>显然，如果双方均追求对于个人收益的最大化，可能导致双输；</p></blockquote><p><strong>如何破解囚徒困境？</strong></p><blockquote><p>沟通并不能解决这个困境，在缺乏强制力介入的情况下，沟通缺乏意义，可能有效的方式是有强制力的合同（比如书面合同）、重复博弈、教育。</p></blockquote><p><strong>结论 1.3</strong>：<strong>如欲得之，必先知之 If you want to get it, you must know it first</strong></p><blockquote><p>如果我们不知道一个人或一场博弈中的收益情况，那么我们就不可能获得收益；</p></blockquote><p><strong>结论 1.4</strong>：<strong>换位思考 Put yourself  in others’ shoes and try to figure out what they’ll do</strong></p><blockquote><p>假如我们知道另一方的收益情况，那么如果我们确认对方会根据 <strong>结论 1.1</strong> 选择某种策略，那么我们可以根据对方的选择选择对于自己收益更高的那种，即使站在自己的角度，并没有严格优势策略；</p></blockquote><h2 id="1-2-Grade-Game-积分游戏">1.2 Grade Game 积分游戏</h2><p>关于耶鲁大学《博弈论》课程上的积分游戏的具体推导见下，懒地打了。。。<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/Page1.png" alt=""><br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/Page2.png" alt=""></p><h2 id="1-3-Ingredients-of-a-game-博弈的要素">1.3 Ingredients of a game 博弈的要素</h2><ul><li><strong>Players 参与者</strong>；</li><li><strong>Strategies 策略</strong>；<ul><li>$s_i$:  $Player_i$的某个特定策略；</li><li>$S_i$: $Player_i$的策略集合；</li><li>$S$: 一次博弈，即所有参与者的策略组合；</li></ul></li><li><strong>Payoff 收益</strong>；</li><li><strong>Assumption 假设</strong>：每个参与者都知道其他人的可能策略和收益，即博弈者之间信息透明；</li><li>$S_{-i}$: 一次博弈中除了$Player_i$之外的其他所有参与者的策略；</li></ul><p>定义符号后，我们给出更严格的严格优势策略的定义：</p><p><strong>定义 1.1 Plus</strong>：<strong>Strictly Dominant Strategy 严格优势策略</strong></p><blockquote><p>$Player_i$'s strategy $S’<em>i$ is strictly dominated by $Player_i$'s strategy $S_i$ if $U_i(S_i, S</em>{-i}) &gt; U_i(S’<em>i, S</em>{-i})$ for all $S_{-i}$；</p></blockquote><h2 id="1-4-Hannibal-汉尼拔">1.4 Hannibal 汉尼拔</h2><p>Ben教授通过汉尼拔进军罗马的例子，引入了弱优势策略，弱优势策略允许了一部分策略组下收益相等而不是严格大于；</p><p><strong>定义 1.1 Extension</strong>：<strong>Weakly Dominant Strategy 弱优势策略</strong></p><blockquote><p>$Player_i$'s strategy $S’<em>i$ is weakly dominated by $Player_i$'s strategy $S_i$ if $U_i(S_i, S</em>{-i}) \ge U_i(S’<em>i, S</em>{-i})$ for all $S_{-i}$, and $U_i(S_i, S_{-i}) &gt; U_i(S’<em>i, S</em>{-i})$ for some $S_{-i}$;</p></blockquote><p>关于汉尼拔的具体推导见下：<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/%E7%AC%94%E8%AE%B0%202025%E5%B9%B44%E6%9C%8815%E6%97%A5%20(2).png" alt=""></p><h2 id="1-5-Iterative-Deletion-迭代剔除劣势策略">1.5 Iterative Deletion 迭代剔除劣势策略</h2><p>该策略要求参与者首先找到所有劣势策略，剔除它们，然后再重新审视整个博弈，如此往复。一个具体的例子如下：</p><p>每人选择一个1到100之间的数字，谁选的数字最接近平均数的三分之二，则获得胜利。</p><p><strong>第一层</strong>：</p><blockquote><p>假设大家选取的数字是在 0 ～ 100 间随机分布的，那么 average 约等于50，50的2/3应该是33左右；但是问题也很明显，大家不会都进行随机选择；</p></blockquote><p><strong>第二层</strong>：</p><blockquote><p>我认为别人都按照第一层的思路进行思考，即大部分人都会选择33，那么我应该选择 33 * 2/3 = 22；</p></blockquote><p><strong>第三层</strong>：</p><blockquote><p>从这一层开始，使用了博弈论的框架，即假设参与者都是理性的。那么，选择大于67的数字属于弱劣势策略（除非大家均选择100）；那么大于67的数字就被剔除了；按照这个思路，我选择45；</p></blockquote><p><strong>第四层</strong>：</p><blockquote><p>如果大家都考虑到了上面一层，那么基于第三层，现在选择大于45的也变成了弱劣势策略；按照这个思路，我应该选择30；</p></blockquote><p>按照这个逻辑一直持续下去，30 ～ 20、20 ～ 13，不断持续剔除下去，那么最终所有人都会选择1；</p><p>但1就是正确答案吗？</p><p>得到1需要反复迭代、剔除，即需要我不断知道别人都想到了上一层，即我知道你知道我知道你知道（无限套娃）我是理性的，即 <strong>Common Knowledge 共同知识</strong> 。</p><p><strong>定义 1.5</strong>：<strong>共同知识</strong></p><blockquote><p>共同知识是指某个信息或事件不仅被所有参与者知晓，而且所有参与者都知道其他参与者也知道该信息，并且知道其他参与者也知道其他人知道该信息，如此无限递归。<br>即：所有人都是理性的；所有人都知道所有人是理性的；所有人都知道所有人都知道所有人是理性的……</p></blockquote><h2 id="1-6-The-Median-Voter-Theorem-中位选民定理">1.6 The Median-Voter Theorem 中位选民定理</h2><p>该定理事实上只是迭代剔除劣势策略在政治学上的一个应用。并且该模型还是简化了现实问题，存在不少问题；</p><p>首先，对于2个候选人A和B，他们的立场用 1 ～ 10 数字表示，假定每个数字对应10%的选民，选民仅按立场的接近程度进行投票；如果立场的接近程度相同，则一半一半；候选人的目标就是最大化选票，即收益；</p><p>容易发现，1和10为劣势策略，具体推导如下：如果A选择2，那么</p><ol><li>当B选1时，$U_A(2,1) = 90% &gt; U_A(1,1) = 50%$；</li><li>当B选2时，$U_A(2,2) = 50% &gt; U_A(1,2) = 10%$；</li><li>当B选3时，$U_A(2,3) = 20% &gt; U_A(1,3) = 15%$；</li><li>当B选4时，$U_A(2,4) = 25% &gt; U_A(1,4) = 20%$；</li></ol><p>以此类推，后面都是2优于1并且均相差$5%$；</p><p>选2严格优于选1，根据对称性，选9也严格优于选10。</p><p>越接近中间就优于两侧吗？并不，可以算一个例子：如果A选择3，那么</p><p>当B选择1时，$U_A(3,1) = 85% &lt; U_A(2, 1) = 90%$，即A选3并不严格优于选2；</p><p>但是如果按照迭代剔除的思想，剔除劣势策略1和10之后，那么接下来策略2和9就变成了劣势策略，以此类推，最优的策略是选5和选6；这就是中位选民定理；</p><p>这个模型存在以下问题：</p><ol><li>选民并非平均分布；</li><li>选民并非完全根据立场来投票，即考量因素往往是多维度的；</li><li>选民往往会根据候选人过去的行为判断立场而并非按候选人所声称的；</li><li>选民存在弃票；</li><li>候选人往往大于2个；</li><li>大选之前还有初选；</li><li>…</li></ol><h2 id="1-7-Best-Response-最优对策">1.7 Best Response 最优对策</h2><p>如果站在双方的角度，都不存在严格最优对策，那么站在我的角度，假设另一方采取某策略的概率是$p$，据此计算我选择每个策略的期望收益；</p><blockquote><p><em><strong>持续更新中…</strong></em></p></blockquote>]]></content>
    
    
    <summary type="html">一些有关Game Theory(博弈论)的学习记录</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="博弈论" scheme="https://blog.yokumi.cn/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>简述MCP(Model Context Protocols)</title>
    <link href="https://blog.yokumi.cn/2025/04/04/%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/"/>
    <id>https://blog.yokumi.cn/2025/04/04/%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/</id>
    <published>2025-04-04T13:25:00.000Z</published>
    <updated>2025-05-10T12:17:54.367Z</updated>
    
    <content type="html"><![CDATA[<h1>What’s MCP</h1><p>MCP，模型上下文协议，是一种开源标准。如果希望让我们的AI Agent能自动使用工具，能与各种数据源建立连接，自动地访问和利用外部信息，那么MCP就是这一过程的中间件。由LLM来决定需要调用哪些工具，但是由于LLM供应商以及各种工具标准并不统一，就MCP标准化指令的执行。即，MCP提供了一种将代理连接到工具的标准化方法。</p><p>MCP作为一种“中间协议层”，可以通过下图来更好地理解，具体架构将在后文阐述；<br><img src="%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/1.png" alt=""></p><h1>Why’ s MCP</h1><p>上面也提到了，LLM供应商以及各种工具标准并不统一，并且函数调用本身就具有局限性，再进一步讲述之前，我们先明确函数调用的概念。</p><p>函数调用（function calling）负责将自然语言提示转换为结构化函数调用指令，以便面向工具的系统（如 MCP 服务器）能够理解并执行作。此阶段的重点是为工具或 API 生成精确的指令。这就是LLM与具体系统集成的第一阶段；第二阶段才是MCP提供标准化工具执行指令。</p><p>LLM供应商大都提供了函数调用的功能，这里以Deepseek为例，简述函数调用的过程和使用方法（不考虑MCP的使用），具体内容可以进一步参考<a href="https://api-docs.deepseek.com/zh-cn/guides/function_calling">Deepseek API文档</a>；</p><ol><li>用户提问：北京今天的天气如何？</li><li>LLM理解用户提问，返回 function <code>get_weather(&#123;location: 'Beijing'&#125;)</code>；</li><li>（用户）手动调用 function <code>get_weather(&#123;location: 'Beijing'&#125;)</code>，将返回结果传递给LLM；</li><li>LLM理解结果，并将答案以自然语言形式输出；</li></ol><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_messages</span>(<span class="hljs-params">messages</span>):<br>    response = client.chat.completions.create(<br>        model=<span class="hljs-string">&quot;deepseek-chat&quot;</span>,<br>        messages=messages,<br>        tools=tools<br>    )<br>    <span class="hljs-keyword">return</span> response.choices[<span class="hljs-number">0</span>].message<br><br>client = OpenAI(<br>    api_key=<span class="hljs-string">&quot;&lt;your api key&gt;&quot;</span>,<br>    base_url=<span class="hljs-string">&quot;https://api.deepseek.com&quot;</span>,<br>)<br><br>tools = [<br>    &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>        <span class="hljs-string">&quot;function&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;get_weather&quot;</span>,<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Get weather of an location, the user shoud supply a location first&quot;</span>,<br>            <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>                <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;location&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                        <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;The city and state, e.g. San Francisco, CA&quot;</span>,<br>                    &#125;<br>                &#125;,<br>                <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;location&quot;</span>]<br>            &#125;,<br>        &#125;<br>    &#125;,<br>]<br><br>messages = [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;How&#x27;s the weather in Beijing?&quot;</span>&#125;]<br>message = send_messages(messages)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;User&gt;\t <span class="hljs-subst">&#123;messages[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;content&#x27;</span>]&#125;</span>&quot;</span>)<br><br>tool = message.tool_calls[<span class="hljs-number">0</span>]<br>messages.append(message)<br><br>messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;tool&quot;</span>, <span class="hljs-string">&quot;tool_call_id&quot;</span>: tool.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;24℃&quot;</span>&#125;)<br>message = send_messages(messages)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Model&gt;\t <span class="hljs-subst">&#123;message.content&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>注意上述代码中，我们手动定义了工具的内容，其格式由LLM供应商决定，并且供应商之间标准并不统一。而且，函数调用功能是通过用户手动执行并将结果添加到prompt中实现的。</p><h2 id="MCP’s-Role-in-Execution">MCP’s Role in Execution</h2><p>LLM生成函数调用指令后，必须执行这些指令才能提供结果。这就是 MCP 的用武之地。MCP 提供了一个标准化的框架来管理执行过程，包括工具发现、调用和响应处理；关于其具体的执行过程，我们先介绍它的架构；</p><h1>MCP Architecture</h1><p><img src="%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/2.png" alt=""></p><p>上图直观展示了MCP的架构，它主要围绕三个组件构成：MCP Server、MCP Host、MCP Client；</p><ul><li>MCP Server：顾名思义，是MCP的服务端，即集成的工具、函数、结构和数据连接所在的位置，同时负责执行代理给出的指令；</li><li>MCP Host：主机，比如聊天应用程序，用户使用包含代理的应用程序；</li><li>MCP Client：MCP的客户端，是主机与服务器之间的接口，负责数据交换；</li></ul><p>当引入MCP后，我们通过Agent代理查询天气的过程变成：</p><ol><li>用户提问：北京今天的天气如何？</li><li>主机连接到LLM，根据问题和服务器提供的工具列表，确定使用哪些MCP Server；</li><li>客户端调用所需的MCP Server，执行所选的工具；</li><li>服务器将结果回送给LLM，后者生成最终答案并输出给用户；</li></ol><h1>MCP开发</h1><blockquote><p><em><strong>持续更新中</strong></em>；</p></blockquote><p>官方开发文档可参考：<br><a href="https://modelcontextprotocol.io/introduction">官方开发文档</a></p><h1>Reference</h1><p>[1]. <a href="https://medium.com/@tahirbalarabe2/what-is-model-context-protocol-mcp-architecture-overview-c75f20ba4498">What is Model Context Protocol? (MCP) Architecture Overview</a></p>]]></content>
    
    
    <summary type="html">简述MCP(Model Context Protocols)</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="https://blog.yokumi.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="LLM" scheme="https://blog.yokumi.cn/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>计网学习笔记(4)：介质访问控制子层</title>
    <link href="https://blog.yokumi.cn/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/"/>
    <id>https://blog.yokumi.cn/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/</id>
    <published>2025-04-04T06:00:00.000Z</published>
    <updated>2025-05-11T15:52:11.268Z</updated>
    
    <content type="html"><![CDATA[<p>介质访问控制（Media Access Control, Mac）需要完成的任务是，为使用传输介质的每一个节点隔离来自同一信道上其他节点所传送的信号，协调活动节点的传输。</p><h1>Dynamic Channel Allocation</h1><h2 id="Assumptions">Assumptions</h2><ol><li>节点之间是独立的；</li><li>只有一条信道；</li><li>冲突可被观测到；</li><li>Continuous time / Slotted time</li><li>Carrier sense / No carrier sense：载波监听，即发送之前能否知道信道空闲；</li></ol><h2 id="Random-multiple-access-随机介质访问控制">Random multiple access 随机介质访问控制</h2><h3 id="ALOHA">ALOHA</h3><h4 id="Pure-ALOHA">Pure ALOHA</h4><ul><li>任何时刻如果有数据需要发送都能发送；</li><li>如果没有收到ACK，则重传；</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/1.png" alt=""></p><blockquote><p><strong>注</strong>：<strong>Vulnerable Period 脆弱期</strong>：$2t_{trans}$；</p></blockquote><h5 id="流程">流程</h5><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/2.png" alt=""></p><blockquote><p><strong>注</strong>：如果没有收到正确的ACK，则随机等待一定时间后再重传；</p></blockquote><h4 id="Slotted-ALOHA-时隙-分槽">Slotted ALOHA 时隙/分槽</h4><ul><li>只能在每个时隙的开始时刻发送数据</li><li>需要统一的时钟管理</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/3.png" alt=""></p><blockquote><p><strong>注</strong>：<strong>Vulnerable Period 脆弱期</strong>：$t_{trans}$；</p></blockquote><h3 id="Carrier-Sense-Multiple-Access-Protocols-CSMA-载波监听多路访问控制">Carrier Sense Multiple Access Protocols(CSMA, 载波监听多路访问控制)</h3><ul><li><strong>发前先听</strong>：<ul><li>If Channel is idle，即监听到信道上没信号，则以一定的概率 $p$ 发送；（减小有两个节点同时监听到信道上没信号并发送数据导致冲突的可能性）</li><li>If Channel is busy，节点等待直至监听到信道上没信号；</li><li>如果有两个节点同时发送，则冲突；</li><li>如果超过一定时间没有收到ACK，则重传；</li></ul></li></ul><blockquote><p><strong>注</strong>：<strong>Vulnerable Period 脆弱期</strong>：$t_{prop}$；</p></blockquote><h4 id="Nonpersistant-vs-Persistant-CSMA">Nonpersistant vs. Persistant CSMA</h4><ul><li>Nonpersistant CSMA 如果监听到信道正忙，那它会等待一个随机时间后在进行监听；<ul><li>高负载时，有较高的吞吐量；</li></ul></li><li>Persistant CSMA 如果监听到信道正忙，会持续监听到信道上没有信号，然后以一定的概率 $p$ 发送；<ul><li>1 - Persistant CSMA：$p = 1$，即监听到信道上没有信号就发送；<ul><li>低负载时，能有较低的时延和较高的吞吐量；</li><li>高负载时，吞吐量较低；</li></ul></li><li>p - Persistant CSMA：以一定的概率 $p$ 发送；</li></ul></li></ul><blockquote><p><strong>注</strong>：$p$ 越小，则在负载高的情况下，随机化（信号的离散程度）越好，冲突的可能性越小；</p></blockquote><h3 id="比较和总结">比较和总结</h3><p><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504102203589.png" alt=""></p><blockquote><p><strong>注</strong>：评价MAC协议的指标：</p><ol><li>低负载时的时延；</li><li>高负载时的吞吐量（或信道利用率）；<br>低负载时，适合使用竞争方法；</li></ol></blockquote><p>上述三个协议都有一个共同的问题：只有当 Timer 超时，发送方才知道数据发送过程中可能出现了冲突，<em><strong>没有检测冲突的能力！</strong></em></p><h3 id="CSMA-CD-with-Collision-Detection-带冲突检测的载波监听多点介接入技术">CSMA/CD (with Collision Detection, 带冲突检测的载波监听多点介接入技术)</h3><p>基本思想：</p><ol><li>载波监听；</li><li><strong>发送方</strong>检测冲突；</li><li>冲突检测：当发送方检测到冲突时，停止传输，并发送一个 <strong>Jam Signal(强化信号)</strong>；</li><li><strong>backoff 退避</strong>：当发送方接收到 <strong>Jam 强化信号</strong>后，等待一个随机时间在恢复发送；（目的是避免两个发送方同时检测到冲突并进行退避后，监听到信道空闲又发送导致再一次冲突）</li></ol><p>特点：</p><ol><li>信道是 <strong>Half-duplex 半双工</strong>，即同一时刻一个节点只能作为发送方或接收方，不能既发又收；</li><li>节省了时间和带宽；</li><li>是 <strong>Ethernet 以太网</strong>的基础；</li><li>属于 Unacknowledged connectionless service 无确认无连接的服务；</li></ol><blockquote><p><strong>Q</strong>：如何检测冲突？<br><strong>A</strong>：通过一条收线，同时从总线上接受信号，与发送的信号进行比较；由于需要较强的信号强度以及较为合适的调制技术，<strong>不适用于无线通信</strong>；</p><p><strong>Q</strong>：Vulnerable Time 脆弱期 = $2t_{prop}$；</p><p><strong>Q</strong>：等待重传的时间是多长？<br><strong>A</strong>：采用指数退避Binary Exponential Backoff Algorithm；</p></blockquote><h5 id="指数退避">指数退避</h5><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/4.png" alt=""></p><ul><li>最多尝试16次；</li><li>指数最多为10；</li><li>基础的退避时间 = 51.2usec；</li></ul><h4 id="Wireless-LAN-Protocols">Wireless LAN Protocols</h4><p>无线信道无法进行冲突检测（信号强度太小，不满足要求）；CSMA/CD不适用；</p><h5 id="隐藏终端-Hidden-Terminal">隐藏终端 Hidden Terminal</h5><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/5.png" alt=""></p><p>如上图，假如A、C都需要向B发送数据，但是A不在C的范围内，即C监听不到A，所以C会同时向B发送数据，导致接收方B冲突；</p><h5 id="Exposed-Terminal-暴露终端">Exposed Terminal 暴露终端</h5><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/6.png" alt=""></p><p>B向A发送数据，但C在B的范围内，C监听到B，错误地认为此时不能向D发送数据；</p><h5 id="MACA-Multiple-Access-Collision-Avoidance-冲突避免多路访问">MACA(Multiple Access Collision Avoidance, 冲突避免多路访问)</h5><p>MACA的实现步骤如下：</p><ol><li>发送方A发送一个 <strong>RTS(Request to Send, 请求发送)</strong> 帧给接收方B；<ul><li>RTS长度为30Bytes，包括数据包的长度信息；</li></ul></li><li>接收方B收到 RTS 后，回复一个 <strong>CTS(Clear to Send, 允许发送)</strong> 帧给发送方A；</li><li>当发送方A收到 CTS 后，开始发送数据；</li><li>接收方B收到数据后，回复ACK；</li></ol><ul><li>RTS和CTS用于<strong>预约信道</strong>，它们<em><strong>均包含待发送数据的长度</strong></em>，这能用于冲突检测，比如：</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/7.png" alt=""></p><ul><li>对于上图，A需要向B发送数据；<ul><li>其中C和E是暴露终端，D是隐藏终端；</li><li>A向B发送RTS，C和E都会收到；</li><li>B向A发送CTS，D和E都会收到；</li><li>C只收到了RTS，保持沉默；</li><li>D只收到了CTS，也保持沉默；</li><li>E既收到了RTS，又收到了CTS，但是收到RTS后，它认为下一个收到的数据长度应该是RTS中数据的长度，与CTS不符合，故也保持沉默；</li></ul></li></ul><p>如果两个站点A、B同时需要向站点E发送数据：</p><ol><li>A、B同时发送RTS；</li><li>接收方收到RTS后，只会回复先到达的RTS对应的CTS；</li><li>假如A站点成功收到CTS，B站点在一定时间范围内没有收到，那么B采用<strong>指数退避</strong>方式，等待一段时间后再进行尝试；</li></ol><h2 id="Controlled-multiple-access-控制介质访问控制">Controlled multiple access 控制介质访问控制</h2><ul><li>Centralized control：<strong>Polling 轮询</strong>，主站依次向从站发出请求；</li><li>Decentralized control：<strong>Token Passing 令牌</strong>，节点共同维护一个令牌；</li></ul><h1>LAN Reference Model: IEEE 802</h1><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/8.png" alt=""></p><ul><li>只包括物理层和数据链路层，同时将数据链路层 Data Link 进一步划分为 <strong>Logical Link Control(LCC, 逻辑链路控制)</strong> 和 <strong>Medium Access Control(MAC, 介质访问控制)</strong> ；</li><li><strong>LCC 逻辑链路控制子层</strong>：<ul><li>向网络层提供统一的接口；</li><li>流量控制；</li><li>差错控制；</li><li>Inter-connecting LANs with bridge 网桥；</li></ul></li><li><strong>MAC 介质访问控制子层</strong>：<ul><li>Framing 成帧；</li><li>差错检测；</li><li>Physical Address: e.g. MAC address；</li><li>多路访问控制；</li><li>LAN switching；</li></ul></li><li>不同的LAN，MAC子层不同，LCC子层相同；</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/9.png" alt=""></p><h1>Ethernet 以太网</h1><h2 id="Classic-Ethernet-Physical-Layer">Classic Ethernet: Physical Layer</h2><h3 id="Physical-Topology-物理拓扑结构">Physical Topology 物理拓扑结构</h3><ul><li>Bus 总线型；</li><li>Star 星型：通过 <strong>Hub 集线器</strong> 实现交换；<em><strong>物理上星型，逻辑上总线型</strong></em>；</li></ul><h3 id="Network-Interface-Card（NIC-网卡）">Network Interface Card（NIC, 网卡）</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/10.png" alt=""></p><h3 id="Hub-集线器">Hub 集线器</h3><p><code>100 Base -T X</code> ：</p><ul><li>100：传输速度，单位Mbps；</li><li>Base：调制技术，即基带传输，不需要进行调制；</li><li>T：传输媒介，T代表双绞线 Twisted Pair，F代表光纤 Fiber Optics；</li><li>X：编码方式，一般采用Manchester编码；</li></ul><p>常见的技术如下：<br><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/11.png" alt=""></p><ul><li>距离长用粗缆；</li></ul><h3 id="Repeater">Repeater</h3><ul><li>属于<strong>物理层</strong>的设备；</li><li>Half Duplex 半双工；</li><li>将两个总线型的以太网连接；</li></ul><h2 id="Classic-Ethernet-MAC-Sublayer-Protocol">Classic Ethernet: MAC Sublayer Protocol</h2><blockquote><p><strong>帧间隙 Inter Frame Gap</strong>：IFP，9.6us(对于10Mbps的以太网)；用于节点转换发送模式/接收模式；</p></blockquote><ul><li>广播式信道；</li><li>以太网采用 <strong>1 - persistant CSMA/CD</strong>；</li></ul><h3 id="Frame-Type">Frame Type</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/12.png" alt=""></p><ul><li>Data字段最多1500Bytes，最少46Bytes；不满足则用Pad字段填充；</li><li>MAC地址字段：<ul><li>6Bytes；</li><li>用 <code>FF:FF:FF:FF:FF:FF</code> 地址表示广播；</li></ul></li><li>Frame Length<ul><li>最多1518Bytes，其中1500Bytes为数据长度，18Bytes为控制地址长度；</li><li>最短64Bytes，其中46Bytes为数据长度；<ul><li>原因是以太网使用了CSMA/CD技术，需要有足够的时间检测冲突，否则会造成数据已经发送完成才检测到冲突；</li><li>$\frac{M_{min}}{B} = 2\tau = 51.2us$</li></ul></li></ul></li></ul><h2 id="Switched-Ethernet">Switched Ethernet</h2><h3 id="Hub-vs-Switch">Hub vs. Switch</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/13.png" alt=""></p><ul><li>Hub：一个节点来的信号会向别的所有节点转发；所有节点都在冲突域内，需要CSMA/CD；</li><li>Switch：不需要；</li></ul><h3 id="Switch-Ways">Switch Ways</h3><ul><li>Cut-Through 直通<ul><li>边收边转发；</li><li>无法检查数据帧是否错误；</li><li>输入/输出需要相同速率；</li></ul></li><li>Store-Forward 存储转发<ul><li>缓存整个数据帧后，检查没有碰撞/CRC错误帧后，再根据目的MAC地址进行转发；</li><li>支持差错检测；</li><li>支持不同输入/输出端口间的交换；</li></ul></li></ul><h2 id="Fast-Ethernet">Fast Ethernet</h2><p>从这里开始，主要介绍不同速率的以太网；经典以太网的速率是10Mbps，即10兆以太网；而快速以太网的速率为100Mbps，即百兆以太网，它的设计原则如下：</p><ul><li>向后兼容，即保持帧格式、接口等不变；</li><li>减少 bit time；</li><li>减少 Max Length of Cable，这个没办法，必要的牺牲；</li><li>Hub或者Switch两种方式都有；</li></ul><h3 id="Cabling">Cabling</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/14.png" alt=""></p><ul><li>不再使用同轴电缆；</li><li>100Base-T4<ul><li>信号频率为25MHz；</li><li>4 Twisted Pair（3UTP）</li><li>不使用Manchester编码，使用三元信号；6B/8T；</li></ul></li><li>100Base-TX<ul><li>信号频率为125MHz；</li><li>2 Twisted Pair（5UTP）；</li><li>编码4B/5B（125MHz * 4/5 = 100Mbps）；</li></ul></li><li>100Base-FX<ul><li>使用光纤；</li></ul></li></ul><blockquote><p><strong>注</strong>：如果用到 Full-Duplex 全双工，即收发是两条线（区分于 Half-Duplex 半双工，收发一条线），不会产生冲突，所以不需要CSMA/CD；</p></blockquote><h3 id="Autonegotiation-自动协商机制">Autonegotiation 自动协商机制</h3><p>两个不同的以太网之间自动选择相同的参数（即 Speed 和 Duplex Mode）进行配置；</p><h2 id="Gigabit-Ethernet">Gigabit Ethernet</h2><p>Gbit以太网，速度又快了10倍；设计原则如下：</p><ul><li>无ACK，发了就完了，不需要应答；</li><li>48-bit的地址格式不变；</li><li>帧格式不变（但进行了拓展，不然最大电缆长度太短了）；</li><li>同样分为 Switch(Full-Duplex，最大电缆长度取决于信号衰减程度)和 Hub(Half-Duplex，存在冲突)；</li></ul><h3 id="Cabling-2">Cabling</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/15.png" alt=""></p><h3 id="Carrier-Extension-载波扩展">Carrier Extension 载波扩展</h3><p>我们知道，由于CSMA/CD技术需要满足：</p><p>$$<br>\frac{M_{min}}{B} = 2\tau = 51.2us<br>$$</p><p>如果不进行扩展，最大电缆长度仅为约25m；所以需要进行扩展（填充无用的比特），将数据长度扩展为<strong>512Bytes</strong>；当然，也可以通过 <strong>Frame Bursting 帧突发</strong>，具体在下一节介绍；</p><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/16.png" alt=""></p><h3 id="Frame-Bursting-帧突发">Frame Bursting 帧突发</h3><p>上述扩展方法，对信道效率存在严重的浪费。如果对于有大量需要连续发送的帧的情况，帧的发送往往用队列存储，发送方可以将需要连续发送的帧拼成一个帧进行发送。</p><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/17.png" alt=""></p><ul><li>第一个帧采用载波扩展；</li><li>剩余的帧直接连续发送，注意帧之间有帧间隙；</li></ul><h3 id="Flow-Control">Flow Control</h3><p>Gigabit Ethernet确实能显著提升传输速度，但是也存在问题，由于发送速度很快，但是接收方突然因为别的任务CPU过忙了1ms，就会导致1953个帧堆积；并且由于它是无连接的，不需要ACK，所以极易造成缓存溢出；</p><p>一种方法是，设计一个特殊的控制帧 <strong>Pause Frame</strong>(0x8808)，如果接收方缓存不足，它会发送该帧给发送方，阻止另一方继续发送数据；</p><h2 id="10G-Ethernet">10G Ethernet</h2><ul><li>一般用于 <strong>Local Backbone 本地骨干网</strong>；</li><li>只支持 Full-Duplex 全双工；</li><li>支持 Autonegotiation 自动协商；</li></ul><h3 id="Cabling-3">Cabling</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/18.png" alt=""></p><h2 id="Summary">Summary</h2><ul><li>1 - persistent CSMA/CD(如果使用Switch则不需要冲突检测)；</li><li>MAC address = 48bits；</li><li>Frame Size = 64Bytes ～ 1518Bytes；<ul><li>Data Size = 46Bytes ～ 1500Bytes；</li></ul></li><li>Hub and Switch；</li><li>经典以太网、高速以太网；</li><li>Topology 拓扑结构：总线型(只有经典以太网使用)、星型；</li><li>物理层编码：<strong>Manchester编码(经典以太网使用，百兆以太网之后就不再使用)</strong>、8B/6T、4B/5B；</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/19.png" alt=""></p><h1>Wireless LANS 无线网络</h1><h3 id="802-11-LAN-architecture">802.11 LAN architecture</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/20.png" alt=""></p><ul><li>AP: Access Point；<ul><li>AP与外部设备(路由器/交换机)之间采用有线连接；</li></ul></li><li>BSS: Basic Service Set；<ul><li>内部设备之间采用无线通信；</li><li>通过AP接入外部网络；</li></ul></li></ul><h3 id="Mac-Sublayer">Mac Sublayer</h3><p>在无线通信中，无法通过 Collision Detection 检测冲突（之前讲过，信号太弱以及调制技术限制）；在802.11无线局域网标准中，MAC子层提供了两种信道接入模式：</p><ul><li><strong>Point coordination function(PCF, 点协调功能, 集中式)</strong><ul><li>由 <strong>Base Station 基站(即 AP)</strong> 作为点协调控制者；</li><li>通过 <strong>Polling 轮询</strong>，为各个站点分配信道访问权，即AP按照预设的顺序依次询问每个站点是否需要发送数据；</li><li>基站广播一个 <strong>beacon frame 信标帧</strong>（包括系统参数，是够允许发言等信息）；</li></ul></li><li><strong>Distributed coordination function(DCF, 分布协调功能, 分布式)</strong><ul><li>没有中央控制者；</li><li>通过 <strong>CSMA/CA(CSMA with Collision Avoidance)</strong> 技术避免冲突；</li></ul></li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/21.png" alt=""></p><h4 id="CSMA-CA">CSMA/CA</h4><p>for 802.11 Sender, if it needs to send a frame:</p><ol><li>通过载波监听等待直到信道空闲，并在等待 <strong>DIFS</strong> 的时间（即在 DIFS 时间内信道空闲，才认为信道空闲，能发送数据）；</li><li>随机退避（0 ～ 15 个时间槽），如果信道上有数据发送则停止计时器；知道计时器为0时发送帧；</li><li>如果没有收到ACK，那么采用指数退避，加倍退避时间；</li></ol><p>for 802.11 Receiver:</p><ol><li>如果正确接收到帧，则等待 <strong>SIFS</strong> 的时间后回复ACK；</li></ol><blockquote><p><strong>注</strong>：$t_{SIFS} &lt; t_{DIFS}$，这能保证 <em><strong>ACK 的优先级更高</strong></em>；<br>事实上，通过为不同类型的帧设置不同长度的 <strong>IFS 帧间隔</strong>，来实现<strong>优先级</strong>服务；</p></blockquote><p>CSMA/CA 有以下两种监听模式：</p><ul><li>Physical Sense：物理意义上的监听信道；</li><li>Virtual Sense：虚拟监听；<ul><li>每个站点都记录一个 NAV(Network Allocation Vector, 网络分配向量)；</li><li>每个帧都携带一个 NAV；</li><li>NAV 表示这个数据帧将预计占用信道多长时间，通过 NAV 来确定退避时间，减少冲突；</li></ul></li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/22.png" alt=""></p><h4 id="Fragment-Burst-段突发">Fragment Burst 段突发</h4><p>如果信道的误码率较高，那么 ACK 和重传的作用较小；而短帧出错概率小，所以采用 <strong>Fragment burst 段突发</strong> 的方式，将较长的帧分为小的 Fragment进行发送，来提高可靠性；<br><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/23.png" alt=""></p><h4 id="Saving-Power-省电模式">Saving Power 省电模式</h4><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/24.png" alt=""></p><h4 id="TXOP-Transmission-Opportunities">TXOP(Transmission Opportunities)</h4><p>如果两个站点产生竞争，原始的 CSMA/CA 采用频繁竞争，即每次发送都进行竞争，谁竞争成功了谁发，但这样会导致速率异常，假设站点的带宽分别为 $c_1,c_2$，则平均数据率为：</p><p>$$<br>\frac{1}{c_{ave}} = \frac{1}{c_1} + \frac{1}{c_2} \Rightarrow c_{ave} = \frac{1}{\frac{1}{c_1} + \frac{1}{c_2}}<br>$$</p><p>即平均数据率小于任何一个站点，造成速率异常。而 TXOP 给予两个站点相同的发送机会，即竞争一次，获得一段传输时间，即</p><p>$$<br>c = c_i / n<br>$$<br>比如对于 6Mbps 和 54Mbps 的两个站点，采用TXOP后，按照 3Mbps 和 27Mbps 发送帧；</p><h4 id="Frame">Frame</h4><ul><li>Data Frame</li><li>Control Frame<ul><li>RTS</li><li>CTS</li><li>ACK</li></ul></li><li>Management Frame<ul><li>Authentication and De-authentication</li><li>Association</li><li>Beacon and Probe Frame</li></ul></li></ul><h5 id="Data-Frame">Data Frame</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;介质访问控制（Media Access Control, Mac）需要完成的任务是，为使用传输介质的每一个节点隔离来自同一信道上其他节点所传送的信号，协调活动节点的传输。&lt;/p&gt;
&lt;h1&gt;Dynamic Channel Allocation&lt;/h1&gt;
&lt;h2 id=&quot;Ass</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计组学习笔记(5)：指令系统</title>
    <link href="https://blog.yokumi.cn/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>https://blog.yokumi.cn/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2025-04-04T02:12:00.000Z</published>
    <updated>2025-05-11T15:52:11.252Z</updated>
    
    <content type="html"><![CDATA[<h1>指令分类</h1><ul><li><strong>微指令</strong>：微程序级的命令，属于硬件；</li><li><strong>机器指令</strong>：介于微指令与宏指令之间，单独一题哦啊即可完成一个独立的算术/逻辑运算；</li><li><strong>宏指令</strong>：有若干条机器指令组成的软件指令，属于软件；</li></ul><blockquote><p><strong>注</strong>：<strong>指令系统ISA(Instruction Set Architecture)</strong>，也称指令集架构；</p><blockquote><p>包含了所有机器指令的集合；<br>定义机器级程序的格式和行为，以及处理器状态；<br>指令系统有如下要求：<br>完备性；<br>有效性；<br>规整型：</p><blockquote><p>对称性：寄存器和存储器单元同等对待，都可以使用各种寻址方式；<br>匀齐性：一种操作性质的指令可以支持各种数据类型；<br>一致性：指令长度与数据长度有一定关系；<br>兼容性：<strong>向后兼容</strong>，即旧处理上运行的软件仍可以在新处理器上运行；</p></blockquote></blockquote></blockquote><h1>指令格式</h1><ul><li>指令字，即指令，指表示一条指令的机器字；</li><li>指令格式是指令字用二进制表示的结构形式；</li><li>指令的构成：<ul><li>操作码OP字段：长度取决于指令集的规模；</li><li>地址码字段：指定参与操作的操作数的地址，1条指令地址码部分有$x$个操作地址，则称该指令为$x$操作数指令或$x$地址指令；</li></ul></li><li>按照操作数的物理位置不同，指令分为：<ul><li>存储器-存储器（SS）型指令：即操作数都存在内存中；</li><li>寄存器-寄存器（RR）型指令：即操作数都存在寄存器中，不需要访问内存；</li><li>寄存器-存储器（RS）型指令；</li></ul></li><li>按指令字长度分类：<ul><li>单字长指令；</li><li>半字长指令；</li><li>双字长指令；</li><li>注：多字长指令能提供更大的地址空间，但必须多次访问内存取出一整条指令；</li><li>等长指令字结构 vs. 变长指令字结构；</li></ul></li><li>扩展操作码指令格式：其中，前缀1111作为特征位，用于区分这是几地址指令；<img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/1.png" alt=""></li><li>指令助记符：<ul><li>助记符 $\rightarrow$ 二进制操作码：汇编（汇编器实现）；</li><li>二进制操作码 $\rightarrow$ 助记符：反汇编；</li></ul></li></ul><h1>指令和数据的寻址方式</h1><p>在存储器中，读/写操作数/指令字的方式有：</p><ul><li>地址指定方式；</li><li>相联存储方式（按内容寻址）；</li><li>堆栈存取方式；</li></ul><h2 id="地址指定方式">地址指定方式</h2><h3 id="指令寻址方式">指令寻址方式</h3><h4 id="顺序寻址方式">顺序寻址方式</h4><p>通过<strong>程序计数器PC</strong>来计数指令的顺序号，该顺序号就是指令在内容中的地址；</p><h4 id="跳跃寻址方式">跳跃寻址方式</h4><p>用于实现条件转移、无条件转移和子程序调用等；</p><h3 id="操作数寻址">操作数寻址</h3><p>形成操作数有效地址的方法，称为操作数寻址方法；<br>一种单地址指令的结构如下：<br><img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/2.png" alt=""></p><ul><li>操作数地址由变址X、间址I、形式地址A(也称偏移量offset)组成；</li></ul><h4 id="隐含寻址">隐含寻址</h4><p>隐含默认地给出操作数的地址；</p><h4 id="立即寻址">立即寻址</h4><p>地址码字段是操作数本身而不是操作数的地址(<strong>立即数</strong>)；</p><h4 id="直接寻址">直接寻址</h4><p>在地址码字段直接给出操作数在内存中的地址A；即形式地址A就是操作数的有效地址EA：<br>$$<br>EA = A<br>$$</p><h4 id="间接寻址">间接寻址</h4><p>在地址码字段给出的是操作数地址的地址，需要两次访存，即：<br>$$<br>EA = (A)<br>$$</p><blockquote><p><strong>注</strong>：一般用寻址特征位 $I$ 区分两种方式，$I = 0$表示直接寻址，$I = 1$表示间接寻址；</p></blockquote><h4 id="寄存器寻址">寄存器寻址</h4><p>操作数地址并不是内存的地址，而是寄存器的编号；地址码字段直接取指定寄存器的内容，就是操作数；</p><h4 id="寄存器的间接寻址">寄存器的间接寻址</h4><p>地址码字段指定的寄存器的内容是操作数的地址；</p><h4 id="偏移寻址">偏移寻址</h4><h5 id="相对寻址">相对寻址</h5><p>程序计数器PC的内容加上偏移量A(有符号数)形成操作数的有效地址；<br><img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/3.png" alt=""></p><h5 id="基址寻址">基址寻址</h5><p>基址寄存器的内容加上偏移量A(有符号数)形成操作数的有效地址；<br><img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/4.png" alt=""></p><h5 id="变址寻址">变址寻址</h5><p>变址寄存器的内容加上偏移量A(有符号数)形成操作数的有效地址；其中变址寄存器的内容会自动递增或递减；</p><h3 id="段寻址方式">段寻址方式</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/5.png" alt=""></p><ul><li>段寄存器左移4位形成20位物理地址；</li></ul><h3 id="堆栈寻址">堆栈寻址</h3><h4 id="寄存器堆栈">寄存器堆栈</h4><ul><li><strong>栈顶不动，数据移动</strong>；</li><li>数据的读出具有破坏性；</li><li>堆栈大小受限；</li></ul><h4 id="存储器堆栈">存储器堆栈</h4><p>在主存中划分出一片堆栈区域，CPU用一个专门的寄存器 SP（Stack Pointer，栈顶指示器）存储栈顶的位置；</p><ul><li><strong>栈顶移动，数据不动</strong>；</li><li>堆栈空间可以自行分配；</li><li>栈顶指示有2种方式：<ul><li>SP 指向空单元；</li><li>SP 指向满单元；</li></ul></li></ul><h1>CISC(Complex Instruction Set Computing, 复杂指令集)计算机</h1><ul><li>指令系统庞大；</li><li>指令长度不固定；</li><li>指令格式复杂；</li><li>寻址方式多；</li><li>通用寄存器数量少；</li><li>各种指令的指令时间相差很大；</li><li>各种指令的使用频度相差较大；</li><li>使用微程序控制器；</li></ul><h1>RISC(Reduced Instruction Set Computing, 精简指令集)计算机</h1><ul><li>选取使用频率最高的一些简单指令，指令数量少；</li><li>指令长度固定；</li><li>指令格式种类少；</li><li>寻址方式简单；</li><li>只有 Load / Store 指令访问存储器，其他均在寄存器之间进行；</li><li>通用寄存器数量较多，减少访存次数；</li><li>大部分指令在一个机器周期内完成；</li><li>使用硬布线控制器；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;指令分类&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;微指令&lt;/strong&gt;：微程序级的命令，属于硬件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机器指令&lt;/strong&gt;：介于微指令与宏指令之间，单独一题哦啊即可完成一个独立的算术/逻辑运算；&lt;/li&gt;
&lt;li&gt;&lt;stron</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机组成原理" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组学习笔记(4)：存储系统I</title>
    <link href="https://blog.yokumi.cn/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/"/>
    <id>https://blog.yokumi.cn/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/</id>
    <published>2025-04-03T02:42:00.000Z</published>
    <updated>2025-05-11T15:52:11.273Z</updated>
    
    <content type="html"><![CDATA[<h1>存储器的分类</h1><ul><li>按照介质分类：<ul><li>半导体存储器、磁介质存储器、光存储器；</li></ul></li><li>按照存储器与CPU的耦合程度：<ul><li>内存（主存 + cache）、外存；</li></ul></li><li>按照存储器的读写功能：<ul><li>读写存储器RWM；</li><li>只读存储器ROW；</li></ul></li><li>按照掉电后存储的信息是否保持：<ul><li>易失性；</li><li>非易失性；</li></ul></li><li>按照数据存取的随机性：<ul><li>随机存取RAM：指随机给定一个地址就可以拿到数据并与前一个访问的地址无关；</li><li>顺序存取SAM：比如磁带；</li><li>直接存取DAM：确定区域后顺序存取；</li></ul></li><li>按照半导体存储器的信息存储方法：<ul><li>静态Static；</li><li>动态Dynamic；</li></ul></li><li>习惯分类：<ul><li>RAM vs. ROM；</li><li>SRAM vs. DRAM(内存条) vs. 闪存；</li><li>MASK ROM(掩膜) vs. PROM(可编程)；<ul><li>EPROM(可擦除PROM)<ul><li>紫外线擦除；</li><li>电擦除；</li></ul></li></ul></li></ul></li></ul><h1>存储器目标</h1><ul><li>大容量；</li><li>高速度；</li><li>低价格；</li></ul><h2 id="层次结构存储器系统">层次结构存储器系统</h2><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/1.png" alt=""></p><h2 id="并行技术">并行技术</h2><ul><li>单体多字：一个读写体，每次存取多个字；</li><li>多体单字：多个读写体，交叉编址，向多个地址读取内容；</li></ul><h2 id="存储容量">存储容量</h2><p>存储容量 = 存储字数（存储单元数） $\times$ 存储字长（每单元的比特数）</p><h2 id="存取速度">存取速度</h2><ul><li>访问时间/存取时间$T_A$：从启动一次存储器操作到该操作完成所经历的时间，即从存储器接收到读/写命令到信息被读出或写入完成所需的时间；</li><li>存取周期$T_m$：存储器在连续读写过程中，完成一次完整的读/写操作所需的全部时间，即CPU连续两次独立访问存储器的最小时间间隔；</li><li>存储器带宽：单位时间内能传输的信息量；</li></ul><blockquote><p><strong>注</strong>：存取周期$T_m$一般大于存取时间$T_A$，因为存储器完成读/写操作后一般需要一段恢复内部状态的复原时间，即$存取周期 = 存取时间 + 恢复时间$；</p></blockquote><h1>SRAM</h1><h2 id="基本结构">基本结构</h2><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/2.png" alt=""><br><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/3.png" alt=""></p><h2 id="基本时序">基本时序</h2><h3 id="读周期">读周期</h3><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/4.png" alt=""></p><h2 id="写周期">写周期</h2><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/5.png" alt=""></p><h1>只读存储器</h1><h2 id="特点">特点</h2><ul><li>只能读出，不能写入；</li><li>不易失；</li><li>只读存储器写入数据的过程称为对其<strong>编程</strong>；</li></ul><h2 id="分类">分类</h2><ul><li>掩模式只读存储器：不能进行重写；</li><li>一次可编程只读存储器PROM：<ul><li>双极型PROM：<ul><li>熔丝烧断型；</li><li>PN结击穿型；</li></ul></li></ul></li><li>多次可编程只读存储器；<ul><li>光擦除EPROM：利用<strong>雪崩注入</strong>，擦除是对<strong>所有</strong>存储单元进行，不能实现选择性擦除；</li><li>电擦除EEPROM/E$^2$PROM；</li><li>电改写EAROM；</li></ul></li><li>闪存Flash Memory；<ul><li>NAND闪存：只允许顺序<strong>按页(Page)存取</strong>数据；<img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/6.png" alt=""></li><li>NOR闪存：具有完整地址/数据结构，能快速随机地读取任一单元；</li></ul></li></ul><blockquote><p><strong>NAND vs. NOR</strong><br><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/7.png" alt=""></p></blockquote><blockquote><p><strong>注</strong>：任何计算机必须有ROM，即必须要有经过编程的ROM（称为<strong>Bios</strong>，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序），用于计算机程序的初始装入，如果都是RAM，那么计算机初始状态下根本不存在程序和数据；</p></blockquote><h1>并行存储器</h1><h2 id="双端口存储器DPRAM">双端口存储器DPRAM</h2><h3 id="基本结构-2">基本结构</h3><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/8.png" alt=""></p><h3 id="实例：IDT7133">实例：IDT7133</h3><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/9.png" alt=""></p><blockquote><p><strong>注</strong>：其中Busy Flag用于控制能否访问，防止左右端口同时访问同一个地址造成冲突；Busy = 0表示不能访问；仲裁方式如下：</p></blockquote><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/10.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;存储器的分类&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;按照介质分类：
&lt;ul&gt;
&lt;li&gt;半导体存储器、磁介质存储器、光存储器；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按照存储器与CPU的耦合程度：
&lt;ul&gt;
&lt;li&gt;内存（主存 + cache）、外存；&lt;/li&gt;
&lt;/ul&gt;
&lt;/</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机组成原理" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>阿里云ESC + V2RayA实现科学上网</title>
    <link href="https://blog.yokumi.cn/2025/04/03/%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://blog.yokumi.cn/2025/04/03/%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</id>
    <published>2025-04-03T00:45:00.000Z</published>
    <updated>2025-05-10T12:17:54.554Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为个人的阿里云国内服务器偶遇运营商垃圾跨境节点导致连接github及其不稳定，所以有了这篇帖子；</p></blockquote><h1>环境</h1><blockquote><p>操作系统：Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-202-generic x86_64)<br>云服务器：阿里云ESC<br>代理客户端：V2RayA，优点是适用于无图形化的操作系统；</p></blockquote><h1>V2RayA 简介</h1><blockquote><p>一个易用而强大的，跨平台的 V2Ray 客户端<br>使用 Golang 和 Vue.js 编写，运行时没有任何外部依赖库，可跨平台运行，借助任意一款浏览器均可操作；<br>对于无图形界面的操作系统，打开它提供的 Web UI 就能完成配置工作，对于远程服务器及其友好；</p></blockquote><h1>V2RayA 安装</h1><p>演示通过软件源安装，其他安装方法和操作系统请参考：<a href="https://v2raya.org/docs/prologue/installation">请选择你的英雄</a></p><blockquote><p><strong>添加公钥</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -qO - https://apt.v2raya.org/key/public-key.asc | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/keyrings/v2raya.asc<br></code></pre></td></tr></table></figure><blockquote><p><strong>添加 V2RayA 软件源</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [signed-by=/etc/apt/keyrings/v2raya.asc] https://apt.v2raya.org/ v2raya main&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/v2raya.list<br><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure><blockquote><p><strong>安装 V2RayA</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install v2raya v2ray<br></code></pre></td></tr></table></figure><p>出现以下信息，说明安装成功：<img src="%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png" alt=""></p><h1>启动 V2RayA</h1><blockquote><p><strong>启动 V2RayA</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start v2raya.service<br></code></pre></td></tr></table></figure><blockquote><p><strong>设置 V2RayA 为开机自启动</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> v2raya.service<br></code></pre></td></tr></table></figure><blockquote><p><strong>检查V2RayA 启动状态</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl status v2raya.service<br></code></pre></td></tr></table></figure><p>如果看到类似以下信息，说明启动成功：<img src="%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png" alt=""></p><h1>V2RayA 配置</h1>]]></content>
    
    
    <summary type="html">让你的云服务器能够科学上网</summary>
    
    
    
    <category term="开发心得" scheme="https://blog.yokumi.cn/categories/%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="云服务器" scheme="https://blog.yokumi.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机学习笔记(2)</title>
    <link href="https://blog.yokumi.cn/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/"/>
    <id>https://blog.yokumi.cn/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/</id>
    <published>2025-03-31T13:40:00.000Z</published>
    <updated>2025-05-11T15:52:11.261Z</updated>
    
    <content type="html"><![CDATA[<h1>正则集和正则式</h1><ul><li>正则集：字母表上一些特殊形式的字符串的集合，是正则式说表示的集合；</li><li>正则式：用类似代数表达式的方式表示正则语言；</li><li>运算：（按照运算优先级从高到低排序）<ul><li>$*$(closure)闭包；</li><li>$\cdot$ (concatenation)连接；</li><li>$+$ (union)联合</li></ul></li></ul><p>注：</p><ul><li>正则式相等等价于正则集相等；</li><li>一个正则式对应一个正则集，但一个正则集可能有多个正确的正则式；</li></ul><h1>右线性文法与正则式</h1><p>右限性文法又称正则文法。右线性文法和正则式都可以用代表正则语言；</p><h2 id="从右线性文法导出正则式">从右线性文法导出正则式</h2><p>设$x \rightarrow \alpha x + \beta(\Leftrightarrow x \rightarrow \alpha x 和x\rightarrow \beta)$，其中$\alpha \in T^<em>,\beta \in (N + T)^</em>,x\in N$，则：$x$的解为$x = \alpha^*\beta$；</p><h1>正则集与右线性文法</h1><ul><li>正则集是由右线性文法产生的语言；</li><li>右线性文法产生的语言都是正则集；</li><li>一个语言是正则集，当且仅当该语言问右线性语言；</li></ul><h1>正则式与有限自动机</h1><h2 id="从DFA构造等价的正则表达式">从DFA构造等价的正则表达式</h2><h3 id="状态消去法">状态消去法</h3><p><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/1.png" alt=""></p><p>具体步骤：<br><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/2.png" alt=""></p><h2 id="从正则式构造等价的-epsilon-NFA">从正则式构造等价的$\epsilon$-NFA</h2><h3 id="归纳构造法">归纳构造法</h3><p><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/3.png" alt=""><br><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/4.png" alt=""><br><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/5.png" alt=""></p><h1>右线性语言与有限自动机</h1><p><strong>定理</strong>：由任意右线性文法定义G定义的语言必然能被一个NFAM所接受，即$L(G) = L(M)$；</p><h2 id="构造与右线性文法等价的NFA">构造与右线性文法等价的NFA</h2><p><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/6.png" alt=""></p><p><strong>省流</strong>：</p><ol><li>新增一个状态作为终止状态；</li><li>对仍在扩展非终结符的生成式，则转移到对应状态；</li><li>对到达终结符的生成式，则转移到新增的结束状态；</li><li>结束状态不存在转移；</li></ol><h2 id="构造能接受NFAM定义的语言的有限性文法">构造能接受NFAM定义的语言的有限性文法</h2><p><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/7.png" alt=""></p><h1>DFA的极小化</h1><p>填表法；</p><h1>Pumping定理</h1><p>判定正则语言的必要条件；<br><strong>定理</strong>：设$L$是正则集，存在常数$n$，对字符串$\omega \in L$且$\left | \omega \right | &gt; n$，则$\omega$可以写成$\omega_1\omega_o\omega_2$，其中$\left | \omega_1 \omega_0\right | \le n$，$\left | \omega_0\right | &gt; 0$，对所有的$i \ge 0$，有$\omega_1\omega_0^i\omega_2 \in L$；</p><p>显然，该定理可以用来证明某个语言不是正则语言；</p><p><strong>证明步骤</strong>：</p><ol><li>对于足够大的n；</li><li>找到一个满足以下条件的串$\omega \in L$（串长至少为n）；</li><li>任选满足$\omega = \omega_1\omega_o\omega_2$，其中$\left | \omega_1 \omega_0\right | \le n$，$\left | \omega_0\right | &gt; 0$；</li><li>找到一个$i$，使得$\omega_1\omega_0^i\omega_2 \notin L$；</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;正则集和正则式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;正则集：字母表上一些特殊形式的字符串的集合，是正则式说表示的集合；&lt;/li&gt;
&lt;li&gt;正则式：用类似代数表达式的方式表示正则语言；&lt;/li&gt;
&lt;li&gt;运算：（按照运算优先级从高到低排序）
&lt;ul&gt;
&lt;li&gt;$*$(closure</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机基础" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计组学习笔记(2)：运算方法与运算器II</title>
    <link href="https://blog.yokumi.cn/2025/03/22/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/"/>
    <id>https://blog.yokumi.cn/2025/03/22/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/</id>
    <published>2025-03-22T12:40:00.000Z</published>
    <updated>2025-05-11T15:52:11.252Z</updated>
    
    <content type="html"><![CDATA[<h1>原码乘法运算</h1><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/1.png" alt=""></p><h2 id="部分积">部分积</h2><p>每次提$2^{-1}$，即右移1位：<br><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/2.png" alt=""></p><h1>原码除法运算</h1><h2 id="加减交替法">加减交替法</h2><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/3.png" alt=""></p><h1>浮点数的表示方法</h1><p>一个任意进制数$N$可以表示为：<br>$$<br>N = M \times R^E<br>$$</p><p>其中：</p><ul><li>$M$表示尾数，是一个小数；</li><li>$E$表示阶码/指数，是一个整数；</li><li>$R$表示基数，一般为2，8，16；</li></ul><p>尾数的有效数字位数决定了浮点数的表示精度；阶码的有效数字位数决定了浮点数的表示范围；<br><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/4.png" alt=""></p><h2 id="浮点数的规格化表示">浮点数的规格化表示</h2><p>对于基数为$R$的规格化浮点数，要求其尾数的绝对值范围：<br>$$<br>\frac{1}{R} \le |M| &lt; 1<br>$$</p><p>对于原码表示的浮点数，即要求最高数值位为1；<br><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/5.png" alt=""></p><h2 id="IEEE-754浮点数标准">IEEE 754浮点数标准</h2><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/6.png" alt=""></p><ul><li>e，阶：用移码表示，即$E = Exp - (2^{n - 1} - 1)$</li><li>Frac，小数字段：<ul><li>规格化数表示：$M = 1 + Frac$；</li><li>非规格化数表示：$M = Frac$；</li></ul></li></ul><h3 id="特殊的浮点数表示">特殊的浮点数表示</h3><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/7.png" alt=""></p><h3 id="浮点数可表示的数值范围">浮点数可表示的数值范围</h3><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/8.png" alt=""></p><h1>浮点数的加减法</h1><h2 id="步骤">步骤</h2><p>$$<br>x\pm y = (M_x 2^{E_x - E_y} \pm M_y)2^{E_y},E_x \le E_y<br>$$</p><ol><li>检查操作数是否为0；</li><li>对阶：小阶向大阶对齐；</li><li>用双符号位的尾数进行加减运算；</li><li>规格化：<ol><li>如果双符号位出现01、10的非法值，则向右规格化直至合法；</li><li>检查是否符合规格化小数的要求，向左规格化直至合法；</li></ol></li><li>舍入（可能再次规格化）：向偶数舍入；</li></ol><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');});</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;原码乘法运算&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机组成原理" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计网学习笔记(3)：数据链路层</title>
    <link href="https://blog.yokumi.cn/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://blog.yokumi.cn/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2025-03-21T01:17:00.000Z</published>
    <updated>2025-05-11T15:52:11.252Z</updated>
    
    <content type="html"><![CDATA[<p>数据链路层对实际在物理层中传输的信号起到差错控制和流量控制的作用，特别是在广播信道中，需要解决多个发送方同时发送信号造成的共享信道冲突，一般由接受方控制发送方。</p><h1>Technologies</h1><h2 id="Framing">Framing</h2><h3 id="定义">定义</h3><p>Encapsulates network packet into a frame，封装成帧，即将网络层发送的Packet加上Header和Trailer，组成Frame。</p><h3 id="要求">要求</h3><p>由于数据链路层间是虚拟通信，实际信号传输通过物理层传输01比特串，这要求数据链路层从01比特串中能正确识别出帧（<em><strong>帧同步</strong></em>）。</p><ul><li>Simple，容易实现；</li><li>Code Independent，加上的内容与传输的消息内容无关；</li><li>Efficient，所用信号带宽尽量小；</li><li>Robustness，出错后能重新同步；</li></ul><h3 id="方式">方式</h3><h4 id="Character-Count-字符计数法">Character Count 字符计数法</h4><p>在每帧之前加上一个字符表示帧的长度，一错后面都错；</p><h4 id="Byte-Stuffing-字符填充法">Byte Stuffing 字符填充法</h4><p>用特定的标志表示帧的开始和结束：<img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/2.png" alt=""></p><p>如果帧的其他控制和数据部分含有帧的开始符或结束符怎么办？——<em><strong>Transparent Transmission透明传输</strong></em><br><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/3.png" alt=""></p><p>即：如果中间含有Flag，在Flag之前插入1个ESC；如果中间含有ESC，在ESC前面插入1个ESC；</p><h4 id="Bit-Stuffing-比特填充法">Bit Stuffing 比特填充法</h4><ol><li>用连续的6个1表示开始和结束标志：01111110；</li><li>中间部分，在从左到右每出现5个1之后插入1个0，可以有效避免中间部分被识别为开始符或结束符，且容易解码；</li></ol><h4 id="Physical-Layer-Coding-Violations-物理层编码违例法">Physical Layer Coding Violations 物理层编码违例法</h4><p>适用于比较特殊的编码，比如Manchester编码，用没有出现跳变的信号表示开始符和结束符；</p><h2 id="Error-control">Error control</h2><h3 id="基本概念">基本概念</h3><h4 id="Error-Types">Error Types</h4><ul><li>Lost Frames；</li><li>Damaged Frames；</li></ul><h4 id="Error-Detection-检错">Error Detection 检错</h4><ul><li>Parity Check 奇偶校验：单冗余码；</li><li>Cyclic Redundancy Check(CRC) 循环检错；</li><li>Checksum：在网络层中；</li></ul><h4 id="Error-Correction-纠错">Error Correction 纠错</h4><p>Error Correction Code(ECC) 纠错码，分为：</p><ul><li><em><strong>Forward Error Correction(FEC) 前向纠错</strong></em>：例如汉明编码；</li><li><em><strong>Automatic Repeat reQuest(ARQ) 自动重传请求</strong></em>：检错+重传；</li><li><em><strong>Hybrid Error Correction(HEC) 混合纠错</strong></em>；</li></ul><h4 id="Single-bit-Error-vs-Burst-Error">Single-bit Error vs. Burst Error</h4><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4.png" alt=""></p><p><em><strong>注意下图中突发错误的长度为5：从第一个错误的到最后一个错误的比特数</strong></em>；</p><h3 id="ECC纠错码：汉明距离">ECC纠错码：汉明距离</h3><p>在所有合法的码字中：</p><ul><li>如果需要检测出 t 位比特错误，需要最小汉明距离为 t + 1；</li><li>如果需要纠正出 t 位比特错误，需要最小汉明距离位 2t + 1；</li></ul><h4 id="The-Num-of-Check-Bits-to-Correct-Single-Bit-Error">The Num of Check Bits to Correct Single Bit Error</h4><p>只考虑纠正一位错误：</p><ul><li>$m$：原始信息长度；</li><li>$r$：check bits，即需要增加的校验位长度；</li><li>$n$：码字长度，即$n = m + r$；</li></ul><p>根据原始信息长度，推出存在$2^m$个合法信息，每一个合法信息按照$n$的码字传输，能产生和它有一位比特差错的种类有$n$个，所有共有$(n + 1)2^m$个码字；<br>$n$位码字的种类共有$2^n$个，所以要求：</p><p>$$<br>(n + 1)2^m \le 2^n \Leftrightarrow m + r + 1 \le 2^r<br>$$</p><h4 id="汉明编码：Correction-of-Single-Bit-Error">汉明编码：Correction of Single Bit Error</h4><ul><li>只允许在$2^i$位置处放置校验位Check Bits；</li><li>剩下的位置填充数据位；</li></ul><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/5.png" alt=""><br><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/6.png" alt=""></p><h3 id="Error-Detection-Code">Error Detection Code</h3><h4 id="Even-Parity-Checking-偶校验">Even-Parity Checking 偶校验</h4><h4 id="Polynomial-Code-多项式编码">Polynomial Code 多项式编码</h4><p>也称为<em><strong>CRC(Cyclic Redundancy Check，循环冗余校验)</strong></em> 或 <em><strong>FCS(Frame Check Sequence，帧校验序列)</strong></em> ；</p><ul><li>$M(x)$：将要传输的比特看成多项式，比如：$110001 \Rightarrow x^5 + x^4 + x^0$；</li><li>运算定义为模2运算，即$x + y = x - y = x\oplus y$；</li><li>$G(x)$：生成多项式；</li></ul><h5 id="计算过程">计算过程</h5><ol><li>$M(x) * x^r$，即在传输的数据右边增加$r$个0；</li><li>$M(x) * x^r / G(x) \cdots R(x)$，即作除法后得到余数多项式$R(x)$；</li><li>Sender发送方：$T(x) = M(x) * x^r + R(x) = M(x) * x^r - R(x)$；</li><li>Receiver接收方：$T(x) / G(x)$，余数一定为0；</li></ol><h5 id="检查过程">检查过程</h5><ol><li>接收方如果收到错误的信息，即$T(x) + E(x)$；</li><li>正常不出错的情况下，$T(x) / G(x)$余数为0；</li><li>出错的情况下，结果为$E(x) / G(x)$的余数；</li><li>能捕捉到所有的错误；</li></ol><h2 id="Flow-control">Flow control</h2><h3 id="Flow-Control-Protocols">Flow Control Protocols</h3><h4 id="Elementary-Protocols">Elementary Protocols</h4><ul><li><em><strong>Utopian Simplex Protocol 乌托邦单工协议</strong></em>；<ul><li>通信是单通的；</li><li>通信是无错的；</li><li>接收方缓存空间无限；</li><li>无需差错控制和流量控制；</li></ul></li><li>***Simplex Stop-and-Wait Protocol for Error-Free Channel 停等协议<ul><li>通信是单通的；</li><li>通信是无错的；</li><li>接收方缓存空间有限；</li><li>需要流量控制：Stop-and-Wait<ul><li>发送方发送一个Frame，等待；</li><li>接收方如果正确收到信息，发送一个<em><strong>ACK(Acknowledgement，应答)</strong></em>；</li><li>发送方接收到ACK后，发送下一个Frame；</li></ul></li><li>如果通信不可靠，会产生如下问题：帧错误、帧丢失或ACK丢失<img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/7.png" alt=""></li><li>其中，如果ACK丢失，发送方会在超时后发送第二个相同的帧，但是接收方并不知道！解决方法：<em><strong>Sequence Number</strong></em>；</li></ul></li><li><em><strong>Protocol 3: Positive ACK with Retransmission(PAR) 带有重试的主动确认协议</strong></em><ul><li><em><strong>ARQ(Automatic Repeat reQuest) 自动重传请求</strong></em><ul><li>在每个Frame之前添加序号，来区分该Frame是重传的还是新的；</li><li>链路层只需要1bit，即编号空间大小为2；</li><li>传输层需要更大的编号空间；</li><li>但是还是有问题：如果ACK传输延迟了，如下图所示，那么当那个重复发送的Frame0收到后返回给发送方时，发送方认为这是Frame1的应答信号，错误地认为Frame1已经正确发送到接收方；<img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/8.png" alt=""></li><li>所以需要给ACK也添加序号：<img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/9.png" alt=""></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SEQ 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> <br>frame_arrival, <br>cksum_err, <br>timeout <br>&#125; event_type;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;protocol.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span> &#123;<br>seq_nr next_frame_to_send = <span class="hljs-number">0</span>;<br>frame s;<br>packet buffer;<br>event_type event;<br><br>from_network_layer(&amp;buffer);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>s.info = buffer;<br>s.seq = next_frame_to_send;<br>to_physical_layer(&amp;s);<br>start_timer(s.seq);<br>wait_for_event(&amp;event);<br><br><span class="hljs-keyword">if</span> (event == frame.arrival) &#123;<br>from_physical_layer(&amp;s);<br><span class="hljs-keyword">if</span> (s.ack == next_frame_to_send) &#123;<br>stop_timer(s.ack);<br>from_network_layer(&amp;buffer);<br>next_frame_to_send = <span class="hljs-number">1</span> - next_frame_to_send;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> &#123;<br>seq_nr frame_expected = <span class="hljs-number">0</span>;<br>frame r, s;<br>event_type event;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>wait_for_event(&amp;event);<br><br><span class="hljs-keyword">if</span> (event == frame.arrival) &#123;<br>from_physical_layer(&amp;r);<br><span class="hljs-keyword">if</span> (r.seq == frame_expected) &#123;<br>to_network_layer(&amp;r.info);<br>frame_expected = <span class="hljs-number">1</span> - frame_expected;<br>&#125;<br>s.ack = <span class="hljs-number">1</span> - frame_expected;<br>to_physical_layer(&amp;s);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><em><strong>Piggybacking 捎带应答</strong></em><ul><li>通信是全双工Full-duplex的；</li><li>当接收方收到帧后，不立刻发送ACK，而是等待网络层有发送请求时，将ACK添加到需要发送的帧中一起发送；</li><li>缺点是在如果长时间没有发送请求，会因等待应答而造成信道阻塞；</li></ul></li></ul><h4 id="Sliding-Window-Protocols-滑动窗口协议">Sliding Window Protocols 滑动窗口协议</h4><h5 id="特点">特点</h5><ul><li>可靠，面向连接的服务；</li><li>信道是全双工的；</li><li>通过CRC+重传进行差错控制；</li><li>通过滑动窗口进行流量控制；</li></ul><h5 id="Protocol-4-Sliding-Window-of-Size-1-大小为1的滑动窗口协议">Protocol 4: Sliding Window of Size 1 大小为1的滑动窗口协议</h5><ul><li>实际上就是停等协议，只不过变成了全双工，既能发又能收；</li><li>在两端同时发送数据时会出现帧重复；</li><li>信道效率低，特别是带宽时延积较大的信道，比如卫星通信；</li></ul><h5 id="Protocol-5-GBN-Go-Back-N-回退N步">Protocol 5: GBN(Go Back N 回退N步)</h5><ul><li>默认情况下接收窗口$W_r = 1$；</li><li>$W_t + W_r \le 2^n$，所以发送窗口需要满足$W_t \le 2^{n} - 1$；</li><li>如果收到的帧出错，之后接受到的帧都丢弃，直到出错的帧重新发送后被正确接收，在此期间接收方保持沉默，并不会应答；</li><li>如果收到的帧与预期收到的不符，丢弃该帧，并回送ACK为当前最后一个已经收到的正确的帧的序号；发送方收到后需要从该ACK序号之后的帧开始重传；</li><li>发送方在接收到ACK或帧计时器超时后，需要回退到发错的那一帧并重传；</li><li>注意ACK的应答可以采用<em><strong>Cumulative ACK</strong></em>（累计ACK）：不需要每一帧都回送一个ACK，当接收方发送ACK = n时，表示n以及n之前的数据帧都已经正确收到；</li><li>对于 $n$ bits的序列号码，$MAX_SEQ = 2^n - 1$；</li><li>默认接受方的Buffer缓存空间 $= MAX_SEQ + 1$；</li></ul><p><em><strong>Protocol 4 vs. Protocol 5</strong></em>：<br><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/10.png" alt=""></p><h5 id="Protocol-6-SR-ARQ-Selective-Repeat-选择重传">Protocol 6: SR ARQ(Selective Repeat 选择重传)</h5><ul><li>只有被拒绝的帧才需要重传；</li><li>一般默认$W_t = W_r = 2^{n-1}$，注意与Protocol 5区分；</li><li>一般，认为接收方需要的Buffer空间 $= W_r$，帧缓存的位置 = $frame.seq % W_r$，这样能否有效保证任意位置接受窗口内的帧不在同一位置；</li><li><em><strong>Frame Timer</strong></em>：发送方每一个缓存的帧都需要一个Timer；</li><li><em><strong>ACK Timer</strong></em>：只需要一个，以第一个为准；</li><li><em><strong>NCK</strong></em>：以下两种情况，接收方会发送NCK用于加速重传：<ul><li>收到的数据帧校验出错；</li><li>收到的数据帧和预期的不符合；</li><li>NCK的序号就是出错帧（指的是预期的帧）的序号；</li></ul></li><li>向网络层提交数据是一个循环的过程：从接收窗口下沿开始依次提交收到的帧并向前滑动接收窗口直到空闲Buffer出现；</li></ul><h5 id="协议456的比较">协议456的比较</h5><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/11.png" alt=""></p><h3 id="Performance">Performance</h3><p>$$<br>\alpha = \frac{T_{prop}}{T_{trans}}<br>$$</p><h4 id="Error-free-Stop-and-Wait">Error-free Stop-and-Wait</h4><p>$$<br>efficiency = \frac{1}{1+2\alpha}<br>$$</p><h4 id="Stop-and-Wait-with-error">Stop-and-Wait with error</h4><p>$$<br>efficiency = \frac{1 - p}{1 + 2\alpha}<br>$$</p><h4 id="Error-free-Sliding-Window">Error-free Sliding-Window</h4><p>$$<br>efficiency = \left{\begin{matrix}<br>\frac{W_T}{1 + 2\alpha},W_T &lt; 1 + 2\alpha \<br>1, W_T \ge 1 + 2\alpha<br>\end{matrix}\right.<br>$$</p><h4 id="Error-free-Sliding-Window-with-Piggybacking">Error-free Sliding-Window with Piggybacking</h4><p>$$<br>efficiency = \frac{W_T}{2 + 2\alpha}<br>$$</p><h2 id="Media-Access-Control">Media Access Control</h2><p>见计网学习笔记(4)：介质访问控制；</p><h1>Services(to Network Layer)</h1><ul><li>Connectionless services<ul><li>Unacknowledged connectionless services：大多数局域网LAN使用无确认；</li><li>Acknowledged connectionless services：wireless system；</li></ul></li><li>Acknowledged connection-oriented services：</li></ul><h1>Implement</h1><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/1.png" alt=""></p><p>方框内表示一整个Router路由器，一般有3个接口，其中1和2组成路由器的网卡(NIC，Network interface cart)；</p><h1>Examples of Point-to-Point DataLink Protocols</h1><h4 id="HDLC-High-Level-DataLink-Control-高级数据链路控制">HDLC(High-Level DataLink Control, 高级数据链路控制)</h4><h5 id="特点-2">特点</h5><ul><li>可靠，面向连接<ul><li>流量控制，差错控制；</li><li>GoBackN ARQ，Selective Repeat ARQ；</li></ul></li><li>Synchronous serial transmission 同步串行链路传输；</li><li>error detection：CRC；</li><li>不支持相关链路和网络参数协商；</li><li>不支持认证；</li></ul><h5 id="Frame-Type">Frame Type</h5><p>采用零比特填充。<br><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/12.png" alt=""></p><h5 id="Station-Type">Station Type</h5><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/13.png" alt=""></p><h4 id="Point-to-Point-Protocol-PPP-点对点协议">Point-to-Point Protocol(PPP, 点对点协议)</h4><h5 id="特点-3">特点</h5><ul><li>只支持点到点；</li><li>Connectionless unacknowledged service；</li><li>采用字节填充；</li><li>适配多种网络层协议；</li><li>支持身份认证；</li><li>物理层可以采用异步和同步传输；</li></ul><h5 id="Frame-Format">Frame Format</h5><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/14.png" alt=""></p><ul><li>Address = 0xFF，表示支持所有站点；</li><li>Control = 0x03，表示无编号模式；</li><li>以上两个字段非必需，可以不要；</li></ul><h4 id="协议对比">协议对比</h4><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/15.png" alt=""></p><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');// 可以在这里添加额外的回调函数});</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据链路层对实际在物理层中传输的信号起到差错控制和流量控制的作用，特别是在广播信道中，需要解决多个发送方同时发送信号造成的共享信道冲突，一般由接受方控制发送方。&lt;/p&gt;
&lt;h1&gt;Technologies&lt;/h1&gt;
&lt;h2 id=&quot;Framing&quot;&gt;Framing&lt;/h2&gt;
</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计组学习笔记(2)：运算方法与运算器Ⅰ</title>
    <link href="https://blog.yokumi.cn/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/"/>
    <id>https://blog.yokumi.cn/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/</id>
    <published>2025-03-13T04:26:00.000Z</published>
    <updated>2025-05-11T15:52:11.265Z</updated>
    
    <content type="html"><![CDATA[<h1>数据表示方法</h1><h2 id="定点数">定点数</h2><p><img src="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/1.png" alt=""></p><h2 id="机器码">机器码</h2><p>将有符号数中的符号位进行数字化编码得到机器码，原有符号数称为真值。</p><h3 id="原码">原码</h3><ul><li>用第一位表示符号位，正0负1；</li><li>真值转化为原码只需根据正负添加符号位；</li><li>0有2种表示；</li><li>运算不便；</li></ul><h3 id="补码">补码</h3><ul><li>正数补码和原码相同；</li><li>负数的原码转补码相当于+$2^{n - 1}$；从二进制码来看就是除符号位之外的数值位取反再加1；</li></ul><h3 id="反码">反码</h3><ul><li>正数的补码和反码相同；</li><li>负数的反码转补码，除符号位之外的数值位取反；</li></ul><h3 id="移码">移码</h3><p>$$<br>[x_{移}] = x + 2^{n-1}<br>$$</p><ul><li>移码可用来表示浮点数的指数；</li><li>移码和补码尾数相同，符号位相反；</li></ul><h2 id="补码运算">补码运算</h2><p>$$<br>[x + y]<em>{补} = [x]</em>{补} + [y]<em>补<br>$$<br>$$<br>[x - y]</em>{补} = [x]<em>{补} - [y]</em>{补}<br>$$<br>$$<br>-[y]<em>{补} = [-y]</em>{补}<br>$$</p><p>注：已知$y$的补码，求$-y$的补码，按位取反+1即可；</p><h2 id="溢出检测方法">溢出检测方法</h2><h3 id="双符号位法">双符号位法</h3><h4 id="变形补码">变形补码</h4><p>正数符号位用00表示，负数符号位用11表示；</p><ul><li>运算后符号位变01，表示发生正溢出；</li><li>运算后符号位变10，表示发生负溢出；</li><li>运算后符号位为00或11，未溢出；</li><li>正确结果应该是最高符号位；</li></ul><p>通过以上结果可以发现，溢出的情况有以下两种：</p><ul><li>最高有效位发生进位，但第1符号位（即正常补码的符号位）未发生进位；</li><li>第1符号位发生进位，但最高有效位未发生进位；</li></ul><p>所以，现代计算机中直接采用单符号位法用于溢出检测。</p><h3 id="单符号位法">单符号位法</h3><p>$$<br>OF = C_f \oplus C_0<br>$$</p><p>其中：</p><ul><li>$OF$，溢出标志；</li><li>$C_f$，符号位的进位；</li><li>$C_0$，最高有效位的进位；</li></ul><h1>加法器</h1><h2 id="1位全加器">1位全加器</h2><p>$$<br>S_i = A_i\oplus B_i \oplus C_i<br>$$</p><p>$$<br>C_i = A_iB_i + (A_i\oplus B_i)C_i<br>$$</p><p>电路图如下：<br><img src="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/2.png" alt=""></p><h2 id="n位行波进位的补码加法器">n位行波进位的补码加法器</h2><p><img src="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/3.png" alt=""></p><p>观察上图，考虑$n = 2$的简单情况：</p><ul><li>高1位等待低1位产生进位的时间为$3T + 3T + T + T = 3T + 3T + 2T$；</li><li>在得到低一位的进位后，产生该位进位需要$2T$；</li><li>最后产生溢出标志和进位标志需要$3T$；</li></ul><p>所以对于$n$位行波进位加法器，时间延迟为$3T + 3T + (n - 1) * 2T + 2T + 3T = （2n + 9)T$；</p><p>如果不考虑溢出检测，最后不需要通过$2T + 3T$，直接产生结果需要$3T$，时间延迟为$3T + 3T + 2(n - 1)T + 3T = 2(n - 1)T + 9T$；</p><h2 id="先行进位加法器">先行进位加法器</h2><p>加法器进位链的基本逻辑关系为：<br>$$<br>C_{i + 1} = A_iB_i + (A_i+B_i)C_i<br>$$</p><p>令：</p><ul><li>$G_i = A_iB_i$，本地进位；</li><li>$P_i = A_i + B_i$，进位传递条件；</li></ul><p>于是：<br>$$<br>C_{i+1} = G_i + P_iC_i<br>$$</p><p>由此可以递推出如下关系：<br><img src="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/4.png" alt=""></p><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');});</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;数据表示方法&lt;/h1&gt;
&lt;h2 id=&quot;定点数&quot;&gt;定点数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机组成原理" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Agentic Design Pattern AI代理设计模式学习</title>
    <link href="https://blog.yokumi.cn/2025/03/13/Agentic%20Design%20Pattern%20AI%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://blog.yokumi.cn/2025/03/13/Agentic%20Design%20Pattern%20AI%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-13T02:44:00.000Z</published>
    <updated>2025-05-10T12:17:53.969Z</updated>
    
    <content type="html"><![CDATA[<h1>零、概述 Overview</h1><p>我们要让 LLM 一次性根据我们的提示生成一个应用的所有前端代码或一整篇论文，LLM 一次性输出最终 Token，不修改，显然是较为困难并且效果不佳的。但是，如果使用代理设计流（Agent Workflow），让 LLM 按照编排的工作流，多次提示，每个步骤都有优化任务，不断迭代改进输出，类似人拆解复杂任务、收集信息、改进迭代并最终达到满意结果的过程。</p><p>以编写文档为例，工作流大致涉及以下步骤：</p><ol><li>撰写文档大纲；</li><li>查询本地知识库或网络收集资料；</li><li>撰写初稿；</li><li>检查初稿并修正不合理之处；</li><li>如此迭代到文档符合要求；</li></ol><p>代理设计模式主要包括：</p><ol><li><strong>Reflection Pattern</strong>：反思模式，LLM 可以通过反思自己的行为成为更有效的代理；</li><li><strong>Tool Use Pattern</strong>：工具使用模式；</li><li><strong>Planning Pattern</strong>：规划模式；</li><li><strong>Multi-Agent Pattern</strong>：多代理模式；</li></ol><h1>壹、Reflection Pattern</h1><p>反思模式类似于我们直接与大模型对话，通过不断提示大模型达到我们想要的输出。代理设计模式中，需要将提供反馈的步骤自动化。</p><p>比如可以设计 Prompt 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">现有以下任务<span class="hljs-attribute">X</span>：略；以下是用于任务<span class="hljs-attribute">X</span>的代码：略；请你仔细检查代码的正确性、风格和效率，并就如何改进它给出建设性的批评和建议；<br></code></pre></td></tr></table></figure><p>然后，将之前生成的代码和检查后的反馈一起作为 Context 输入给 LLM，让 LLM 根据反馈建议修改代码；</p><p>一个简单的示意图如下：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504081117237.png" alt=""></p><p>当然，实际应用中会涉及多次迭代，以获得更高的精度；</p><h2 id="应用：SELF-RAG">应用：SELF-RAG</h2><p>SELF-RAG 在检索以及生成的过程中引入了自我反思机制，下图直观呈现了它和传统 RAG 的区别：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504081124295.png" alt=""></p><h1>贰、Tool Use Pattern</h1><p>代理通过调用 API 来获取预训练模型权重中缺少的额外信息，比如调用 Web 搜索、访问本地知识库、执行代码等等；</p><h1>叁、Planning Pattern</h1><p>前面已经提到，复杂的问题往往需要拆解为多个步骤。我们可以事先就搭建好代理工作流，但是在代理规划模式下，Agent 能动态决定需要采取的步骤。</p><p>关于任务的分解，主要有以下几种方式：</p><h2 id="Chain-of-Thought-思维链CoT">Chain of Thought(思维链CoT)</h2><p>通过“逐步思考”实现复杂推理，</p><blockquote><p>可参考内容</p></blockquote><p>[1]  <a href="https://arxiv.org/abs/2201.11903?utm_campaign=The%20Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8Kh954rkXmE4vgpKvro3Klpjhn7IuT-Y_eXIYtgVIq9PTzwa5zFWX7FZZqv1tuDEEsTDuY">Chain-of-Thought Prompting Elicits Reasoning in Large Language Models</a>, Wei et al. (2022)；</p><h2 id="Tree-of-Thought">Tree of Thought</h2><p>在前者的基础上进行了扩展，对于每个步骤生成了多个思考，建立树状结构，然后执行 BFS 或 DFS，通过分类器或多数投票进行评估；</p><h1>肆、Multi-Agent Collaboration</h1><p>Multi-Agent Collaboration，即多代理协作，顾名思义，对于一个复杂的任务，拆分成不同的任务，并交给不同代理去做。虽然现在 LLM 的上下文限制不断提升，但对于一个复杂的任务，比如开发一个较为复杂的软件系统，单个 LLM 并不一定能达到较好的效果。而如果像游戏公司一样，将不同部分交给专业的人去做，比如策划、客户端开发、服务端开发、TA、QA、美术等等，让不同的 Agent 完成不同的子任务，可能能达到更好的效果。</p><blockquote><p>可参考内容</p></blockquote><p>[1]  <a href="https://arxiv.org/abs/2307.07924?utm_campaign=The%20Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8TZzur2df1qdnGx09b-Fg94DTsc3-xXao4StKvKNU2HR51el3n8yOm0CPSw6GiAoLQNKua">Communicative Agents for Software Development</a>, Qian et al. (2023)；</p>]]></content>
    
    
    <summary type="html">有关AI代理设计模式的一些学习</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="https://blog.yokumi.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>计网学习笔记(2)：物理层</title>
    <link href="https://blog.yokumi.cn/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://blog.yokumi.cn/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2025-03-07T13:58:00.000Z</published>
    <updated>2025-05-11T15:52:11.288Z</updated>
    
    <content type="html"><![CDATA[<h1>基本概念</h1><ul><li><strong>Bandwidth信道带宽</strong>：$f_{max} - f_{min}$，单位Hz；<ul><li>Analog Bandwidth，模拟信号用Hz表示；</li><li>Digital Bandwidth，数字信号用bps（bit per second）表示；</li><li>Low-pass channel，低通信道，$f_{min} = 0$；</li><li>Band-pass channel，带通信道，$f_{min} &gt; 0$；</li></ul></li><li><strong>Bit Rate(bps)</strong>：比特率；</li><li><strong>Baud Rate(Baud)</strong>：波特率，每秒钟表示bit所需的信号单元的数量；<ul><li>T：一个信号单元的时间；</li><li>Baud Rate = $\frac {1}{T}$；</li><li><em><strong>Bit Rate = Baud Rate $\times$ 一个信号单元携带的bit数 = Baud Rate $\times$ $log_2 {有效状态数}$；</strong></em></li></ul></li><li><strong>信道容量</strong>：信道的最大数据率；</li><li><strong>吞吐量</strong>：单位时间内网络可以传送的数据位数，单位bps；</li><li><strong>负载Load</strong>：单位时间内注入网络的数据位数，单位bps；</li><li><strong>误码率</strong>；</li><li><strong>Delay时延</strong>：第一位开始发送与最后一位数据被接受的时间差；<ul><li><strong>发送时延Transmission Delay</strong>：发送一个数据块需要的时间；<ul><li>Transmission Delay = $\frac {Message Length(bits)}{Bandwidth(bps)}$；</li></ul></li><li><strong>传播时延Propagation Delay</strong>：信号通过传输介质的时间；<ul><li>Propagation Delay = $\frac {length of physical link}{propagation speed in medium}$；</li></ul></li><li>节点处理时延；</li><li>排队时延；</li></ul></li><li><strong>带宽时延积bandwidth-delay product</strong>：表示充满整个链路的bit数（有点像体积），表示信道的缓存能力；<ul><li>Bandwidth-Delay Product = propagation delay $\times$ bandwidth；</li></ul></li></ul><h1>信道</h1><h2 id="Noiseless-Channel-无噪信道">Noiseless Channel 无噪信道</h2><p>理想信道的比特率通过Nyquist Bit Rate（奈奎斯特公式，1924）给出：<br>$$<br>C(Capacity) = Bit Rate = 2 \times bandwidth\times log_2{信道级数(即有效状态数)}<br>$$<br>注意上述公式给出的是理想情况下最大可能的传输速率；</p><h2 id="Noisy-Channel-有噪信道">Noisy Channel 有噪信道</h2><p>有噪信道的传输速率通过Shannon Capacity（香农公式，1948）给出：<br>$$<br>Capacity = bandwidth\times log_2{1 + \frac{signal_power}{noise_power}}<br>$$<br>其中，<strong>信噪比(SNR，Signal-to-Noise Ratio)</strong> 又可以取对数用db(decibels)来表示：<br>$$<br>S/N_{db} = 10log_{10}{(S/N)}<br>$$</p><h1>传输介质Transmission Media</h1><h2 id="传输介质的分类">传输介质的分类</h2><ul><li>磁介质Magnetic Media</li><li>导向型（有线）<ul><li><em><strong>Twisted Pair双绞线</strong></em></li><li><em><strong>Coaxial Cable 同轴电缆</strong></em></li><li><em><strong>Fiber Optics光纤</strong></em></li><li>Power Lines电力线</li></ul></li><li>非导向型（无线）<ul><li><em><strong>Radio无线电</strong></em></li><li><em><strong>Microwave地面微波</strong></em> and <em><strong>Satellite卫星通信</strong></em></li></ul></li></ul><h2 id="频率范围Electromagnetic-Spectrum">频率范围Electromagnetic Spectrum</h2><ul><li>Twisted Pair双绞线：$0$ ~ $10^8$Hz；</li><li>Coaxial Cable同轴电缆：$10^3$ ~ $10^9$Hz；</li><li>Fiber Optics光纤：$10^{14}$ ~ $10^{15}$Hz；（基本属于可见光的范围）</li><li>Radio无线电波：$10^4$ ~ $10^9$；</li></ul><h2 id="传输介质的特性">传输介质的特性</h2><ul><li><em><strong>带宽</strong></em></li><li><em><strong>传播时延</strong></em></li><li><em><strong>最大传输距离</strong></em>（不加放大器等的情况下）</li><li><em><strong>抗干扰能力</strong></em></li><li><em><strong>安全性</strong></em></li><li>安装与维护难易程度、成本</li></ul><h2 id="有线传输介质">有线传输介质</h2><h3 id="Twisted-Pair双绞线">Twisted Pair双绞线</h3><ul><li>两根通电铜导线拧合在一起；（使两根通电导线产生的磁场相互抵消）</li><li>既能传模拟信号（电话线），又能传数字信号（以太网）；</li><li>拧得越紧，辐射强度越小，抗干扰能力越强；</li><li>UTP(Unshielded TP) and STP(Shielded TP)；（有屏蔽的双绞线多了一个Metal Shield，能减少向外辐射，减少衰减，增强抗干扰能力）</li><li>Catogory（越大带宽也高）；</li></ul><h3 id="Coaxial-Cable同轴电缆">Coaxial Cable同轴电缆</h3><ul><li>better shielding and greater bandwidth；（带宽大于双绞线）</li><li>粗缆和细缆<ul><li>50-ohm cable：基带同轴（电话交换机，早期用在以太网上）；</li><li>70-ohm cable：宽带同轴（适合传输模拟信号，比如电视网）；</li></ul></li><li>抗干扰能力也比较强；</li></ul><h3 id="Fiber-Optic光纤">Fiber Optic光纤</h3><ul><li>利用了光的全反射；</li><li>一般是好几根固定在一起作为一根；</li><li>我们称一种入射角度为一个模：<ul><li><em><strong>Multimode多模光纤</strong></em>：有多种入射角；</li><li><em><strong>Single-mode单模光纤</strong></em>：只有一种入射角；（光线相互之间干扰很小，<em><strong>带宽更宽</strong></em>）</li></ul></li><li>光纤的工作窗口：对应波长/频率的光波适合在这个光纤内传输，损失最小；</li><li>光纤环网：<img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/1.png" alt=""><ul><li>Opitcal Receiver用于将光信号转化为电信号（光敏电阻）；</li><li>Signal Regenerator用于对电信号进行放大和整形，此时可以选择发送到计算机或者继续传输；</li><li>Optical Transmitter用于将电信号重新转化为光信号（发光二极管）；</li></ul></li><li>优点：<ul><li>带宽大；</li><li>抗干扰能力好，安全；</li><li>轻便（相较于铜导线）；</li></ul></li></ul><h2 id="无线传输介质">无线传输介质</h2><p>总体来说（相较于有线传输）：</p><ul><li>误码率更高；</li><li>传播时延更高；</li><li>传输损耗更大；</li><li>安全性也更弱；</li><li>抗干扰能力更差；</li><li>带宽不可再生，可用的是有限的；</li><li>同一个空间内，同一频率会相互干扰；</li></ul><h3 id="Radio无线电波">Radio无线电波</h3><h4 id="传播方式">传播方式</h4><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/2.png" alt=""></p><ul><li>较低的频段，波长较大，可以沿地球表面传播；</li><li>高频，波长较小，沿直线传播，在中继站之间传播；</li><li>超高频以上，需要用在视距范围内的中继站传播；</li></ul><h3 id="Microwave微波">Microwave微波</h3><p>直线传输，适合长距离通信，当需要地面中继站（<em><strong>典型设备：中继器Repeater，进行再生信号，即信号的整形和放大</strong></em>）才能进行远距离；</p><h3 id="红外线和可见光通信">红外线和可见光通信</h3><p>略</p><h2 id="卫星通信">卫星通信</h2><p>通信卫星相当于微波通信中中继站Repeater的作用，只不过在大气层以外。</p><h3 id="典型设备：Transponder转发器">典型设备：Transponder转发器</h3><ul><li>监听由地面天线发出的上行电波；</li><li>将收到的电波进行Amplify(放大)；</li><li>将电波以<em><strong>另一种频率</strong></em>的下行电波<em><strong>广播</strong></em>发送给范围内的地面天线；</li></ul><h3 id="通信卫星的分类">通信卫星的分类</h3><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/3.png" alt=""></p><ul><li>GEO：地球同步轨道；</li><li>MEO：中地轨道；</li><li>LEO：近地轨道；</li></ul><blockquote><p>轨道高度越高，需要覆盖全球的卫星数量越小，但时延越高；</p></blockquote><h3 id="卫星通信的特点">卫星通信的特点</h3><ul><li>Long propagation delay，时延长；</li><li>broadcast media，先天的广播介质；</li><li>传输成本和传输距离无关；</li><li>不受地面环境影响；</li></ul><h1>数字通信系统</h1><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/4.png" alt=""></p><h2 id="典型设备">典型设备</h2><ul><li>Modem调制/解调器：将信号调整为适合信道传输的频率范围（baseband signal基带信号 $\rightarrow$ passband signal带通信号）；<ul><li>基带信号：$0$ ~ $f_{max}$ Hz；</li><li>带通信号：$f_{1}$ ~ $f_{2}$ Hz，$f_1 &gt; 0$；</li></ul></li><li>CodeC编解码器；</li><li>Multiplxer多路复用器：将多路信号复用在一条传输介质上，提高信道利用率；</li><li>信道编码器：将01信号转化为抗干扰能力更强的方波；</li></ul><h2 id="Line-Code线路编码">Line Code线路编码</h2><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/5.png" alt=""></p><ul><li>NRZ不归零编码：抗干扰能力不强；</li><li>Manchester编码：用“low to high”表示0，“high to low”表示1；指定电平的变化必须发生在时钟周期的中间；这样同时传输来信号和时钟，有着<em><strong>自同步</strong></em>功能；</li><li>AMI编码：1用“+1”“-1”间隔表示；</li></ul><h3 id="评价指标">评价指标</h3><ul><li>Clock Recovery时钟恢复：能在信号流中提取时钟频率；<img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/6.png" alt=""></li><li>Balanced Signals平衡信号：消除直流分量；Manchester编码和AMI编码都可以；</li><li>Bandwidth Efficiency信道效率：Manchester编码只有50%；</li></ul><h2 id="调制技术Modulation">调制技术Modulation</h2><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/7.png" alt=""></p><p>从上到下依次是：</p><ul><li>原始二进制信号；</li><li>2ASK：振幅调制（幅移键控）；</li><li>2FSK：频率调制；</li><li>2PSK：相位调制；</li></ul><h3 id="多级调制技术">多级调制技术</h3><p>同时利用不同的振幅以及相位来表示传输的比特位，从而提高每个信号单元携带的比特数量；</p><ul><li>QPSK：正交相移键控；</li><li>QASK：正交幅度调制；<br><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/8.png" alt=""></li></ul><p>其中：</p><ul><li>振幅：点与原点的距离；</li><li>相位：点与原点的连线和x轴的夹角；</li></ul><h2 id="模拟信号数字化PCM">模拟信号数字化PCM</h2><p><em><strong>PCM：Pluse Coding Modulation（脉冲编码调制）；</strong></em><br>分为以下三个阶段：</p><ul><li>Sampling采样：根据Nyquist Theory，<em><strong>数字信号的采样率应至少是信号最高频率的2倍</strong></em>。</li><li>Quantizing量化；</li><li>Encoding编码；<br>典型设备：CodeC编码解码器；</li></ul><h2 id="复用Multiplexing">复用Multiplexing</h2><ul><li>TDM时分复用；</li><li>FDM频分复用；</li><li>WDM波分复用；</li><li>CDM码分复用；</li></ul><h3 id="关键设备Multiplexer">关键设备Multiplexer</h3><p>例如，<em><strong>Digital Subscriber Line Access Multiplex(DSLAM，数字用户线接入复用器)</strong></em>；</p><h3 id="Frequency-Division-Multiplexing-频分复用">Frequency Division Multiplexing 频分复用</h3><p>将多路信号通过傅立叶变换分成频率范围各不相同的信号合成一路进行传输，再通过带通滤波器实现分离；<br>注意信号之间一般存在<em><strong>保护频带</strong></em>；</p><h3 id="Time-Division-Multiplexing-时分复用">Time Division Multiplexing 时分复用</h3><p>将每路信号在时间上分为多个<em><strong>timeslot(时隙)</strong></em>，信号被分到不同时间片进行发送</p><h4 id="Synchronous-TDM同步时分复用">Synchronous TDM同步时分复用</h4><p>每一个<em><strong>发送帧Frame</strong></em>都为每路信号保留发送空间，缺点是对于数字信号的传播，一般不连续，易造成资源浪费；在电话网络中应用较广；</p><h4 id="Statistical-TDM统计-异步时分复用">Statistical TDM统计/异步时分复用</h4><p>只发送需要发送的数据，在需要时分复用时才进行复用，但需要加上地址头Address作为用户标识；</p><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/13.png" alt=""></p><ul><li>其中，T1为24路，E1位30/32路(其中2路为控制信号)；</li></ul><h3 id="Code-Division-Multiplexing码分复用">Code Division Multiplexing码分复用</h3><p>不同用户可以在任意时间使用整个信号发送信息，不同用户发送的信息通过编码理论进行区分；<br>比如，在班级里，同学间分为不同小组进行讨论，但不同组用不同语言交流，并且同时大声说话，我需要接受某信息就需要知道该信息的组所用的语言，屏蔽其他组。但如果组越多，噪声越大，就越不容易接受。</p><h3 id="Wavelength-Division-Multiplexing波分复用">Wavelength Division Multiplexing波分复用</h3><p>波长和频率成反比，所以波分复用和频分复用类似，一般用在<em><strong>Fiber Optic光纤通信</strong></em>中。<br><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/14.png" alt=""></p><blockquote><p>Line Code：线路编码，用于基带传输Baseband Transmission；<br>Modulation：调制，用于带通传输；</p></blockquote><h2 id="Example-电话网">Example: 电话网</h2><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/9.png" alt=""></p><ol><li>首先，语音信号通过<em><strong>Local Loop(本地环路)</strong></em>，到达<em><strong>CodeC(编解码器)</strong></em>，将模拟信号转化为数字信号；</li><li>语音信号的带宽一般是$4$kHz左右，根据Nyquist Theorm，复原该语音信号需要每秒$8$k的采样率，即每$125$usec采样一次，而$1 sample = 8bits$(非线性编码)，所以比特率为$8k \times 8bits = 64kbps$；</li><li>CodeC将数字信号通过<em><strong>Trunk(中继线)</strong></em>，继续发往路由器/交换机，其中用到了时分复用；</li></ol><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/10.png" alt=""></p><ol><li>电脑通过电话线接入网络，由于电脑发送的是01比特串，所以先通过<em><strong>Modem(调制解调器，使用QAM，正交幅度调制)</strong></em>，将数字信号转化为模拟信号；</li><li>之后的步骤类似电话网络；</li></ol><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/11.png" alt=""><br>其中，$-1$bit是因为1位用于检错；</p><h3 id="DSL-Digital-Subscriber-Lines数字用户线">DSL: Digital Subscriber Lines数字用户线</h3><ul><li>DSL在短距离内可以提供较大的带宽；</li><li>随着距离增加，带宽急剧下降；</li></ul><h4 id="ADSL-Asymmetric-DSL非对称数字用户线">ADSL: Asymmetric DSL非对称数字用户线</h4><p>该服务将本地贿赂上的$1.1$MHz频谱分为$256$条独立的信道，每条信道的带宽约为$4.3$KHz：</p><ul><li>Channel 0用于<em><strong>电话服务(POTS，Plain Old Telephone Service)</strong></em>；</li><li>Channel 1～4用于保护隔离；</li><li>剩下的250条信道被分为上行流Upstream和下行流Downstream，其中有2条用于控制，即实际用于传输用户数据的是248条；</li></ul><h4 id="技术：DMT-Discrete-Multitone-Modulation，离散多音调制">技术：DMT(Discrete Multitone Modulation，离散多音调制)</h4><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/12.png" alt=""></p><h3 id="Switching-交换">Switching 交换</h3><h4 id="Circuit-Switching电路交换">Circuit Switching电路交换</h4><ul><li>面向连接：<ul><li>circuit establishment</li><li>data transfer</li><li>circuit</li></ul></li><li>需要提前分配路径和资源；</li><li>优点：<ul><li>Small Delay；</li><li>Good Quality；</li><li>容易控制；</li></ul></li><li>缺点：<ul><li>在建立连接的过程中需要花费较长时间；</li><li>带宽固定；</li><li>如果双方不发送数据，会造成信道浪费；</li></ul></li><li>例子：电话网</li></ul><h4 id="Message-Switching报文交换">Message Switching报文交换</h4><ul><li>在每个节点，收到的整个消息都被存储到节点内再进行转发；（Store-and-Forward）<img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/15.png" alt=""></li><li>缺点：需要开较大的缓存空间，不适合较大的消息；</li><li>例子：邮局；</li></ul><h4 id="Packet-Switching分组交换">Packet Switching分组交换</h4><ul><li>数据在发送前被分为不同的<em><strong>组Packet</strong></em>，再进行传输，每个包独立进行<em><strong>路由选择（显然，每个包都需要携带相应的路由信息）</strong></em>，每个包到达节点后进行<em><strong>存储-转发</strong></em>，过程中资源是<em><strong>动态分配</strong></em>的；</li><li>与电路交换的对比：<img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/16.png" alt=""></li></ul><h1>物理层协议</h1><ul><li>Mechanical Features机械特性：接口形状和尺寸、引线数目和排列、固定和锁定装置等；</li><li>Electrical Features电气特性：电缆线上的电压范围；</li><li>Functional Features功能特性：某条线上出现的某一电平的电压保持何种意义；</li><li>Procedure Features过程特性：对于不同功能的各种可能事件的出现顺序；</li></ul><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');// 可以在这里添加额外的回调函数});</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Bandwidth信道带宽&lt;/strong&gt;：$f_{max} - f_{min}$，单位Hz；
&lt;ul&gt;
&lt;li&gt;Analog Bandwidth，模拟信号用Hz表示；&lt;/li&gt;
&lt;li&gt;Digital Bandwi</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机网络" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>形式语言与自动机学习笔记(1)</title>
    <link href="https://blog.yokumi.cn/2025/03/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/"/>
    <id>https://blog.yokumi.cn/2025/03/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</id>
    <published>2025-03-05T13:20:00.000Z</published>
    <updated>2025-05-11T15:52:11.257Z</updated>
    
    <content type="html"><![CDATA[<h1>一、概述</h1><ul><li><strong>形式语言</strong>：形式化描述的字母表上的字符串构成的集合；</li><li><strong>自动机</strong>：具有离散输入输出的数学模型；</li></ul><blockquote><p>形式语言与自动机的关系：<br>形式语言——字符串，自动机——字符串的识别系统<img src="/2025/03/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/1.png" alt=""></p></blockquote><ul><li><strong>文法</strong>：定义语言的数学模型；</li><li><strong>元语言</strong>：描述语言的语言；</li></ul><h1>二、Chomsky文法体系</h1><h2 id="概念简述">概念简述</h2><p>文法$G$是一个四元组$G=(N，T，P，S)$，其中：</p><ul><li>$N$：非终结符的有限集合；</li><li>$T$：终结符的有限集合，且$N\cap T = \phi$；</li><li>$P$：形式为$\alpha \rightarrow \beta$的生成式的有限集合，且$\alpha \in (N \cup T)^* N^+ (N \cup T), \beta \in(N\cup T)^*$，即$\alpha$中至少含有一个非终结符；</li><li>$S$：起始符，且$S\in N$；</li></ul><p>应用生成式就是将非终结符不断替换为终结符+非终结符的符号串，再替换得到的新的字符串中的非终结符，最终得到只含有终结符的符号串；<br>我们将中间过程的符号串称为句型，最终推导出的只含有终结符的符号串称为句子，显然，<em><strong>句型包含句子</strong></em>。</p><p>我们将文法产生的语言记为$L(G)$：<br>$$<br>L(G) = { \omega \mid \omega \in T^* \text{ 且 } S \Rightarrow^* \omega }<br>$$<br>即必须是由终结符组成，并且由起始串$S$推导得到；</p><p>关于Chomsky文法体系，对生成式做出一些限制，分为以下4类：</p><h2 id="0型文法">0型文法</h2><ul><li>无限制</li><li>对应递归可枚举语言</li><li>对应图灵机</li></ul><h2 id="1型文法">1型文法</h2><ul><li>上下文有关文法</li><li>对应上下文有关语言</li><li>对应线性有界自动机（不考虑空串）</li></ul><p>1型文法对生成式做出了如下限制：$\alpha \rightarrow \beta$，其中$|\alpha| \leq |\beta|$，且$\alpha, \beta \in (N \cup T)^*$，且$\alpha$至少含有一个非终结符号；<br>该限制的意义是保证了推到过程中字符串长度单调不减；</p><h2 id="2型文法">2型文法</h2><ul><li>上下文无关文法</li><li>对应上下文无关语言</li><li>对应下推自动机</li></ul><p>2型文法对生成式做出了如下限制：$A \rightarrow \alpha$，其中$A$是一个非终结符，$\alpha$是由非终结符和终结符组成的任意字符串（可以是空串）；<br>该限制的意义是每次替换单独一个非终结符，支持递归结构的解析；</p><h2 id="3型文法">3型文法</h2><ul><li>正则文法（分为左线性文法和右线性文法）</li><li>对应正则语言</li><li>对应优先自动机</li></ul><p>左线性文法对生成式做出了如下限制：$A \rightarrow B\omega$或$A \rightarrow \omega$，其中$A,B$为非终结符，$\omega$为终结符；<br>右线性文法对生成式做出了如下限制：$A \rightarrow \omega B$或$A \rightarrow \omega$，其中$A,B$为非终结符，$\omega$为终结符；<br>该限制的意义是，生成式只能在字符串的左边或者右边扩展非终结符，限制了语言的复杂性和递归性；</p><h1>有限自动机</h1><h2 id="DFA">DFA</h2><p>DFA是一个五元组$M = (Q,T,\delta. q_0, F)$；</p><ul><li>$Q$：有限状态集合；</li><li>$T$：有限的输入字母表；</li><li>$\delta$：转移函数：$Q \times T \rightarrow Q$；</li><li>$q_0$：起始状态；</li><li>$F$：终止状态的集合；</li></ul><p><strong>$\delta’$函数</strong>：接受一个字符串输入的状态转移函数：<br>$$<br>\delta’:Q\times T^* \rightarrow Q<br>$$<br>对任何$q \in Q$，作出如下定义：</p><ul><li>$\delta’(q, \varepsilon) = q$；</li><li>若$\omega$为字符串，$a$为一个字符，则$\delta’(q, a\omega) = \delta(\delta’(q, \omega), a)$；</li></ul><p><strong>被DFA接受的字符串</strong>：输入结束后使DFA达到终止状态；</p><p><strong>格局</strong>：当前状态$q$，待输入字符串$\omega$，用$(q, \omega)$表示当前瞬时状态；</p><h2 id="UFA-不确定的有限自动机">UFA 不确定的有限自动机</h2><p>在某个状态，对应某个输入，有多个转移，能到达多个状态；UFA和DFA的定义上的区别只有$\delta$函数：<br>$$<br>\delta：Q\times T\rightarrow 2^Q<br>$$<br>如果接受一个字符串后UFA能够到达的状态集合包含一个及以上F中的元素，则称为该字符串能被UFA接受；</p><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');// 可以在这里添加额外的回调函数});</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;形式语言&lt;/strong&gt;：形式化描述的字母表上的字符串构成的集合；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动机&lt;/strong&gt;：具有离散输入输出的数学模型；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;形式</summary>
      
    
    
    
    <category term="专业学习" scheme="https://blog.yokumi.cn/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="计算机基础" scheme="https://blog.yokumi.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计(Java)</title>
    <link href="https://blog.yokumi.cn/2025/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(Java)/"/>
    <id>https://blog.yokumi.cn/2025/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(Java)/</id>
    <published>2025-03-01T03:08:00.000Z</published>
    <updated>2025-05-10T12:17:54.554Z</updated>
    
    <content type="html"><![CDATA[<h1>面向对象的三大特性</h1><ul><li>封装、继承、多态<ul><li>封装：对抽象的事物抽象成一个对象，并对其对象的属性私有化，同时能提供一些能被外部访问属性的方法。<ul><li>对象：属性+方法；<ul><li>成员变量：生存期是对象的生存期，作用域在类的内部；<ul><li>访问属性：private vs. public vs. friendly<ul><li>private：针对类而不是针对对象的，即同一个类的不同对象的私有属性之间可以相互访问；</li><li>friendly：既没有public也没有private修饰，可以在同一个package内进行访问；</li><li>public：一个编译单元（.java文件）只能有一个public类，并且名称要求相同；</li><li>protected：自己、同一个package内、子类可访问；</li></ul></li></ul></li><li>本地变量：生存期和作用域都是函数内部；</li><li>对象初始化：<ul><li>构造函数（无返回类型，接收无参和有参两种构造方式，即多个同名但参数表不同的函数构成了函数<em><strong>重载</strong></em>）；</li><li>初始化顺序：定义初始化$\rightarrow$构造器；如果继承了父类，先进行父类初始化，并需要确保父类的属性得到了正确的初始化；</li></ul></li></ul></li></ul></li><li>继承：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；<ul><li>Cpp和Java的一个重要区别是，Cpp支持多继承，并且有指针的概念；Java是单继承，但可以用接口来实现多继承；</li></ul></li><li>多态：<ul><li>多态变量：对象变量能对应多种类型，具体可分为静态类型和动态类型；</li><li>造型Cast：<ul><li>造型并不是类型转换；</li><li>向上造型Upcasting：子类对象可以当作父类对象来使用，即子类对象可以用父类对象来赋值；</li></ul></li><li>函数调用的绑定：通过对象类型去调用函数时，调用哪个函数称为绑定；<ul><li>静态绑定：根据变量的声明类型决定；在编译期间确定，被称为静态分派，比如函数的重载；</li><li>动态绑定：根据变量的动态类型决定；在程序运行时确定，被称为动态分派，比如方法的重写（同名同参数表的子类方法会覆盖(override)父类方法）；</li></ul></li><li>多态的底层实现是动态绑定，实际就是方法调用动态分派的过程。如果子类方法覆盖了父类方法，在多态调用时，会先确定实际类型为子类，然后先搜索子类中的该方法。</li></ul></li></ul></li></ul><h1>static vs. final</h1><ul><li>Static：<ul><li>static修饰属性：类变量，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用；</li><li>static修饰方法：类函数，随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用 this；</li></ul></li><li>final：<ul><li>final修饰变量：<ul><li>如果修饰基本数据类型，那相当于常量，不能改变值；</li><li>如果修饰引用数据类型的变量（即对象的引用），那么不能改变对象的引用（即存储地址），即初始化后不能再让其指向一个新的对象；</li></ul></li><li>final修饰方法：相当于禁用了重写，继承类不能修改该方法的含义；</li><li>final修饰类：<ul><li>该类不能被继承；</li><li>final类中的所有成员⽅法都会被隐式地指定为final⽅法；</li><li>该类的成员变量不受影响；</li><li>该类可以有内部类；</li><li>当然，也可以通过私有化构造方法来禁止该类被继承（单例模式）；</li></ul></li></ul></li></ul><h1>抽象类 vs. 接口Interface</h1><ul><li>抽象类：包含抽象方法的类，即使用abstract修饰的类；有抽象函数的类一定是抽象类；<ul><li>抽象类不能用于实例化对象；</li><li>抽象类只能被继承；</li></ul></li><li>接口：接口是一个抽象类型，是抽象方法的集合；<ul><li>接口支持多继承；</li><li>接口中定义的方法，默认是 public abstract 修饰的抽象方法；</li></ul></li><li>相同点：<ul><li>两者均不能被实例化；</li><li>子类/实现类必须重写抽象类/接口中定义的抽象方法；</li></ul></li><li>不同点：<ul><li>抽象类有构造方法，接口没有构造方法；</li><li>抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8 之后可以）；</li><li>抽象类只能单继承，接口可以多继承；</li><li>抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量；</li></ul></li></ul>]]></content>
    
    
    <summary type="html">面向对象的程序设计</summary>
    
    
    
    <category term="就业八股" scheme="https://blog.yokumi.cn/categories/%E5%B0%B1%E4%B8%9A%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="面向对象" scheme="https://blog.yokumi.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>一些有关Large Language Model(LLM)的学习记录</title>
    <link href="https://blog.yokumi.cn/2025/02/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Large%20Language%20Model(LLM)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.yokumi.cn/2025/02/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Large%20Language%20Model(LLM)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2025-02-27T13:33:00.000Z</published>
    <updated>2025-05-10T12:17:54.194Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：</p><blockquote><p>由于本人之前对于大模型的学习学的急功近利，偏向于应用（<s>乱用bushi</s>），回头看来对LLM本身过于肤浅，所以浅开一个坑，用于补齐原理性的知识；</p><p><s>BUPT课设太TM多了</s>。不定期随便填坑。</p></blockquote><p><strong>参考资料</strong>：</p><blockquote><p>【1】［美] 塞巴斯蒂安·拉施卡 著，叶文滔 译. 大模型技术30讲[M]. 北京：人民邮电出版社，2024.<br>【2】Raschka S. <em>Build a Large Language Model (From Scratch)</em>[M]. Shelter Island, NY: Manning, 2024.</p></blockquote><h1>一、Understanding LLM</h1><h2 id="1-1-What-is-LLM">1.1 What is LLM?</h2><p><strong>定义 1.1</strong>：<strong>Large Language Model</strong></p><blockquote><p>An LLM is a neural network designed to understand, generate, and respond to human-like text;</p></blockquote><ul><li>“Large” means, datasets on which it’s trained and parameters(the model’s size);<ul><li><strong>parameters</strong> are the adjustable weights in the network that are optimized during training to predict the next word in a sequence;</li></ul></li><li>LLM‘s architecture – <strong>Transformer</strong>, which enables them to pay selective attention to different parts of the input when making predictions;</li><li>LLM is also called <strong>Generative AI</strong>(生成式AI);</li></ul><p>至于其中使用到的两种手段 —— machine learning and deep learning，将在之后具体阐释。（后者是前者的一个子集，主要区别是是否需要手动提取特征。然而机器学习的经典算法已经快被淘汰了，令人感慨）；</p><h2 id="1-2-Application-of-LLM">1.2 Application of LLM</h2><p>无需多言，用过都说好；</p><h2 id="1-3-Stages-of-building-and-using-LLMs">1.3 Stages of building and using LLMs</h2><ul><li><strong>Pretraining 预训练</strong>：在多领域的庞大数据集下训练；</li><li><strong>Finetuning 微调</strong>：针对特定任务通过特定领域的标注数据集在Pretrained LLM的基础上进行训练；<ul><li><strong>Instruction Finetuning 指令微调</strong>：简单来说，就是<em><strong>标注数据 = 指令 + 正确答案</strong></em>；</li><li><strong>Classification Finetuning 分类微调</strong>：<em><strong>标注数据 = 文本 + 分类标签</strong></em>；</li></ul></li></ul><p>两者的具体区别如下图所示：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171352752.png" alt=""></p><h2 id="1-4-Introducing-the-transformer-architecture">1.4 Introducing the transformer architecture</h2><p>Transformer 的两个重要组件是 <strong>Encoder 编码器</strong> 和 <strong>Decoder 解码器</strong>，编码器将输入文本编码为向量，而解码器解码向量并生成相应文本。区别于传统的全连接型或卷积型，编码器和解码器之间采用 <strong>Self-attention mechanism 自注意力机制</strong> 连接；</p><p>在 Transformer模型的基础上，又衍生出了两种不同架构：<strong>Bert(Bidirectional encoder representations from transformers)</strong> 和 <strong>GPT(Generative pretrained transformers)</strong>；</p><p>从全拼也可以看出，这两种模型分别用于不同的任务，Bert模型主要用于 predict masked or hidden words 预测掩码值，适用于文本分类任务，以下是它和 GPT-Model 区别的图示：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171450135.png" alt=""></p><p>GPT-Model 又分为：</p><ul><li><strong>Zero-shot 零样本学习</strong>：能够处理从未在训练数据中见过的任务或类别，即模型在面对新任务时不需要额外的训练和微调也能做出合理的决策；</li><li><strong>Few-shot 少样本学习</strong>：模型在提供极少量样本或示例时，就能够理解并执行特定任务的能力；泛化能力强；</li></ul><p>下图具体说明了两者的区别：<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171510313.png" alt=""></p><p>GPT-Model采用 <strong>自监督(Self-supervised learning)</strong> 的方式进行学习，即自标注形式(Self-labeling)。我们可以将句子或者文档中的下一个单词作为模型应该预测的标签进行训练。</p><blockquote><p><strong>注</strong>：模型能够执行未明确训练的任务的能力称为 <strong>Emergent Ability 涌现</strong>，模型并未针对专门任务进行训练，但是在大量数据集的训练下突然表现出未预料到的新行为或新能力。增加参数量往往会促进涌现行为的出现。</p></blockquote><h2 id="1-5-Building-a-large-language-model">1.5 Building a large language model</h2><p><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504172235133.png" alt=""></p><h1>零、</h1>]]></content>
    
    
    <summary type="html">一些有关Large Language Model(LLM)的学习记录</summary>
    
    
    
    <category term="科研学习" scheme="https://blog.yokumi.cn/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="人工智能" scheme="https://blog.yokumi.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="LLM" scheme="https://blog.yokumi.cn/tags/LLM/"/>
    
    <category term="Python" scheme="https://blog.yokumi.cn/tags/Python/"/>
    
  </entry>
  
</feed>
