<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hexo博客的一些进阶配置</title>
    <link href="/2025/05/11/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/05/11/Hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>关于 Hexo 的基础配置，已经在 <a href="https://blog.yokumi.cn/2025/01/17/%E4%B8%80%E6%96%87%E7%99%BD%E5%AB%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8+%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83+%E5%8D%9A%E5%AE%A2%E7%AD%89%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/">一文白嫖阿里云服务器+配置基本开发环境+博客等服务部署</a>文章中介绍。</p></blockquote><h1>一、添加 RSS 外链</h1><ol><li>安装 <code>hexo-generator-feed</code> 插件；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-feed --save<br></code></pre></td></tr></table></figure><ol start="2"><li>修改 <code>_config.yml</code> 配置文件；</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 订阅 RSS</span><br><span class="hljs-symbol">feed:</span><br><span class="hljs-symbol">  type:</span> atom<br><span class="hljs-symbol">  path:</span> atom.xml<br><span class="hljs-symbol">  limit:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">  hub:</span><br><span class="hljs-symbol">  content:</span><br><span class="hljs-symbol">  content_limit:</span> false<br><span class="hljs-symbol">  content_limit_delim:</span> <span class="hljs-string">&#x27; &#x27;</span><br><span class="hljs-symbol">  order_by:</span> -date<br></code></pre></td></tr></table></figure><p>其中，<code>limit</code> 表示限制文章数量，可根据需要自行配置；</p><ol start="3"><li>重新生成并部署；</li><li>通过 <code>http://你的域名/atom.xml</code> 就可以访问你的 RSS 了；</li><li>在你需要的地方添加即可；</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网学习笔记(5)：网络层</title>
    <link href="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1>网络层的位置和功能</h1><p><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/1.png" alt=""></p><blockquote><p>网络层是处理<strong>端到端(end-to-end)传输</strong>的最底层！</p></blockquote><p><strong>Hop(跳)</strong>：</p><blockquote><p>主机之间通信，经过一个路由器就是一跳。</p></blockquote><p><strong>网络层的主要功能</strong>：</p><ol><li><strong>Internetworking 网络互联</strong>：将异构的网络实现互联，向上(传输层)提供统一的接口；</li><li><strong>Addressing 编址</strong>：保证设备之间接口地址（IP Address）唯一且格式统一；</li><li><strong>Packeting 组包</strong>：将上层需要传输的数据封装为包(Packet)；</li><li><strong>Routing 路由</strong>：选路，决定数据包的下一条，通过路由器(Router)实现；</li><li><strong>Fragmenting 分段/分片</strong>：由于不同数据链路层支持的最大数据长度不同，需要适应不同的数据链路层，对数据包进行分段；</li></ol><h1>网络层提供的服务</h1><p>网络层需要向上(传输层)提供服务，要求：</p><ul><li>路由技术独立：即传输层不需要知道路由器的技术，网络层提供的接口是透明且统一的；</li><li>传输层对路由完全透明：不需要看到路由技术和数据包是如何路由的；</li><li>传输层获得的网络地址的格式是统一的；</li></ul><p>又分为：</p><ul><li><strong>Virtual Circuit 虚电路</strong>：Connection-Oriented，面向连接的；</li><li><strong>Datagram 数据报</strong>：Connectionless，无连接的；</li></ul><p>两者都属于分组交换 <strong>Packet Switching</strong>，区别是：</p><ul><li><strong>Datagram 数据报</strong>：<ul><li>每一个包需要携带目的地的完整地址；</li><li>路由器通过路由表转发包，路由表是动态更新的；</li><li>包到达目的地可能是乱序的，即每个包选择的路径可能不相同；</li></ul></li><li><strong>Virtual Circuit 虚电路</strong>：<ul><li>在数据包进行传输之前，网络先建立了一条端到端的虚拟电路；</li><li>传输过程中，数据包携带<strong>虚拟电路地址 VCI(Virtual Circuit Identifier)</strong>，作为地址标识，这比标准的地址短的多；</li><li>VC建立后，所有包需要遵循VC的路径进行路由，所以包到达目的地是一定是按序的；</li></ul></li></ul><h1>路由</h1><p>路由表 = 路由算法 + 路由协议；根据路由算法和路由协议产生和更新路由表(Routing Tables)，根据路由表进行选路，转发数据包</p><h2 id="1-路由算法">1. 路由算法</h2><h3 id="1-1-设计路由算法的原则">1.1 设计路由算法的原则</h3><ul><li>正确性；</li><li>简单性；</li><li>健壮性；</li><li>可快速收敛到稳定状态；</li><li>公平性；</li><li>最优策略：最小化转发延时、最大化网络吞吐量；</li></ul><h3 id="1-2-路由算法的分类">1.2 路由算法的分类</h3><ul><li><strong>静态路由 Nonadaptive/Static Routing</strong>：<ul><li>提前计算出路由表；</li><li>往往不会改变，需要手动维护；</li><li>不能根据网络实时流量和拓扑结构的变化动态调整；</li></ul></li><li><strong>动态/自适应路由 Adaptive Routing</strong>：<ul><li>能适应<strong>网络拓扑 Topology</strong> 和<strong>业务量 Traffic</strong> 的变化；</li></ul></li></ul><h3 id="1-3-一些概念">1.3 一些概念</h3><ul><li><strong>最优化原则</strong>：最优路径上的任意两点间的路径也是最优的；</li><li><strong>宿树/汇集树 Sink Tree</strong>：以目的地节点为根，由所有源节点到目的节点的最优路径路由构成；<ul><li>由于是树，显然是无环的，不存在无限的跳数；</li></ul></li></ul><h3 id="1-4-路由思想和策略">1.4 路由思想和策略</h3><blockquote><p>以下阐述的只是一些路由思想，或者说寻找最优路径的思想，但在实际环境中并不能有效工作；</p></blockquote><ul><li>最短路算法：Dijkstra 算法<ol><li>建立有向加权图；<ul><li>节点为路由器，注意没有主机；</li><li>边为通信线路；</li><li>边权可以为跳数、传输时延、物理距离等等；</li></ul></li><li>通过 Dijkstra 算法寻找最短路；</li></ol></li><li>一些选路策略：<ul><li>固定查表选路 Fixed Routing；</li><li><strong>泛洪 Flooding</strong>：<ul><li>其基本过程如下：<ul><li>将数据包转发给每个邻居；</li><li>邻居再将收到的数据包转发给除了来路之外的所有链路(防止数据包原路返回)；</li></ul></li><li>优点：<ul><li>泛洪显然不需要路由表，简单粗暴；</li><li>不需要网络信息；</li><li>具有鲁棒性，所有路径都会被尝试，所有节点都会被到达，所以至少有一个数据包会按照最短的路由达到目的地；</li><li>在建立路由表时可能较为有用；</li></ul></li><li>缺点：<ul><li>产生大量重复的数据包；</li><li>最终可能有一个或多个重复的数据包到达目的节点；</li></ul></li><li>限制泛滥手段：<ul><li>跳计数器 Hop Counter：<ul><li>每个数据包携带一个 Hop Counter，一般由发送方初始化为源地址到目的地址的距离或子网的网络半径；</li><li>每经过一跳，Hop Counter 减 1；</li><li>当 Hop Counter 为 0 时，丢弃该包；</li></ul></li><li>序列号 Sequence Number：<ul><li>发送方在每个包前添加序列号；</li><li>每个路由器会记录每个发送方目前的最大序列表，表示该序列号已经通过该路由，从而避免重复转发；</li></ul></li></ul></li></ul></li><li>随机选路；</li><li>自适应选路；</li></ul></li></ul><h3 id="1-5-DVR-距离矢量选路-Distance-Vector-Routing">1.5 DVR(距离矢量选路 Distance Vector Routing)</h3><h4 id="1-5-1-执行步骤">1.5.1 执行步骤</h4><ul><li>每个路由维持一个路由表，包括：<ul><li>到其他路由的最短距离；</li><li>到该路由使用的下一条的接口；</li></ul></li><li>每个路由会<strong>周期性</strong>（RIP：30s）地播报自己的路由表；</li><li>路由器会根据收到的邻居的路由表更新自己的路由表；</li><li>如果在一段时间内（RIP：180s）都没有收到某个路由器的路由表，则将该路由器从自己的路由表中删除（将距离设置为 $\infty$ ）；</li><li>当迭代至各个路由器的路由表均不发生变化后，则认为构建路由表结束；</li></ul><h4 id="1-5-2-特点">1.5.2 特点</h4><ol><li>邻接节点之间共享网络信息（路由表）；</li><li>只和初始邻接节点共享信息；</li><li>对所有接口广播信息；</li><li>周期性地广播；</li></ol><blockquote><p>用一句话概括，就是路由器<strong>周期性</strong>地向<strong>所有邻居</strong> <strong>广播</strong>整个<strong>路由表</strong>；</p></blockquote><h4 id="1-5-3-问题">1.5.3 问题</h4><ul><li>收敛速度较慢；</li><li>“好消息”迅速传遍整个网络，但对“坏消息”反应慢；（React rapidly to good news but leisurely to bad news）；即<strong>无穷计数 Count-to-Infinity</strong> 问题；</li><li>按传闻进行路由；（Rumor based routing）</li></ul><p><strong>无穷计数问题</strong>：<br><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/2.png" alt=""></p><p>大致的情况就是，节点A下线后，其余节点之间由于<strong>只知道距离，不知道路径</strong>，相互传递距离，反复更新距离（比如上图B没收到A但收到C的路由表，认为可以通过C到达A，于是更是路由表中到达A 的距离为 1 + 2 = 3，然后C又认为可以通过B到达A，如此循环更新，直到 $\infty$ ）；</p><blockquote><p>RIP协议中规定：权重(按跳数 Hop 计) &gt; 16，则认为是 $\infty$，即认为节点已经断开；</p></blockquote><blockquote><p><strong>注</strong>：上面提到的<strong>RIP</strong>，<s>并非R.I.P(Rest in Peace)</s>，全称是 Routing Information Protocol，属于一种路由协议，该协议使用 <strong>DVR</strong> 路由算法；</p></blockquote><h3 id="1-6-LSR-链路状态选路-Link-State-Routing">1.6 LSR(链路状态选路 Link State Routing)</h3><p>与DVR不同，DVR只会向领接路由器发送路由表，而 LSR 中，每个路由器向网络中的所有路由器共享信息；当路由器在本地构建已知的最优网络拓扑图后，发送一个<strong>链路状态包 Link-State Packet</strong> 给所有路由器（Flooding）；主要特点如下：</p><ol><li>共享整个网络的拓扑结构信息；</li><li>向网络中的所有路由器共享；</li><li>当网络拓扑结构改变时进行共享；</li></ol><h4 id="1-6-1-执行步骤">1.6.1 执行步骤</h4><p>对于每个路由器：</p><ol><li>从相邻的节点学习：<ol><li>本路由器广播(用于广播网络)/多播(用于点对点链路)一个 <strong>HELLO Packet</strong> 给邻接节点；</li><li>邻接节点收到 Hello 包后，回复一个包含自己名字(Route IDs，全网唯一)的包；</li></ol></li><li>测量通信线路开销：<ol><li>通过 <strong>Echo Packet</strong> 测量<strong>往返延时RTT</strong>；</li><li>或测量信道带宽等参数；</li></ol></li><li>构建 <strong>Link-State Packet</strong>：<ol><li><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/3.png" alt=""></li><li>Seq 字段表示序列编号，用于检查路由器收到的 LSP 是否是新的：<ol><li>如果是新序列编号的 LSP，则继续 Flooding；</li><li>如果是重复编号的或序列编号比已经收到的最大编号小的 LSP，则丢弃；</li></ol></li><li>Age 字段表示寿命，目的是为了避免 LSP 包无限泛滥，用于删除循环的路由；</li><li>当周期性地或监听到某些时间（比如某节点下线）等事件后构建 LSP 包；</li></ol></li><li>发送 <strong>Link-State Packet</strong>：<ol><li>由于需要实现可靠发送，所以采用前面提到的泛洪策略；</li><li>每个节点都有错误侦测机制，收到正确的数据包后会回复确认包；</li></ol></li><li>计算新的路由：<ol><li>本路由器收到所有的 LSP 包后，在本地运行 Dijkstra 算法，计算出通往每个目的节点的最短路径，并保存到路由表中；</li></ol></li></ol><h4 id="1-6-2-采用-LSR-的协议">1.6.2 采用 LSR 的协议</h4><ul><li>IS-IS 协议；</li><li>OSPF 协议；</li></ul><h3 id="1-7-层次-分级选路-Hierachical-Routing">1.7 层次/分级选路 Hierachical Routing</h3><p>将距离较近的比如同一单位内的路由划分为同一个<strong>域 Region</strong>，在整个网络内先按照域进行路由，进入域后，才选路至路由器；</p><h1>拥塞控制 Congestion Control</h1><h2 id="1-拥塞">1. 拥塞</h2><p>简单来说，拥塞 Congestion 就是网络的负载（同一时间发送到网络的数据包）超过了网络的可用资源（ CPU 处理速度，Buffer 缓冲队列长度，Bandwidth 链路带宽）；拥塞的症状（判断网络拥塞的指标）主要有：</p><ul><li>Long Delay；</li><li>Lost Packet 较高的丢包率；</li></ul><blockquote><p>上述症状并不能用来判断所有网络是否出现拥塞；无线网络产生丢包还要考虑误码等情况；</p></blockquote><p>注意与流量控制进行区分，流量控制只是两个站点（发送方和接收方）之间进行本地的协调；但是拥塞控制的范围是整个网络，是一个全局的问题；</p><h2 id="2-解决方式">2. 解决方式</h2><p>解决方式主要分为以下5种：</p><ol><li><strong>网络供给 Networking Provision</strong>；</li><li><strong>业务感知路由 Traffic aware-routing</strong>；</li><li><strong>准入控制 Admission control</strong>；</li><li><strong>流量限制 Traffic throttling</strong>；</li><li><strong>负载掉落 Load shedding</strong>；</li></ol><p>从产生拥塞的问题来看，前两种属于增加资源，后三种属于减少负债；<br>从作用的时间节点来看，前三种属于预防性控制，后两种属于反应性(Reactive)措施；</p><h4 id="2-1-流量调节-业务量减速-Traffic-throttling">2.1 流量调节/业务量减速 Traffic throttling</h4><p>这是基于反馈的解决方案，需要路由器能够感知拥塞；其基本步骤如下：</p><ol><li>拥塞检测：<ol><li>检测输出链路利用率：不够精确；</li><li>排队分组，即计算路由器中缓存的数据包数量；</li><li>计算分组丢包数量：但是太迟；</li><li>估计<strong>队列延时 queuing delay</strong>：通过EWMA(Exponentially Weighted Moving Average 指数加权移动平均)计算，即$d_{new} = \alpha d_{old} + (1-\alpha)s$，其中 $\alpha$ 是平滑因子（越大越平滑），$s$ 是最近采样的队列长度；</li></ol></li><li>拥塞通知：路由器需要通知数据包的发送方产生拥塞，让发送方降低业务量，主要有以下几种方式：<ol><li><strong>抑制分组 Choke Packet</strong>：路由器会发送一个 Choke Packet 给源节点（发送方），包含产生拥塞的目的节点信息；<ul><li>发送方发出的原始数据包会被标记，避免产生更多的 Choke Packet；</li><li>实际应用中效果并不好，因为网络已经拥塞了还需要产生 Choke Packet 并在路由间传输；</li></ul></li><li><strong>ECN(Explicit Congestion Notification 显式拥塞通知)</strong>：<ul><li>在 IP 和 TCP 协议中被使用；</li><li>在 IP Packet Header 中专门设置了 2bits 作为拥塞控制比特位；<ul><li>默认设置为 00；</li><li>在传输过程中，如果路由器检测到拥塞，将其设置为 11；</li><li>当该数据包发送到目的端节点后，目的端节点通过传输层（端到端通信）发送 Congestion Signal 给源端节点；</li></ul></li></ul></li></ol></li><li>业务量限制/调节：收到 Choke Packet 后，源节点会减少发送到某个目的地节点的业务量；<ul><li>减少业务量的方式包括但不限于减小发送窗口；</li></ul></li></ol><p>问题：当拥塞恢复时，路由器不会通知端节点恢复业务量？</p><blockquote><p>需要发送方自身进行推测和试探；比如 TCP 的 AIMD 机制（慢启动 + 加性增大），当拥塞时，TCP 会将发送窗口大小减半，然后逐步增加发送窗口大小，如果没有再次丢包，则继续慢慢加大发送窗口，如果丢包则再次降速。</p></blockquote><h4 id="2-2-Loading-Shedding-负载掉落">2.2 Loading Shedding 负载掉落</h4><p>关键问题是选择丢弃哪些数据，需要根据不同的应用场景进行选择。</p><p><strong>RED(Random Early Detection 随机早期检测)</strong>：</p><ul><li>路由器在路由完全失效前，就随机丢弃一部分包；</li><li>路由器并不会（显式）通知源节点，而是直接丢弃选中的包，但是源节点因为没有收到 ACK，检测到丢包后，会感知到拥塞的信息，并降低发送速度。</li><li>上述方法即属于<strong>隐式通知</strong>；</li></ul><p>举个例子：</p><ol><li>发送方此时发送了窗口内的 4、5、6 三个序号的数据帧；</li><li>路由器收到序号为 4 的数据帧时，接收并回复 ACK 4；</li><li>路由器收到序号为 5 的数据帧时，因为 RED 机制选中而被丢弃；</li><li>路由器收到序号为 6 的数据帧时，它选择缓存该帧，但由于它期望收到序号为 5 的帧，所以它会回复 ACK 4；</li><li>发送方收到了两个重复的 ACK 4，那么它会知道，后面发送的数据可能丢包了。</li></ol><blockquote><p><strong>注</strong>：TCP协议中，规定源节点如果收到 3 个及以上相同的 ACK，则认为发生拥塞；</p></blockquote><h1>服务质量 Quality of Service</h1><h2 id="1-QoS-参数">1. QoS 参数</h2><p>第一章 计算机网络概述中已经讲过，QoS主要包括以下4个参数：</p><ul><li>Reliability：可靠性，包括错误率和丢包率；</li><li>Delay；</li><li>Jitter；</li><li>Bandwidth；</li></ul><p>针对不同的应用场景，对参数的要求各不相同，需要提供个性化的服务。</p><h2 id="2-提升服务质量的技术">2. 提升服务质量的技术</h2><h3 id="2-1-流量整形-Traffic-shaping">2.1 流量整形 Traffic shaping</h3><p>实际网络中，往往会出现<strong>突发流量 Traffic Burst</strong>。平均流量基本固定，但是短时间内的瞬时流量可能非常大。而流量整形的作用就是去除或减少突发流量，使得实时传输速率接近平均速率，其主要涉及以下2个算法。</p><h4 id="漏桶-Leaky-Bucket">漏桶 Leaky Bucket</h4><p>事实上，桶就是一个 Buffer 队列，通过匀速从队列中拿出数据分组，实现匀速传输。如果桶满，则丢弃新来的数据或等待队列空。</p><h4 id="令牌桶-Token-Bucket">令牌桶 Token Bucket</h4><ul><li>路由器匀速产生令牌，如果令牌桶满则丢弃多余的令牌；</li><li>数据包到达路由器的队列后，需要消耗令牌进行发送，一个 Token 对应 一个 Packet；</li><li>令牌桶并没有数据队列的缓存限制，不会丢弃数据帧；</li><li>令牌桶能接受一定的突发流量，比如突发流量到达，可以一次性消耗所有令牌（跟令牌桶的大小有关）；</li></ul><p>如何计算经过令牌桶后的突发数据的持续时间？</p><p>令：</p><ul><li>突发数据的持续时间为 $S$ sec；</li><li>令牌桶的容量为 $B$ Bytes；</li><li>令牌的产生速率为 $R$ Bytes/s；</li><li>最大的输出速率为 $M$ Bytes/s；</li></ul><p>则有以下关系：</p><p>$$<br>B + R \times S = M \times S<br>$$</p><p>即：</p><p>$$<br>S = \frac{B}{M - R}<br>$$</p><h3 id="2-2-分组调度-Packet-Scheduling">2.2 分组调度 Packet Scheduling</h3><h4 id="先进先出队列-FIFO-Queuing">先进先出队列 FIFO Queuing</h4><ul><li>先到达的包先发出；</li><li>后到达的包可能会因为队列空间不够而被丢弃；</li></ul><h4 id="优先级队列-Priority-Queuing">优先级队列 Priority Queuing</h4><ul><li>到达的数据包先经过一个<strong>分类器 Classifier</strong>，按照优先级不同存入不同的队列；</li><li>同样，后到达的包如果对应的优先级队列已满，同样丢弃；</li><li>如果空闲，那么高优先级队列中的数据包先被处理和发送；</li><li>对低优先级的数据不公平，如果高优先级队列一直有数据需要发送，那么低优先级的数据无法发出；</li></ul><h4 id="公平队列-Fair-Queuing">公平队列 Fair Queuing</h4><ul><li>对于每一个流（如果一系列包经过相同的路由，那么称其为<strong>流 Flow</strong>）都有一个队列，循环处理和发送每个队列中的数据包；</li></ul><h4 id="公平加权队列-Weighted-Fair-Queuing">公平加权队列 Weighted Fair Queuing</h4><ul><li>根据优先级对数据进行加权，一般高优先级对应较大的权重；</li><li>循环按照权值处理每个优先队列，比如权值为3的则一次发送3个包，权值为2的一次发送2个包；</li></ul><p>以下是教材的一个实现示例，实际上这种思想的实现方式并不唯一。</p><p><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/4.png" alt=""></p><p>每个包的到达时间和长度是路由器已知的，发送完成的时间根据以下公式给出：</p><p>$$<br>Finsh_time_i = max(Arrival_time_i, Finish_time_{i-1}) + \frac{Lengh_i}{Weight_i}<br>$$</p><h3 id="2-3-Admission-Control">2.3 Admission Control</h3><p>暂略；</p><h3 id="2-4-Integrated-Services">2.4 Integrated Services</h3><p>暂略；</p><h3 id="2-5-Differentiated-Services">2.5 Differentiated Services</h3><p>暂略；</p><h2 id="3-QoS的一个例子——保证转发-Assured-Forwarding">3. QoS的一个例子——保证转发 Assured Forwarding</h2><p><img src="/2025/05/08/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82/5.png" alt=""></p><ol><li>所有的业务被划分为4个优先级；</li><li>通过 Traffic Policer 的令牌桶机制进行流量整形；</li><li>在经过 Traffic Policer 时，每个优先级下又被分类为3种优先级，或者说丢弃优先级，即丢包的可能性大小；</li><li>所以最终实际上有12种服务等级；</li><li>在每个 Packet 的 IP Header 的 <strong>ToS 字段(Type of Service 服务类型)</strong> 会携带 DSCP(6bits) + ECN(2bits)，其中：<ul><li><strong>DSCP(Differentiated Services Code Point 服务等级)</strong>；</li><li><strong>ECN(Explicit Congestion Notification 拥塞控制)</strong>；</li></ul></li><li>路由器接收到被划分后的包，根据以下2种机制进行分组调度：<ul><li><strong>WFQ(Weighted Fair Queuing 加权公平队列)</strong>：按照优先级进行公平调度；</li><li><strong>RED(Random Early Detection 随机早期检测)</strong>：采用主动丢弃机制，这里被丢弃的概率就是前面划分的丢弃优先级；</li></ul></li></ol><h1>互联 Internetworking</h1><p>不同网络的协议不同，在不同网络间传输信息，需要实现网络互联。</p><h3 id="1-分段-分片-Fragmentation">1. 分段/分片 Fragmentation</h3><p>不同的网络的 <strong>MTU(Maximun Transmission Unit 最大传输单元)</strong> 不同，在网络层传输数据时，需要进行分片处理。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组学习笔记(7)：中央处理器II</title>
    <link href="/2025/05/08/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8II/"/>
    <url>/2025/05/08/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8II/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 - 期中复习</title>
    <link href="/2025/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
    <url>/2025/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：</p><blockquote><p>以下是笔者为应付期中考试的一些复习和总结，由于复习地比较仓促，可能存在错误和遗漏，仅供后来者参考！主要是参考往年题按照题型进行了总结。刷题部分是手写，不传在这里了，晚点可能补充链接；简答题部分由于往年题参考答案不全，本人参考了PPT进行总结，可能存在错误；</p></blockquote><h1>题型</h1><h2 id="一、计算题">一、计算题</h2><h3 id="1-1-CRC检错码计算">1.1 CRC检错码计算</h3><ul><li>看给出的多项式$G(x)$的最高位$r$，则在数据位后添加$r$个$0$后再进行除法；</li><li>这里的除法不同于常规的多项式除法，是<em><strong>模2除法，即按位异或</strong></em>；</li><li>往往和HDLC协议结合出题，只需注意：<ul><li>HDLC协议采用比特填充；</li><li>HDLC等协议差错校验和成帧的顺序是：<ul><li>发送方处理步骤：<ul><li>计算并添加校验码 -&gt; 0比特填充 -&gt; 添加收尾标记01111110</li></ul></li><li>接受方处理步骤：<ul><li>收到物理层的01比特串 -&gt; 首先根据首尾标记位提出帧 -&gt; 删除发送方添加的零比特，就是进行比特删除 -&gt; 最后，进行差错校验</li></ul></li></ul></li></ul></li></ul><h3 id="1-2-帧填充与识别">1.2 帧填充与识别</h3><ul><li>熟悉比特填充、字符填充两种方式即可，会填充和识别；</li><li>HDLC使用比特填充法；</li><li>PPP使用字符填充法；</li></ul><h3 id="1-3-汉明编码">1.3 汉明编码</h3><ul><li>在2的幂次位插入校验码；</li></ul><h3 id="1-4-最大传输速率问题">1.4 最大传输速率问题</h3><ul><li>熟悉三个公式：比特率和波特率的换算、Nyquist定理和香农定理。</li><li>注意后两者计算的是理论上限；</li></ul><h3 id="1-5-分组交换和电路交换延时计算">1.5 分组交换和电路交换延时计算</h3><ul><li>电路交换<ul><li>步骤如下：<ul><li>建立连接 -&gt; 传输数据 -&gt; 连接中止，释放资源；</li></ul></li><li>时延的计算公式如下：<ul><li>$T_{circuit} = T_{establish} + T_{trans} + h_{hop} * T_{prop} + T_{release}$</li></ul></li><li>优点：<ul><li>稳定，时延低（Small Delay, Good Quality）；</li><li>交换过程中控制方式简单；</li></ul></li><li>缺点：<ul><li>连接建立的时间较长；</li><li>带宽固定，不适用于多样的传输服务；</li><li>当两端都没有数据要发送时，造成信道资源浪费；</li></ul></li></ul></li><li>分组交换<ul><li>步骤如下：<ul><li>将较大的数据包分为多个 Packet 进行传输；</li><li>每个 Packet 都有独立的路由（即可能需要携带额外的控制信息）；</li><li>每个 Packet 经过一跳到达中继节点时，都需要进行存储 - 转发 Store-and-Forward；</li></ul></li><li>忽略排队和处理时延，时延的计算公式如下：<ul><li>Let size of date = $M$，size of each packet = $P$，the date rate of the channel = $B$；</li><li>So num of packets $n = \left \lceil \frac{M}{P} \right \rceil$，each packet’s transmission delay $T_{trans} = \frac{P}{B}$，each hop’s propagation delay $T_{prop} = \frac{s}{v_{prop}}$；</li><li>$T_{packet} = (n - 1) * t_{trans} + h * (T_{prop} + T_{trans})$；</li></ul></li><li>优点：<ul><li>信道效率提高；</li><li>速率适配；</li><li>Packet 可以在节点较忙时先被缓存再发送（排队制，不过可能造成传送速率减慢，但可以引入优先级机制）；</li></ul></li><li>缺点：<ul><li>网络更加复杂；</li><li>传播过程中的时延更长；</li><li>没有 QoS，即服务质量保证；</li></ul></li></ul></li></ul><h3 id="1-6-最小帧长度的计算">1.6 最小帧长度的计算</h3><ul><li>以太网或其他使用CSMA/CD技术的LAN，都需要满足条件：$\frac{M_{min}}{B} = 2\tau$；确保有足够的时间检测冲突；</li><li>对于10M以太网，$2\tau = 51.2us$；据此得到最小帧长度为64Bytes；</li><li>事实上，对于10兆以太网，数据帧长度范围为46Bytes ～ 1500Bytes，加上18位控制字符，最终帧长度范围为64Bytes ～ 1518Bytes；</li><li>帧的地址字段长度为6Bytes；</li></ul><h2 id="二、简答题">二、简答题</h2><h3 id="2-1-物理层相关">2.1 物理层相关</h3><ol><li>（2012/2014/2015年期中）请写出采用调制解调器 MODEM 拨号上网时，什么因素限制了调制解调器的带宽？为什么拨号上网的上行和下载速度不相同？</li></ol><blockquote><p>上行受到模拟信号转数字信号的信噪比影响，根据香农公式，最大数据率受到限制，而下行并不会受到限制，</p></blockquote><ol start="2"><li>（2019年期中）两台计算机使用调制解调器利用电话线进行通信，不适合成帧的方法有哪些？说明原因。</li></ol><blockquote><p>调制解调器接受和传送数据的单位是字节而不是位/比特，所以不适合用比特填充法成帧；</p></blockquote><ol start="3"><li>（2015年期中）为什么普通电话线无法传送计算机网络数据，而采用 ADSL 电话线就可以传送？</li></ol><blockquote><p>ADSL 使用的电缆扩展了普通电话线的带宽到3400Hz以上。</p></blockquote><ol start="4"><li>（2020年期中）ADSL用户线的传输介质？复用技术？ADSL用户到端局的数据链路层采用的协议？其向上层提供的服务？成帧技术？</li></ol><blockquote><p><strong>传输介质</strong>：普通电话线，即3类双绞线 Twisted Pair UTP3，但相较于普通电话线扩展了带宽到3400Hz以上。普通电话线有滤波器，它没有。</p><p><strong>复用技术</strong>：模拟信号，采用频分复用 FDM；</p><p><strong>用户到端局的数据链路层采用的协议</strong>：端到端，采用PPP协议，以字符为单位；</p><p><strong>其向上层提供的服务</strong>：非对称数据传输，下行速率远高于上行速率，适用于家庭用户“多下载少上传”的需求；为网络层的多种不同的协议提供支持、提供身份认证、协商IP等（即PPP协议的服务）。</p><p><strong>成帧技术</strong>：字符填充法；</p></blockquote><ol start="5"><li>（2012年期中）传输介质速率比较。</li></ol><blockquote><p>传输速率/带宽：双绞线 &lt; 细缆 &lt; 粗缆 &lt; 光纤；</p></blockquote><h3 id="2-2-滑动窗口协议部分">2.2 滑动窗口协议部分</h3><ol><li>（2013年期中）在滑动窗⼝协议中，采⽤重发计时器和ACK计时器各有什么作⽤？这两者在数值上有什么关系？ (6分）</li></ol><blockquote><p><strong>重发计时器 Frame_Timer</strong>，在发送方发送一个帧时启动，如果在规定时间内未收到该帧对应的ACK，则进行超时重传，每一个帧对应一个计时器；用于确保数据最终被可靠地传送到接收方；</p><p><strong>ACK计时器 ACK_Timer</strong>，一般只在选择重传协议中使用。它的工作机制如下，在接收方从接收窗口下沿依次提交收到的帧并向前滑动时，会启动 ACK_Timer；在 ACK_Timer的规定时间内，如果有接收方有数据要发送，则停止 ACK_Timer，采用 Piggybacking 将 ACK 和数据一起发送给发送方；如果 ACK_Timer 超时，则单独发送 ACK 给 发送方，同时停止计时器。ACK_Timer 通过延时确认，提高了网络效率，减少了单独的 ACK 报文数量。由于采用累积 ACK 的方式，所以接收方只需要一个 ACK_Timer。</p><p>在时间关系上，书上给出了以下关系：$2t_{prop} + ack_timer &lt; frame_timer$，不等式左边表示从发送方发送数据帧到接收方发送 ACK 并返回 ACK 所需的最大时间，不等式右边表示发送方的重传计时器的超时时间，即等待 ACK 的最大时间。小于关系避免了发送方在 ACK 尚未到达前误判数据帧丢失并进行不必要的重传。</p></blockquote><h3 id="2-3-共享信道协议">2.3 共享信道协议</h3><ol><li>（2018年期中）共享信道协议中，评价一个协议优劣的两个主要指标是什么？</li></ol><blockquote><p>低负载情况下的时延和高负载下的吞吐量（或信道利用率）；</p><p>低负载下适合用竞争的方法（即 1-persistent CSMA）；而 p 越小，负载高时，发送帧的随机化越好，冲突越小，吞吐量越高；</p></blockquote><ol start="2"><li>（2020年期中）简述什么是隐蔽站问题？802.11(CSMA/CA)如何解决？</li></ol><blockquote><p>隐蔽站问题，即假如A需要向B发送数据，但此时站点C位于A的监听范围之外，但出于B的范围内，C同时也要向B发送数据。由于A无法监听到C，仍会发送数据造成冲突；<br>CSMA/CA技术</p></blockquote><ol start="3"><li>（2015年期中）提高信道利用率的措施？</li></ol><blockquote><p>增加发送字节的长度、采用滑动窗口技术等；</p></blockquote><h3 id="2-4-参考模型">2.4 参考模型</h3><ol><li>OSI参考模型</li></ol><blockquote><p>应用层：提供应用相关的服务；<br>表示层：信息的表示、加密、压缩等；<br>会话层：进程会话控制、令牌管理、同步；<br>（以上三层的数据单元为 <strong>Message 消息</strong>）；<br>传输层：实现可靠的端到端的传输，数据单元为 <strong>Segment 段</strong>；<br>网络层：进行路由转发，实现拥塞控制、服务质量管理和网络互联，数据单元为 <strong>Packet 分组</strong>；<br>数据链路层：数据单元是 <strong>Frame 帧</strong>；<br>物理层：数据单元是 <strong>Bit 比特</strong>；</p></blockquote><ol start="2"><li>TCP/IP参考模型</li></ol><blockquote><p>网际层：分组交换、路由，采用IP协议；<br>传输层：分为TCP(可靠的面向连接的服务)和UDP(不可靠的无连接的服务)</p></blockquote><ol start="3"><li>IEEE 802 参考模型</li></ol><blockquote><p>将数据链路层又划分为以下两个子层：</p><p>逻辑链路控制子层（LLC）：为网络层提供统一的接口；流量控制；差错控制；网桥；<br>介质访问控制子层（MAC）：成帧；差错检查；MAC地址；介质访问多路控制；局域网交换，VLAN；</p></blockquote><ol start="4"><li>（2013年期中）针对OSI参考模型和TCP/IP参考模型，各写出两点不足；</li></ol><blockquote><p>OSI模型的缺点：<br>（1）实现复杂度高：七层划分过于细致，导致协议实现成本高，尤其在会话层和表示层功能重复（如加密、压缩等），实际应用中常被合并；<br>（2）缺乏灵活性：属于理论标准，未充分考虑实际网络需求（如互联网的IP协议）；</p><p>TCP/IP模型的缺点：<br>（1）层次划分粗糙：可能导致协议功能边界模糊；<br>（2）无明确服务/接口定义：OSI模型严格区分服务、接口和协议，而TCP/IP模型仅关注协议实现，缺乏标准化接口描述，不利于系统集成；</p></blockquote><ol start="4"><li>（2013年期中）解释协议和服务概念，并说明⼆者之间的关系。协议数据单元（PDU）和服务原语有什么区别和联系？</li></ol><blockquote><p><strong>协议</strong>：两个系统同一层的对等实体之间进行通信需要共同遵守的规则；<br><strong>服务</strong>：某层实体对于上一层实体的支持，即对上一层提供的功能集合；<br><strong>协议与服务的关系</strong>：一层协议的实现需要下层的服务，本层服务的实现需要协议的支持，协议是水平的，服务是垂直的。但注意，本层协议改变不一定会导致本层服务改变，本层服务不变、协议改变不会影响上一层服务，但是本层服务改变会影响相邻上一层的服务；<br><strong>接口</strong>：定义某层实体对于上一层提供的服务原语操作；</p><p><strong>服务原语</strong>：用户与层间服务交互的命令，用于请求或响应服务；<br><strong>协议数据单元PDU</strong>：是同层对等实体之间交换的数据单元，包含<strong>协议头</strong>（即对上层数据进行封装的操作）和<strong>上层数据</strong>；<br><strong>PDU和服务原语的区别和联系</strong>：区别上，PDU为同层之间的水平通信，服务原语为层间的垂直通信，属于用户与服务的交互命令；PDU是实现协议的载体，而服务原语触发协议动作，用户通过服务原语间接使用协议功能；</p></blockquote><ol start="5"><li>（2015年期中）请写出计算机网络层次化设计方法的设计原则。</li></ol><blockquote><p>（1）<strong>各层应执行定义明确的函数 (Each layer should perform a well-defined function)</strong></p><blockquote><p>这意味着每一层需要专注于解决特定类型的问题或提供特定的服务。功能的划分应该清晰，避免不同层次的任务相互混淆。这有助于简化设计和实现，并使各层能够独立开发和维护。</p></blockquote><p>（2）<strong>层间边界的选择应使接口处的信息流最小化 (The layer boundaries should be chosen to minimize the information flow across the interfaces)</strong></p><blockquote><p>相邻层之间的交互（通过服务访问点 SAP）应该尽可能简单。理想情况下，一层应该只向其上一层提供必要的、最小化的服务，减少不必要的依赖和信息传递。这有助于降低协议开销，并提高系统的效率和模块化程度。</p></blockquote><p>（3）<strong>层次的数量应适中 (The number of layers should be…)</strong></p><blockquote><p>层次的数量既不能太多，也不能太少。应该足够多，以确保不同的功能不会被不恰当地合并到同一层中，保持每层的职责单一和清晰。 应该足够少，以避免架构过于庞大和复杂，减少不必要的开销（如每层添加头部信息）。 需要在功能清晰度和整体复杂性之间找到平衡。</p></blockquote></blockquote><h3 id="2-5-无线通信">2.5 无线通信</h3><ol><li>（2019年期中）简要解释WLAN中的TXOP机制。</li></ol><blockquote><p>TXOP，即Transmission Opportunity，传统的信道分配方式是站点每次发送一帧，即“你发一帧我发一帧”这种形式，但这对于数据率大的站点并不公平，并且低速站点会拉低吞吐量。使用TXOP机制时，每个站点获得相等的发送时间，比如假如有$n$个站点，每个站点的速率为$c_i$，那实际传输过程中，每个站点的速率为$\frac{c_i}{n}$，保证了每个站点都获得相等的发送时间；</p></blockquote><ol start="2"><li>（2019年期中）无线局域网的协议标准是什么？什么是虚拟载波监听技术？</li></ol><blockquote><p><strong>协议标准</strong>：IEEE 802.11；</p><p><strong>虚拟载波监听技术</strong>：<br>（1）每个站点都维持一个 NAV（Network Allocation Vector，网络分配向量）；<br>（2）发送方在发送帧时，携带一个 NAV，表示信道将被占用的时长；<br>（3）接收方在接收到帧后，更新本地的 NAV，根据 NAV 确定需要的退避时间，以避免冲突。</p></blockquote><h3 id="2-6-一些设备">2.6 一些设备</h3><ul><li>Repeater：互联设备，属于物理层；用于将两个总线型的以太网进行连接；</li><li>Bridge：网桥，属于数据链路层；用于将两个局域网进行互联；</li></ul><ol><li>网桥和交换机的共同点和区别：</li></ol><blockquote><p>共同点：都是数据链路层设备；<br>不同点：<br>（1）网桥主要用软件处理；而交换机的处理是硬件层面的；<br>（2）网桥同时只能分析和处理一帧，而交换机一次性可以处理大量帧；<br>（3）网桥采用存储转发方式，而交换机还可以通过直通 Cut-Through 等方式加快传输速率；</p></blockquote><ol start="2"><li>（2018年期中）能隔离广播风暴的设备有？</li></ol><blockquote><p>路由器 and VLAN交换机，两者分别工作在不同的层；</p></blockquote><h3 id="2-7-虚拟局域网VLAN">2.7 虚拟局域网VLAN</h3><ul><li>将局域网在逻辑上划分为多个广播域；</li><li>每个 VLAN 都有一个唯一的标识符 VLAN ID；通过这个实现区分；</li><li>不支持 VLAN 的交换机无法识别帧中的 VLAN ID；</li></ul><ol><li>（2019年期中）使用 VLAN 交换机可构建逻辑上相互隔离的多个网络，广播和组播报文也会被隔离吗？ 说明原因？</li></ol><blockquote><p>可以隔离。VLAN通过在数据链路层进行逻辑隔离，默认情况下会<strong>隔离广播和未知组播</strong>报文，将其限制在各自的VLAN内部，从而提高网络性能和安全性。</p></blockquote><h1>考后回忆和复盘</h1><blockquote><p>题量比较大，一共9道大题，考试时间是85分钟，还是有一些往年题的，你邮经典藏往年题然后吃老本。懒得回忆具体数据了，和上面整理的内容重合度还蛮高的。好好看PPT和作业题即可。当然，如果我的整理对你有帮助，那么就更好了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组学习笔记(6)：中央处理器I</title>
    <link href="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/"/>
    <url>/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/</url>
    
    <content type="html"><![CDATA[<h1>处理器功能</h1><ol><li>指令控制：控制程序严格按照规定顺序执行；</li><li>操作控制：处理器根据从内存取出的每条指令产生相应的操作信号，送往相应的部件，控制这些部件按指令的要求进行动作；</li><li>时间控制：对各种操作实施时间进行控制；</li><li>数据加工；</li><li>中断处理；</li></ol><h1>CPU模型及其组成</h1><p><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/1.png" alt=""></p><p>CPU组成部分如下：</p><ul><li><strong>控制器</strong>：从指令cache中读取当前指令，并指出下一条指令在指令cache中的位置；对指令进行译码，产生操作控制信号；指挥并控制CPU、内存和IO设备之间的数据流动；<ul><li><strong>程序计数器PC</strong>；<ul><li>保存将要执行的下一条指令的地址；</li></ul></li><li><strong>指令寄存器IR</strong>；<ul><li>保存当前正在执行的一条指令；</li><li>保存的操作码字段就是指令译码器的输入；</li></ul></li><li><strong>指令译码器</strong>；</li><li>操作控制器OC；<ul><li>根据指令的操作码和时序性好，产生各种操作的控制信号；</li><li>根据设计方法不同可分为：<ul><li>硬布线控制器：采用时序逻辑；</li><li>微程序控制器：采用存储逻辑；</li></ul></li></ul></li><li>时序产生器；<ul><li>对各种操作信号进行执行时间先后顺序控制；</li></ul></li></ul></li><li><strong>运算器</strong>：对数据进行加工处理，是执行部件，执行所有算术运算、逻辑运算和测试运算；<ul><li>算数逻辑单元ALU；</li><li>累加寄存器；</li><li><strong>数据缓冲寄存器DR</strong>；<ul><li>用来暂存从数据cache中读出的或来自外部接口的一个数据字，或ALU 的运算结果；</li><li>从图上就可以看出，它是ALU运算结果和通用寄存器组之间的缓冲；</li><li>用来补偿CPU、内存和外设在操作速度上的差异；</li></ul></li><li><strong>程序状态字寄存器PSWR</strong>；<ul><li>保存运算结果标志，比如进位标志、零标志、溢出标志、负标志；</li><li>保存中断和系统工作状态等信息；</li></ul></li></ul></li><li>其他主要寄存器：<ul><li><strong>地址寄存器AR</strong>；<ul><li>存放处理器当前访问的数据cache中数据单元的地址；</li></ul></li><li>通用寄存器R0 ～ R3；<ul><li>暂存ALU的运算结果；</li></ul></li></ul></li><li><strong>数据通路</strong>：寄存器之间、寄存器与ALU之间传送数据通路的总称；</li></ul><h1>指令周期</h1><h2 id="执行程序">执行程序</h2><p>在冯诺依曼结构，即存储程序式计算机中，在程序运行之前，需要将程序和数据均放到内存中，具体执行程序的顺序如下：</p><ol><li>将程序首地址送入程序计数器PC；</li><li>从内存(cache)中取出该指令并执行；</li><li>形成下一条待执行指令的地址，保存到PC中；</li><li>自动连续执行指令，直至最后一条指令；</li></ol><p>即一个取指令 + 执行指令的过程；</p><h2 id="指令周期">指令周期</h2><p>指令周期就是取指令 + 分析指令 + 执行指令所需的总时间；</p><p>显然，由于各种指令的执行时间是不同的，所以各种指令的指令周期也不相同；</p><p>一个指令周期包含若干个CPU周期；</p><h2 id="CPU周期-机器周期">CPU周期 / 机器周期</h2><p>CPU周期又称机器周期，一个机器周期又包含若干个时钟周期；</p><h2 id="时钟周期；">时钟周期；</h2><p>时钟周期是处理操作的基本单位，也称节拍脉冲；</p><h2 id="指令的执行步骤">指令的执行步骤</h2><h3 id="MOV指令">MOV指令</h3><p>MOV指令作用是数据传送，属于RR型指令，假设指令为 <code>MOV R1 R0</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令（1个CPU周期）<ol><li>读取寄存器R0中的数；</li><li>通过ALU以及三态门读到数据总线DBUS上；</li><li>将取出来的数写入数据缓冲寄存器DR；</li><li>将数据缓冲寄存器DR中的数写入寄存器R1；</li></ol></li></ol><p>MOV指令周期 = 2个CPU周期；</p><h3 id="LAD指令">LAD指令</h3><p>LAD指令作用是从内存上加载数据到寄存器中，属于RS型指令，假设指令为 <code>LAD R1 A</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令<ol><li>送操作数地址（1个CPU周期）<ol><li>操作数的直接地址即为 A，将其装入地址寄存器AR；</li></ol></li><li>取出操作数，装入通用寄存器（1个CPU周期）<ol><li>从数据存储器中读出 A 地址上的数，发送至数据总线；</li><li>将取出来的操作数写入数据缓冲寄存器DR；</li><li>将数据缓冲寄存器DR中的数写入寄存器R1；</li></ol></li></ol></li></ol><p>LAD指令周期 = 3个CPU周期；</p><h3 id="ADD指令">ADD指令</h3><p>ADD指令属于RR型指令，假设指令为 <code>ADD R1 R2</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令（1个CPU周期）<ol><li>读取寄存器R1和R2上的数；</li><li>通过ALU执行加法运算，结果通过三态门发送至数据总线；</li><li>将运算结果暂存至数据缓冲寄存器DR；</li><li>将数据缓冲寄存器DR暂存的运算结果写入寄存器R1；</li></ol></li></ol><p>ADD指令 = 2个CPU周期；</p><h3 id="STO指令">STO指令</h3><p>STO指令的作用是将寄存器中的数写入内存，属于RS型指令，假设指令为 <code>STO R2(R3)</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令<ol><li>送操作数地址（1个CPU周期）<ol><li>从寄存器R3中取出操作数的直接地址，将其装入地址寄存器AR；</li></ol></li><li>送操作数地址，执行写操作（1个CPU周期）<ol><li>从寄存器R2中的数读出，发送到数据总线上；</li><li>发出写命令，将数据总线上的的数写入地址寄存器AR对应的地址单元；</li></ol></li></ol></li></ol><p>STO指令 = 3个CPU周期；</p><h3 id="JMP指令">JMP指令</h3><p>JMP指令是无条件转移指令，假设指令为 <code>JMP A</code> ，执行过程如下：</p><ol><li>取指令（1个CPU周期）<ol><li>从内存(cache)中取出当前MOV指令；</li><li>PC += 1，为取下一条指令作准备；</li><li>指令译码/测试；</li></ol></li><li>执行指令（1个CPU周期）<ol><li>转移地址即为A，将转移地址A送往程序计数器PC；</li></ol></li></ol><p>JMP指令 = 2个CPU周期；</p><h3 id="执行步骤总结">执行步骤总结</h3><ol><li>读取指令（1次访存）；（公共操作）</li><li>分析指令；</li><li>执行指令：不同指令操作步骤不同；</li><li>检查有无中断请求；（公共操作）</li></ol><p>方框图表示如下，其中1个方框代表1个CPU周期；<img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/2.png" alt=""></p><h1>时序产生器和控制方式</h1><h2 id="控制器分类">控制器分类</h2><ul><li>硬布线控制器：时序信号一般采用 <strong>主状态周期 —— 节拍电位 —— 节拍脉冲</strong> 的三级体制，节拍电位 = CPU周期时间；</li><li>微程序控制器：时序信号较简单，采用 <strong>节拍电位 —— 节拍脉冲</strong> 的二级体制；<ul><li>组成包括：<ul><li>时钟源；</li><li>环形脉冲发生器；</li><li>节拍脉冲和读写时序译码；</li><li>启停控制逻辑；</li></ul></li></ul></li></ul><h2 id="控制方式">控制方式</h2><ul><li>同步控制：执行各指令所需的机器周期数和时钟周期数固定不变；</li><li>异步控制：<ul><li>每条指令和操作控制信号按需占用时间；</li><li>每条指令的指令周期可以由多个不等长的机器周期构成；</li></ul></li><li>联合控制；</li></ul><h1>微程序控制器</h1><h2 id="与硬布线控制器对比">与硬布线控制器对比</h2><ul><li>微程序控制器按照软件设计的思想设计硬件；</li><li>相较于硬布线控制器，具有规整性、灵活性、可维护性等优点；</li></ul><h2 id="基本概念">基本概念</h2><ul><li>微命令：控制部件通过控制线向执行部件发出的各种控制信号；</li><li>微操作：执行部件接收到微命令后执行的的特定操作；<ul><li>相容性操作：同时在一个CPU周期内可以并行的操作；</li><li>相斥性操作：不能同时在一个CPU周期内并行的操作；</li></ul></li><li>反馈信息：执行部件使用反馈线向控制部件报告操作情况，控制部件根据反馈信息发出新的微命令；</li><li>微指令：在一个CPU周期内，实现某个操作功能的一组微命令构成了微指令。<ul><li>即，用一条微指令对应一个机器指令的一个执行步骤；</li><li>微指令需要提供：<ul><li>执行该步骤所需的控制信号；</li><li>提供下一条需要执行的微指令的地址；</li></ul></li></ul></li><li>微程序：一条机器指令对应一段微程序，微程序即实现一条机器指令所需的多条微指令序列；</li></ul><h2 id="微指令的基本格式">微指令的基本格式</h2><p>微指令包括操作控制字段和顺序控制字段：</p><ul><li>操作控制字段用于发出控制信号，每一位对应一个微命令；</li><li>顺序控制字段用于产生下一条微指令的地址；</li></ul><p><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/3.png" alt=""></p><h2 id="微程序控制器原理">微程序控制器原理</h2><p><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/4.png" alt=""></p><p>一个基本的原理框图如上图所示：</p><ul><li>控制存储器：用来存放全部指令系统的微程序的<strong>只读存储器</strong>；<ul><li>从控制存储器中读出一条微指令并执行的时间总和称为<strong>微指令周期</strong>；</li></ul></li><li>微指令寄存器：用于存放由控制存储器读出的一条微指令；<ul><li>微地址寄存器：用于决定将要访问的下一条微指令的地址；</li></ul></li><li>地址转移逻辑：<ul><li>正常情况下，由微指令的顺序控制字段直接给出下一条微指令的地址并存放在微地址寄存器中；</li><li>当微程序出现分支，则需要根据状态条件、指令寄存器IR等计算地址转移；</li></ul></li></ul><p>一个基本的执行过程如下：</p><ol><li>执行“取指”指令，即取出指令，这是所有机器指令的共用微指令，所以一般存放在地址0000处；并且所有机器指令的最后一条微指令的直接地址都指向0000，用于取下一条指令；</li><li>进入 P1 测试，即操作码测试，产生对应的微程序入口指令，送入微地址寄存器；</li><li>该条微指令执行完毕后，进入 P2 测试，用于计算下一条微指令的地址，读取微指令，重复上述操作；</li><li>当微程序对应的所有微指令均被执行完后，返回到0000处，即取指微指令，用于执行下一段微程序；</li></ol><h2 id="机器指令与微指令的关系">机器指令与微指令的关系</h2><p>注意区分程序与微程序、机器指令与微指令、地址与微地址的对应关系。前者与主存有关，而后者与控制存储器有关，如下图：<br><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/5.png" alt=""></p><h2 id="微程序设计">微程序设计</h2><h3 id="微命令编码">微命令编码</h3><ol><li>直接表示法：微指令的控制字段中每一位对应一个微命令（即控制信号）；</li><li>编码表示法：把一组相斥的微命令合并成一个小组，对应一个字段，通过小组译码器对微命令信号进行译码，译码输出作为控制信号。$n$ 位二进制译码后可以表示 $2^{n} - 1$个微命令。比如3个互斥的微命令，原本需要3位，现在只需要合并为一个2位的字段，通过2:4译码器进行译码；如下图：</li></ol><p><img src="/2025/04/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(6)%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8I/6.png" alt=""></p><p><strong>注：为什么用 $n$ 位二进制可以表示 $2^n - 1$$ 个微命令，而不是 $2^n$ 个？</strong></p><blockquote><p>注意<strong>编码表示法中用“全 0 码不表示任何有效微命令”</strong>，即全0表示无操作，所以剩下 $2^n - 1$ 个微命令才是有效的；</p></blockquote><ol start="3"><li>混合表示法：更灵活；</li></ol><h3 id="产生后继地址的方法">产生后继地址的方法</h3><ol><li>计数器方式</li></ol><ul><li>与程序计数器PC类似：<ul><li>顺序执行微指令时，下一条微指令的地址通过当前微地址 + 一个增量产生；</li><li>非顺序执行时需要通过一定的转移方式产生下一条微地址；</li></ul></li><li>优点：<ul><li>需要的顺序控制字段少；</li></ul></li><li>缺点：<ul><li>多路并行转移功能弱，速度慢、灵活性差；</li></ul></li></ul><ol start="2"><li>多路转移方式</li></ol><ul><li>程序运行时：<ul><li>不产生分支时：后继微地址直接由本条微地址的顺序控制字段给出；</li><li>产生分支时：根据本条微地址的顺序控制字段的P字段（即<strong>判别测试位</strong>）和<strong>状态条件位</strong>来从若干“候选”微地址中选择；</li></ul></li><li>状态条件有 $n$ 位 $\Rightarrow$ 可以实现 $2^n$ 路转移（即对应 $2^n$ 个微程序入口） $\Rightarrow$ 涉及微地址寄存器的 $n$ 位（ $n$ 位状态条件直接存入微地址寄存器，微地址寄存器的高位相当于”基地址“）；</li><li>优点：多路并行转移功能强， 速度快，更灵活；</li><li>缺点：多路转移需要复杂的组合逻辑；</li></ul><h3 id="微指令格式">微指令格式</h3><ul><li>水平型微指令：一次能定义并执行多个并行操作的微命令的微指令；<ul><li>包含控制字段、判别测试字段（P字段）、下地址字段；</li></ul></li><li>垂直型微指令：类似机器指令，通过设置微操作码字段规定微指令的功能，长度较短，但一条微指令只有 1 ～ 2 个微操作命令，实现一条机器指令对应的微程序需要的垂直型微指令更多；</li></ul><p>两者对比：</p><ul><li>水平型微指令并行操作能力强，灵活，效率高；</li><li>水平型微指令执行一条指令的用时较短；</li><li>水平型微指令组成的微程序微指令较长但微程序较短；</li><li>水平型微指令难以掌握，垂直型微指令容易掌握；</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些有关Game Theory(博弈论)的学习记录</title>
    <link href="/2025/04/05/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Game%20Theory(%E5%8D%9A%E5%BC%88%E8%AE%BA)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/04/05/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Game%20Theory(%E5%8D%9A%E5%BC%88%E8%AE%BA)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：</p><blockquote><p>以下是笔者学习<a href="https://www.bilibili.com/video/BV1xY411Y7Wj/">【耶鲁大学】博弈论</a> 课程中整理的内容，因为笔者实在是懒的自己找书啃。有些内容可能结合自己的研究方向（Multiple-Agent-System）简单拓展；至于数模感觉能用到的几率比较小。</p></blockquote><h1>一、Prisoner’s Dilemma 囚徒困境</h1><h2 id="1-1-四个重要结论">1.1 四个重要结论</h2><p><strong>定义 1.1</strong>：<strong>Strictly Dominant Strategy 严格优势策略</strong></p><blockquote><p>假如策略$\alpha$在无论对手选择何种应对的情况下的收益都高于策略$\beta$，则称策略$\alpha$为相对$\beta$的严格优势策略；</p></blockquote><p><strong>结论 1.1</strong>：<strong>不要使用严格劣势策略</strong></p><blockquote><p>我们假设参与博弈的行为人都是理性的（和经济学中定义的理想经济人类似），都希望追求更高的收益（当前，每个人衡量收益大小的标准有不同，对收益的看法显然也会影响决策）；</p></blockquote><p><strong>结论 1.2</strong>：<strong>理性的选择可能导致更糟的结果</strong></p><blockquote><p>显然，如果双方均追求对于个人收益的最大化，可能导致双输；</p></blockquote><p><strong>如何破解囚徒困境？</strong></p><blockquote><p>沟通并不能解决这个困境，在缺乏强制力介入的情况下，沟通缺乏意义，可能有效的方式是有强制力的合同（比如书面合同）、重复博弈、教育。</p></blockquote><p><strong>结论 1.3</strong>：<strong>如欲得之，必先知之 If you want to get it, you must know it first</strong></p><blockquote><p>如果我们不知道一个人或一场博弈中的收益情况，那么我们就不可能获得收益；</p></blockquote><p><strong>结论 1.4</strong>：<strong>换位思考 Put yourself  in others’ shoes and try to figure out what they’ll do</strong></p><blockquote><p>假如我们知道另一方的收益情况，那么如果我们确认对方会根据 <strong>结论 1.1</strong> 选择某种策略，那么我们可以根据对方的选择选择对于自己收益更高的那种，即使站在自己的角度，并没有严格优势策略；</p></blockquote><h2 id="1-2-Grade-Game-积分游戏">1.2 Grade Game 积分游戏</h2><p>关于耶鲁大学《博弈论》课程上的积分游戏的具体推导见下，懒地打了。。。<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/Page1.png" alt=""><br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/Page2.png" alt=""></p><h2 id="1-3-Ingredients-of-a-game-博弈的要素">1.3 Ingredients of a game 博弈的要素</h2><ul><li><strong>Players 参与者</strong>；</li><li><strong>Strategies 策略</strong>；<ul><li>$s_i$:  $Player_i$的某个特定策略；</li><li>$S_i$: $Player_i$的策略集合；</li><li>$S$: 一次博弈，即所有参与者的策略组合；</li></ul></li><li><strong>Payoff 收益</strong>；</li><li><strong>Assumption 假设</strong>：每个参与者都知道其他人的可能策略和收益，即博弈者之间信息透明；</li><li>$S_{-i}$: 一次博弈中除了$Player_i$之外的其他所有参与者的策略；</li></ul><p>定义符号后，我们给出更严格的严格优势策略的定义：</p><p><strong>定义 1.1 Plus</strong>：<strong>Strictly Dominant Strategy 严格优势策略</strong></p><blockquote><p>$Player_i$'s strategy $S’<em>i$ is strictly dominated by $Player_i$'s strategy $S_i$ if $U_i(S_i, S</em>{-i}) &gt; U_i(S’<em>i, S</em>{-i})$ for all $S_{-i}$；</p></blockquote><h2 id="1-4-Hannibal-汉尼拔">1.4 Hannibal 汉尼拔</h2><p>Ben教授通过汉尼拔进军罗马的例子，引入了弱优势策略，弱优势策略允许了一部分策略组下收益相等而不是严格大于；</p><p><strong>定义 1.1 Extension</strong>：<strong>Weakly Dominant Strategy 弱优势策略</strong></p><blockquote><p>$Player_i$'s strategy $S’<em>i$ is weakly dominated by $Player_i$'s strategy $S_i$ if $U_i(S_i, S</em>{-i}) \ge U_i(S’<em>i, S</em>{-i})$ for all $S_{-i}$, and $U_i(S_i, S_{-i}) &gt; U_i(S’<em>i, S</em>{-i})$ for some $S_{-i}$;</p></blockquote><p>关于汉尼拔的具体推导见下：<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/%E7%AC%94%E8%AE%B0%202025%E5%B9%B44%E6%9C%8815%E6%97%A5%20(2).png" alt=""></p><h2 id="1-5-Iterative-Deletion-迭代剔除劣势策略">1.5 Iterative Deletion 迭代剔除劣势策略</h2><p>该策略要求参与者首先找到所有劣势策略，剔除它们，然后再重新审视整个博弈，如此往复。一个具体的例子如下：</p><p>每人选择一个1到100之间的数字，谁选的数字最接近平均数的三分之二，则获得胜利。</p><p><strong>第一层</strong>：</p><blockquote><p>假设大家选取的数字是在 0 ～ 100 间随机分布的，那么 average 约等于50，50的2/3应该是33左右；但是问题也很明显，大家不会都进行随机选择；</p></blockquote><p><strong>第二层</strong>：</p><blockquote><p>我认为别人都按照第一层的思路进行思考，即大部分人都会选择33，那么我应该选择 33 * 2/3 = 22；</p></blockquote><p><strong>第三层</strong>：</p><blockquote><p>从这一层开始，使用了博弈论的框架，即假设参与者都是理性的。那么，选择大于67的数字属于弱劣势策略（除非大家均选择100）；那么大于67的数字就被剔除了；按照这个思路，我选择45；</p></blockquote><p><strong>第四层</strong>：</p><blockquote><p>如果大家都考虑到了上面一层，那么基于第三层，现在选择大于45的也变成了弱劣势策略；按照这个思路，我应该选择30；</p></blockquote><p>按照这个逻辑一直持续下去，30 ～ 20、20 ～ 13，不断持续剔除下去，那么最终所有人都会选择1；</p><p>但1就是正确答案吗？</p><p>得到1需要反复迭代、剔除，即需要我不断知道别人都想到了上一层，即我知道你知道我知道你知道（无限套娃）我是理性的，即 <strong>Common Knowledge 共同知识</strong> 。</p><p><strong>定义 1.5</strong>：<strong>共同知识</strong></p><blockquote><p>共同知识是指某个信息或事件不仅被所有参与者知晓，而且所有参与者都知道其他参与者也知道该信息，并且知道其他参与者也知道其他人知道该信息，如此无限递归。<br>即：所有人都是理性的；所有人都知道所有人是理性的；所有人都知道所有人都知道所有人是理性的……</p></blockquote><h2 id="1-6-The-Median-Voter-Theorem-中位选民定理">1.6 The Median-Voter Theorem 中位选民定理</h2><p>该定理事实上只是迭代剔除劣势策略在政治学上的一个应用。并且该模型还是简化了现实问题，存在不少问题；</p><p>首先，对于2个候选人A和B，他们的立场用 1 ～ 10 数字表示，假定每个数字对应10%的选民，选民仅按立场的接近程度进行投票；如果立场的接近程度相同，则一半一半；候选人的目标就是最大化选票，即收益；</p><p>容易发现，1和10为劣势策略，具体推导如下：如果A选择2，那么</p><ol><li>当B选1时，$U_A(2,1) = 90% &gt; U_A(1,1) = 50%$；</li><li>当B选2时，$U_A(2,2) = 50% &gt; U_A(1,2) = 10%$；</li><li>当B选3时，$U_A(2,3) = 20% &gt; U_A(1,3) = 15%$；</li><li>当B选4时，$U_A(2,4) = 25% &gt; U_A(1,4) = 20%$；</li></ol><p>以此类推，后面都是2优于1并且均相差$5%$；</p><p>选2严格优于选1，根据对称性，选9也严格优于选10。</p><p>越接近中间就优于两侧吗？并不，可以算一个例子：如果A选择3，那么</p><p>当B选择1时，$U_A(3,1) = 85% &lt; U_A(2, 1) = 90%$，即A选3并不严格优于选2；</p><p>但是如果按照迭代剔除的思想，剔除劣势策略1和10之后，那么接下来策略2和9就变成了劣势策略，以此类推，最优的策略是选5和选6；这就是中位选民定理；</p><p>这个模型存在以下问题：</p><ol><li>选民并非平均分布；</li><li>选民并非完全根据立场来投票，即考量因素往往是多维度的；</li><li>选民往往会根据候选人过去的行为判断立场而并非按候选人所声称的；</li><li>选民存在弃票；</li><li>候选人往往大于2个；</li><li>大选之前还有初选；</li><li>…</li></ol><h2 id="1-7-Best-Response-最优对策">1.7 Best Response 最优对策</h2><p>如果站在双方的角度，都不存在严格最优对策，那么站在我的角度，假设另一方采取某策略的概率是$p$，据此计算我选择每个策略的期望收益；</p><blockquote><p><em><strong>持续更新中…</strong></em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>科研学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简述MCP(Model Context Protocols)</title>
    <link href="/2025/04/04/%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/"/>
    <url>/2025/04/04/%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/</url>
    
    <content type="html"><![CDATA[<h1>What’s MCP</h1><p>MCP，模型上下文协议，是一种开源标准。如果希望让我们的AI Agent能自动使用工具，能与各种数据源建立连接，自动地访问和利用外部信息，那么MCP就是这一过程的中间件。由LLM来决定需要调用哪些工具，但是由于LLM供应商以及各种工具标准并不统一，就MCP标准化指令的执行。即，MCP提供了一种将代理连接到工具的标准化方法。</p><p>MCP作为一种“中间协议层”，可以通过下图来更好地理解，具体架构将在后文阐述；<br><img src="%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/1.png" alt=""></p><h1>Why’ s MCP</h1><p>上面也提到了，LLM供应商以及各种工具标准并不统一，并且函数调用本身就具有局限性，再进一步讲述之前，我们先明确函数调用的概念。</p><p>函数调用（function calling）负责将自然语言提示转换为结构化函数调用指令，以便面向工具的系统（如 MCP 服务器）能够理解并执行作。此阶段的重点是为工具或 API 生成精确的指令。这就是LLM与具体系统集成的第一阶段；第二阶段才是MCP提供标准化工具执行指令。</p><p>LLM供应商大都提供了函数调用的功能，这里以Deepseek为例，简述函数调用的过程和使用方法（不考虑MCP的使用），具体内容可以进一步参考<a href="https://api-docs.deepseek.com/zh-cn/guides/function_calling">Deepseek API文档</a>；</p><ol><li>用户提问：北京今天的天气如何？</li><li>LLM理解用户提问，返回 function <code>get_weather(&#123;location: 'Beijing'&#125;)</code>；</li><li>（用户）手动调用 function <code>get_weather(&#123;location: 'Beijing'&#125;)</code>，将返回结果传递给LLM；</li><li>LLM理解结果，并将答案以自然语言形式输出；</li></ol><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_messages</span>(<span class="hljs-params">messages</span>):<br>    response = client.chat.completions.create(<br>        model=<span class="hljs-string">&quot;deepseek-chat&quot;</span>,<br>        messages=messages,<br>        tools=tools<br>    )<br>    <span class="hljs-keyword">return</span> response.choices[<span class="hljs-number">0</span>].message<br><br>client = OpenAI(<br>    api_key=<span class="hljs-string">&quot;&lt;your api key&gt;&quot;</span>,<br>    base_url=<span class="hljs-string">&quot;https://api.deepseek.com&quot;</span>,<br>)<br><br>tools = [<br>    &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>        <span class="hljs-string">&quot;function&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;get_weather&quot;</span>,<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Get weather of an location, the user shoud supply a location first&quot;</span>,<br>            <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>                <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;location&quot;</span>: &#123;<br>                        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                        <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;The city and state, e.g. San Francisco, CA&quot;</span>,<br>                    &#125;<br>                &#125;,<br>                <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;location&quot;</span>]<br>            &#125;,<br>        &#125;<br>    &#125;,<br>]<br><br>messages = [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;How&#x27;s the weather in Beijing?&quot;</span>&#125;]<br>message = send_messages(messages)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;User&gt;\t <span class="hljs-subst">&#123;messages[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;content&#x27;</span>]&#125;</span>&quot;</span>)<br><br>tool = message.tool_calls[<span class="hljs-number">0</span>]<br>messages.append(message)<br><br>messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;tool&quot;</span>, <span class="hljs-string">&quot;tool_call_id&quot;</span>: tool.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;24℃&quot;</span>&#125;)<br>message = send_messages(messages)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Model&gt;\t <span class="hljs-subst">&#123;message.content&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>注意上述代码中，我们手动定义了工具的内容，其格式由LLM供应商决定，并且供应商之间标准并不统一。而且，函数调用功能是通过用户手动执行并将结果添加到prompt中实现的。</p><h2 id="MCP’s-Role-in-Execution">MCP’s Role in Execution</h2><p>LLM生成函数调用指令后，必须执行这些指令才能提供结果。这就是 MCP 的用武之地。MCP 提供了一个标准化的框架来管理执行过程，包括工具发现、调用和响应处理；关于其具体的执行过程，我们先介绍它的架构；</p><h1>MCP Architecture</h1><p><img src="%E7%AE%80%E8%BF%B0MCP(Model%20Context%20Protocols)/2.png" alt=""></p><p>上图直观展示了MCP的架构，它主要围绕三个组件构成：MCP Server、MCP Host、MCP Client；</p><ul><li>MCP Server：顾名思义，是MCP的服务端，即集成的工具、函数、结构和数据连接所在的位置，同时负责执行代理给出的指令；</li><li>MCP Host：主机，比如聊天应用程序，用户使用包含代理的应用程序；</li><li>MCP Client：MCP的客户端，是主机与服务器之间的接口，负责数据交换；</li></ul><p>当引入MCP后，我们通过Agent代理查询天气的过程变成：</p><ol><li>用户提问：北京今天的天气如何？</li><li>主机连接到LLM，根据问题和服务器提供的工具列表，确定使用哪些MCP Server；</li><li>客户端调用所需的MCP Server，执行所选的工具；</li><li>服务器将结果回送给LLM，后者生成最终答案并输出给用户；</li></ol><h1>MCP开发</h1><blockquote><p><em><strong>持续更新中</strong></em>；</p></blockquote><p>官方开发文档可参考：<br><a href="https://modelcontextprotocol.io/introduction">官方开发文档</a></p><h1>Reference</h1><p>[1]. <a href="https://medium.com/@tahirbalarabe2/what-is-model-context-protocol-mcp-architecture-overview-c75f20ba4498">What is Model Context Protocol? (MCP) Architecture Overview</a></p>]]></content>
    
    
    <categories>
      
      <category>科研学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网学习笔记(4)：介质访问控制子层</title>
    <link href="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/"/>
    <url>/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>介质访问控制（Media Access Control, Mac）需要完成的任务是，为使用传输介质的每一个节点隔离来自同一信道上其他节点所传送的信号，协调活动节点的传输。</p><h1>Dynamic Channel Allocation</h1><h2 id="Assumptions">Assumptions</h2><ol><li>节点之间是独立的；</li><li>只有一条信道；</li><li>冲突可被观测到；</li><li>Continuous time / Slotted time</li><li>Carrier sense / No carrier sense：载波监听，即发送之前能否知道信道空闲；</li></ol><h2 id="Random-multiple-access-随机介质访问控制">Random multiple access 随机介质访问控制</h2><h3 id="ALOHA">ALOHA</h3><h4 id="Pure-ALOHA">Pure ALOHA</h4><ul><li>任何时刻如果有数据需要发送都能发送；</li><li>如果没有收到ACK，则重传；</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/1.png" alt=""></p><blockquote><p><strong>注</strong>：<strong>Vulnerable Period 脆弱期</strong>：$2t_{trans}$；</p></blockquote><h5 id="流程">流程</h5><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/2.png" alt=""></p><blockquote><p><strong>注</strong>：如果没有收到正确的ACK，则随机等待一定时间后再重传；</p></blockquote><h4 id="Slotted-ALOHA-时隙-分槽">Slotted ALOHA 时隙/分槽</h4><ul><li>只能在每个时隙的开始时刻发送数据</li><li>需要统一的时钟管理</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/3.png" alt=""></p><blockquote><p><strong>注</strong>：<strong>Vulnerable Period 脆弱期</strong>：$t_{trans}$；</p></blockquote><h3 id="Carrier-Sense-Multiple-Access-Protocols-CSMA-载波监听多路访问控制">Carrier Sense Multiple Access Protocols(CSMA, 载波监听多路访问控制)</h3><ul><li><strong>发前先听</strong>：<ul><li>If Channel is idle，即监听到信道上没信号，则以一定的概率 $p$ 发送；（减小有两个节点同时监听到信道上没信号并发送数据导致冲突的可能性）</li><li>If Channel is busy，节点等待直至监听到信道上没信号；</li><li>如果有两个节点同时发送，则冲突；</li><li>如果超过一定时间没有收到ACK，则重传；</li></ul></li></ul><blockquote><p><strong>注</strong>：<strong>Vulnerable Period 脆弱期</strong>：$t_{prop}$；</p></blockquote><h4 id="Nonpersistant-vs-Persistant-CSMA">Nonpersistant vs. Persistant CSMA</h4><ul><li>Nonpersistant CSMA 如果监听到信道正忙，那它会等待一个随机时间后在进行监听；<ul><li>高负载时，有较高的吞吐量；</li></ul></li><li>Persistant CSMA 如果监听到信道正忙，会持续监听到信道上没有信号，然后以一定的概率 $p$ 发送；<ul><li>1 - Persistant CSMA：$p = 1$，即监听到信道上没有信号就发送；<ul><li>低负载时，能有较低的时延和较高的吞吐量；</li><li>高负载时，吞吐量较低；</li></ul></li><li>p - Persistant CSMA：以一定的概率 $p$ 发送；</li></ul></li></ul><blockquote><p><strong>注</strong>：$p$ 越小，则在负载高的情况下，随机化（信号的离散程度）越好，冲突的可能性越小；</p></blockquote><h3 id="比较和总结">比较和总结</h3><p><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504102203589.png" alt=""></p><blockquote><p><strong>注</strong>：评价MAC协议的指标：</p><ol><li>低负载时的时延；</li><li>高负载时的吞吐量（或信道利用率）；<br>低负载时，适合使用竞争方法；</li></ol></blockquote><p>上述三个协议都有一个共同的问题：只有当 Timer 超时，发送方才知道数据发送过程中可能出现了冲突，<em><strong>没有检测冲突的能力！</strong></em></p><h3 id="CSMA-CD-with-Collision-Detection-带冲突检测的载波监听多点介接入技术">CSMA/CD (with Collision Detection, 带冲突检测的载波监听多点介接入技术)</h3><p>基本思想：</p><ol><li>载波监听；</li><li><strong>发送方</strong>检测冲突；</li><li>冲突检测：当发送方检测到冲突时，停止传输，并发送一个 <strong>Jam Signal(强化信号)</strong>；</li><li><strong>backoff 退避</strong>：当发送方接收到 <strong>Jam 强化信号</strong>后，等待一个随机时间在恢复发送；（目的是避免两个发送方同时检测到冲突并进行退避后，监听到信道空闲又发送导致再一次冲突）</li></ol><p>特点：</p><ol><li>信道是 <strong>Half-duplex 半双工</strong>，即同一时刻一个节点只能作为发送方或接收方，不能既发又收；</li><li>节省了时间和带宽；</li><li>是 <strong>Ethernet 以太网</strong>的基础；</li><li>属于 Unacknowledged connectionless service 无确认无连接的服务；</li></ol><blockquote><p><strong>Q</strong>：如何检测冲突？<br><strong>A</strong>：通过一条收线，同时从总线上接受信号，与发送的信号进行比较；由于需要较强的信号强度以及较为合适的调制技术，<strong>不适用于无线通信</strong>；</p><p><strong>Q</strong>：Vulnerable Time 脆弱期 = $2t_{prop}$；</p><p><strong>Q</strong>：等待重传的时间是多长？<br><strong>A</strong>：采用指数退避Binary Exponential Backoff Algorithm；</p></blockquote><h5 id="指数退避">指数退避</h5><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/4.png" alt=""></p><ul><li>最多尝试16次；</li><li>指数最多为10；</li><li>基础的退避时间 = 51.2usec；</li></ul><h4 id="Wireless-LAN-Protocols">Wireless LAN Protocols</h4><p>无线信道无法进行冲突检测（信号强度太小，不满足要求）；CSMA/CD不适用；</p><h5 id="隐藏终端-Hidden-Terminal">隐藏终端 Hidden Terminal</h5><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/5.png" alt=""></p><p>如上图，假如A、C都需要向B发送数据，但是A不在C的范围内，即C监听不到A，所以C会同时向B发送数据，导致接收方B冲突；</p><h5 id="Exposed-Terminal-暴露终端">Exposed Terminal 暴露终端</h5><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/6.png" alt=""></p><p>B向A发送数据，但C在B的范围内，C监听到B，错误地认为此时不能向D发送数据；</p><h5 id="MACA-Multiple-Access-Collision-Avoidance-冲突避免多路访问">MACA(Multiple Access Collision Avoidance, 冲突避免多路访问)</h5><p>MACA的实现步骤如下：</p><ol><li>发送方A发送一个 <strong>RTS(Request to Send, 请求发送)</strong> 帧给接收方B；<ul><li>RTS长度为30Bytes，包括数据包的长度信息；</li></ul></li><li>接收方B收到 RTS 后，回复一个 <strong>CTS(Clear to Send, 允许发送)</strong> 帧给发送方A；</li><li>当发送方A收到 CTS 后，开始发送数据；</li><li>接收方B收到数据后，回复ACK；</li></ol><ul><li>RTS和CTS用于<strong>预约信道</strong>，它们<em><strong>均包含待发送数据的长度</strong></em>，这能用于冲突检测，比如：</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/7.png" alt=""></p><ul><li>对于上图，A需要向B发送数据；<ul><li>其中C和E是暴露终端，D是隐藏终端；</li><li>A向B发送RTS，C和E都会收到；</li><li>B向A发送CTS，D和E都会收到；</li><li>C只收到了RTS，保持沉默；</li><li>D只收到了CTS，也保持沉默；</li><li>E既收到了RTS，又收到了CTS，但是收到RTS后，它认为下一个收到的数据长度应该是RTS中数据的长度，与CTS不符合，故也保持沉默；</li></ul></li></ul><p>如果两个站点A、B同时需要向站点E发送数据：</p><ol><li>A、B同时发送RTS；</li><li>接收方收到RTS后，只会回复先到达的RTS对应的CTS；</li><li>假如A站点成功收到CTS，B站点在一定时间范围内没有收到，那么B采用<strong>指数退避</strong>方式，等待一段时间后再进行尝试；</li></ol><h2 id="Controlled-multiple-access-控制介质访问控制">Controlled multiple access 控制介质访问控制</h2><ul><li>Centralized control：<strong>Polling 轮询</strong>，主站依次向从站发出请求；</li><li>Decentralized control：<strong>Token Passing 令牌</strong>，节点共同维护一个令牌；</li></ul><h1>LAN Reference Model: IEEE 802</h1><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/8.png" alt=""></p><ul><li>只包括物理层和数据链路层，同时将数据链路层 Data Link 进一步划分为 <strong>Logical Link Control(LCC, 逻辑链路控制)</strong> 和 <strong>Medium Access Control(MAC, 介质访问控制)</strong> ；</li><li><strong>LCC 逻辑链路控制子层</strong>：<ul><li>向网络层提供统一的接口；</li><li>流量控制；</li><li>差错控制；</li><li>Inter-connecting LANs with bridge 网桥；</li></ul></li><li><strong>MAC 介质访问控制子层</strong>：<ul><li>Framing 成帧；</li><li>差错检测；</li><li>Physical Address: e.g. MAC address；</li><li>多路访问控制；</li><li>LAN switching；</li></ul></li><li>不同的LAN，MAC子层不同，LCC子层相同；</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/9.png" alt=""></p><h1>Ethernet 以太网</h1><h2 id="Classic-Ethernet-Physical-Layer">Classic Ethernet: Physical Layer</h2><h3 id="Physical-Topology-物理拓扑结构">Physical Topology 物理拓扑结构</h3><ul><li>Bus 总线型；</li><li>Star 星型：通过 <strong>Hub 集线器</strong> 实现交换；<em><strong>物理上星型，逻辑上总线型</strong></em>；</li></ul><h3 id="Network-Interface-Card（NIC-网卡）">Network Interface Card（NIC, 网卡）</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/10.png" alt=""></p><h3 id="Hub-集线器">Hub 集线器</h3><p><code>100 Base -T X</code> ：</p><ul><li>100：传输速度，单位Mbps；</li><li>Base：调制技术，即基带传输，不需要进行调制；</li><li>T：传输媒介，T代表双绞线 Twisted Pair，F代表光纤 Fiber Optics；</li><li>X：编码方式，一般采用Manchester编码；</li></ul><p>常见的技术如下：<br><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/11.png" alt=""></p><ul><li>距离长用粗缆；</li></ul><h3 id="Repeater">Repeater</h3><ul><li>属于<strong>物理层</strong>的设备；</li><li>Half Duplex 半双工；</li><li>将两个总线型的以太网连接；</li></ul><h2 id="Classic-Ethernet-MAC-Sublayer-Protocol">Classic Ethernet: MAC Sublayer Protocol</h2><blockquote><p><strong>帧间隙 Inter Frame Gap</strong>：IFP，9.6us(对于10Mbps的以太网)；用于节点转换发送模式/接收模式；</p></blockquote><ul><li>广播式信道；</li><li>以太网采用 <strong>1 - persistant CSMA/CD</strong>；</li></ul><h3 id="Frame-Type">Frame Type</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/12.png" alt=""></p><ul><li>Data字段最多1500Bytes，最少46Bytes；不满足则用Pad字段填充；</li><li>MAC地址字段：<ul><li>6Bytes；</li><li>用 <code>FF:FF:FF:FF:FF:FF</code> 地址表示广播；</li></ul></li><li>Frame Length<ul><li>最多1518Bytes，其中1500Bytes为数据长度，18Bytes为控制地址长度；</li><li>最短64Bytes，其中46Bytes为数据长度；<ul><li>原因是以太网使用了CSMA/CD技术，需要有足够的时间检测冲突，否则会造成数据已经发送完成才检测到冲突；</li><li>$\frac{M_{min}}{B} = 2\tau = 51.2us$</li></ul></li></ul></li></ul><h2 id="Switched-Ethernet">Switched Ethernet</h2><h3 id="Hub-vs-Switch">Hub vs. Switch</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/13.png" alt=""></p><ul><li>Hub：一个节点来的信号会向别的所有节点转发；所有节点都在冲突域内，需要CSMA/CD；</li><li>Switch：不需要；</li></ul><h3 id="Switch-Ways">Switch Ways</h3><ul><li>Cut-Through 直通<ul><li>边收边转发；</li><li>无法检查数据帧是否错误；</li><li>输入/输出需要相同速率；</li></ul></li><li>Store-Forward 存储转发<ul><li>缓存整个数据帧后，检查没有碰撞/CRC错误帧后，再根据目的MAC地址进行转发；</li><li>支持差错检测；</li><li>支持不同输入/输出端口间的交换；</li></ul></li></ul><h2 id="Fast-Ethernet">Fast Ethernet</h2><p>从这里开始，主要介绍不同速率的以太网；经典以太网的速率是10Mbps，即10兆以太网；而快速以太网的速率为100Mbps，即百兆以太网，它的设计原则如下：</p><ul><li>向后兼容，即保持帧格式、接口等不变；</li><li>减少 bit time；</li><li>减少 Max Length of Cable，这个没办法，必要的牺牲；</li><li>Hub或者Switch两种方式都有；</li></ul><h3 id="Cabling">Cabling</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/14.png" alt=""></p><ul><li>不再使用同轴电缆；</li><li>100Base-T4<ul><li>信号频率为25MHz；</li><li>4 Twisted Pair（3UTP）</li><li>不使用Manchester编码，使用三元信号；6B/8T；</li></ul></li><li>100Base-TX<ul><li>信号频率为125MHz；</li><li>2 Twisted Pair（5UTP）；</li><li>编码4B/5B（125MHz * 4/5 = 100Mbps）；</li></ul></li><li>100Base-FX<ul><li>使用光纤；</li></ul></li></ul><blockquote><p><strong>注</strong>：如果用到 Full-Duplex 全双工，即收发是两条线（区分于 Half-Duplex 半双工，收发一条线），不会产生冲突，所以不需要CSMA/CD；</p></blockquote><h3 id="Autonegotiation-自动协商机制">Autonegotiation 自动协商机制</h3><p>两个不同的以太网之间自动选择相同的参数（即 Speed 和 Duplex Mode）进行配置；</p><h2 id="Gigabit-Ethernet">Gigabit Ethernet</h2><p>Gbit以太网，速度又快了10倍；设计原则如下：</p><ul><li>无ACK，发了就完了，不需要应答；</li><li>48-bit的地址格式不变；</li><li>帧格式不变（但进行了拓展，不然最大电缆长度太短了）；</li><li>同样分为 Switch(Full-Duplex，最大电缆长度取决于信号衰减程度)和 Hub(Half-Duplex，存在冲突)；</li></ul><h3 id="Cabling-2">Cabling</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/15.png" alt=""></p><h3 id="Carrier-Extension-载波扩展">Carrier Extension 载波扩展</h3><p>我们知道，由于CSMA/CD技术需要满足：</p><p>$$<br>\frac{M_{min}}{B} = 2\tau = 51.2us<br>$$</p><p>如果不进行扩展，最大电缆长度仅为约25m；所以需要进行扩展（填充无用的比特），将数据长度扩展为<strong>512Bytes</strong>；当然，也可以通过 <strong>Frame Bursting 帧突发</strong>，具体在下一节介绍；</p><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/16.png" alt=""></p><h3 id="Frame-Bursting-帧突发">Frame Bursting 帧突发</h3><p>上述扩展方法，对信道效率存在严重的浪费。如果对于有大量需要连续发送的帧的情况，帧的发送往往用队列存储，发送方可以将需要连续发送的帧拼成一个帧进行发送。</p><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/17.png" alt=""></p><ul><li>第一个帧采用载波扩展；</li><li>剩余的帧直接连续发送，注意帧之间有帧间隙；</li></ul><h3 id="Flow-Control">Flow Control</h3><p>Gigabit Ethernet确实能显著提升传输速度，但是也存在问题，由于发送速度很快，但是接收方突然因为别的任务CPU过忙了1ms，就会导致1953个帧堆积；并且由于它是无连接的，不需要ACK，所以极易造成缓存溢出；</p><p>一种方法是，设计一个特殊的控制帧 <strong>Pause Frame</strong>(0x8808)，如果接收方缓存不足，它会发送该帧给发送方，阻止另一方继续发送数据；</p><h2 id="10G-Ethernet">10G Ethernet</h2><ul><li>一般用于 <strong>Local Backbone 本地骨干网</strong>；</li><li>只支持 Full-Duplex 全双工；</li><li>支持 Autonegotiation 自动协商；</li></ul><h3 id="Cabling-3">Cabling</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/18.png" alt=""></p><h2 id="Summary">Summary</h2><ul><li>1 - persistent CSMA/CD(如果使用Switch则不需要冲突检测)；</li><li>MAC address = 48bits；</li><li>Frame Size = 64Bytes ～ 1518Bytes；<ul><li>Data Size = 46Bytes ～ 1500Bytes；</li></ul></li><li>Hub and Switch；</li><li>经典以太网、高速以太网；</li><li>Topology 拓扑结构：总线型(只有经典以太网使用)、星型；</li><li>物理层编码：<strong>Manchester编码(经典以太网使用，百兆以太网之后就不再使用)</strong>、8B/6T、4B/5B；</li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/19.png" alt=""></p><h1>Wireless LANS 无线网络</h1><h3 id="802-11-LAN-architecture">802.11 LAN architecture</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/20.png" alt=""></p><ul><li>AP: Access Point；<ul><li>AP与外部设备(路由器/交换机)之间采用有线连接；</li></ul></li><li>BSS: Basic Service Set；<ul><li>内部设备之间采用无线通信；</li><li>通过AP接入外部网络；</li></ul></li></ul><h3 id="Mac-Sublayer">Mac Sublayer</h3><p>在无线通信中，无法通过 Collision Detection 检测冲突（之前讲过，信号太弱以及调制技术限制）；在802.11无线局域网标准中，MAC子层提供了两种信道接入模式：</p><ul><li><strong>Point coordination function(PCF, 点协调功能, 集中式)</strong><ul><li>由 <strong>Base Station 基站(即 AP)</strong> 作为点协调控制者；</li><li>通过 <strong>Polling 轮询</strong>，为各个站点分配信道访问权，即AP按照预设的顺序依次询问每个站点是否需要发送数据；</li><li>基站广播一个 <strong>beacon frame 信标帧</strong>（包括系统参数，是够允许发言等信息）；</li></ul></li><li><strong>Distributed coordination function(DCF, 分布协调功能, 分布式)</strong><ul><li>没有中央控制者；</li><li>通过 <strong>CSMA/CA(CSMA with Collision Avoidance)</strong> 技术避免冲突；</li></ul></li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/21.png" alt=""></p><h4 id="CSMA-CA">CSMA/CA</h4><p>for 802.11 Sender, if it needs to send a frame:</p><ol><li>通过载波监听等待直到信道空闲，并在等待 <strong>DIFS</strong> 的时间（即在 DIFS 时间内信道空闲，才认为信道空闲，能发送数据）；</li><li>随机退避（0 ～ 15 个时间槽），如果信道上有数据发送则停止计时器；知道计时器为0时发送帧；</li><li>如果没有收到ACK，那么采用指数退避，加倍退避时间；</li></ol><p>for 802.11 Receiver:</p><ol><li>如果正确接收到帧，则等待 <strong>SIFS</strong> 的时间后回复ACK；</li></ol><blockquote><p><strong>注</strong>：$t_{SIFS} &lt; t_{DIFS}$，这能保证 <em><strong>ACK 的优先级更高</strong></em>；<br>事实上，通过为不同类型的帧设置不同长度的 <strong>IFS 帧间隔</strong>，来实现<strong>优先级</strong>服务；</p></blockquote><p>CSMA/CA 有以下两种监听模式：</p><ul><li>Physical Sense：物理意义上的监听信道；</li><li>Virtual Sense：虚拟监听；<ul><li>每个站点都记录一个 NAV(Network Allocation Vector, 网络分配向量)；</li><li>每个帧都携带一个 NAV；</li><li>NAV 表示这个数据帧将预计占用信道多长时间，通过 NAV 来确定退避时间，减少冲突；</li></ul></li></ul><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/22.png" alt=""></p><h4 id="Fragment-Burst-段突发">Fragment Burst 段突发</h4><p>如果信道的误码率较高，那么 ACK 和重传的作用较小；而短帧出错概率小，所以采用 <strong>Fragment burst 段突发</strong> 的方式，将较长的帧分为小的 Fragment进行发送，来提高可靠性；<br><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/23.png" alt=""></p><h4 id="Saving-Power-省电模式">Saving Power 省电模式</h4><p><img src="/2025/04/04/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/24.png" alt=""></p><h4 id="TXOP-Transmission-Opportunities">TXOP(Transmission Opportunities)</h4><p>如果两个站点产生竞争，原始的 CSMA/CA 采用频繁竞争，即每次发送都进行竞争，谁竞争成功了谁发，但这样会导致速率异常，假设站点的带宽分别为 $c_1,c_2$，则平均数据率为：</p><p>$$<br>\frac{1}{c_{ave}} = \frac{1}{c_1} + \frac{1}{c_2} \Rightarrow c_{ave} = \frac{1}{\frac{1}{c_1} + \frac{1}{c_2}}<br>$$</p><p>即平均数据率小于任何一个站点，造成速率异常。而 TXOP 给予两个站点相同的发送机会，即竞争一次，获得一段传输时间，即</p><p>$$<br>c = c_i / n<br>$$<br>比如对于 6Mbps 和 54Mbps 的两个站点，采用TXOP后，按照 3Mbps 和 27Mbps 发送帧；</p><h4 id="Frame">Frame</h4><ul><li>Data Frame</li><li>Control Frame<ul><li>RTS</li><li>CTS</li><li>ACK</li></ul></li><li>Management Frame<ul><li>Authentication and De-authentication</li><li>Association</li><li>Beacon and Probe Frame</li></ul></li></ul><h5 id="Data-Frame">Data Frame</h5>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组学习笔记(5)：指令系统</title>
    <link href="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1>指令分类</h1><ul><li><strong>微指令</strong>：微程序级的命令，属于硬件；</li><li><strong>机器指令</strong>：介于微指令与宏指令之间，单独一题哦啊即可完成一个独立的算术/逻辑运算；</li><li><strong>宏指令</strong>：有若干条机器指令组成的软件指令，属于软件；</li></ul><blockquote><p><strong>注</strong>：<strong>指令系统ISA(Instruction Set Architecture)</strong>，也称指令集架构；</p><blockquote><p>包含了所有机器指令的集合；<br>定义机器级程序的格式和行为，以及处理器状态；<br>指令系统有如下要求：<br>完备性；<br>有效性；<br>规整型：</p><blockquote><p>对称性：寄存器和存储器单元同等对待，都可以使用各种寻址方式；<br>匀齐性：一种操作性质的指令可以支持各种数据类型；<br>一致性：指令长度与数据长度有一定关系；<br>兼容性：<strong>向后兼容</strong>，即旧处理上运行的软件仍可以在新处理器上运行；</p></blockquote></blockquote></blockquote><h1>指令格式</h1><ul><li>指令字，即指令，指表示一条指令的机器字；</li><li>指令格式是指令字用二进制表示的结构形式；</li><li>指令的构成：<ul><li>操作码OP字段：长度取决于指令集的规模；</li><li>地址码字段：指定参与操作的操作数的地址，1条指令地址码部分有$x$个操作地址，则称该指令为$x$操作数指令或$x$地址指令；</li></ul></li><li>按照操作数的物理位置不同，指令分为：<ul><li>存储器-存储器（SS）型指令：即操作数都存在内存中；</li><li>寄存器-寄存器（RR）型指令：即操作数都存在寄存器中，不需要访问内存；</li><li>寄存器-存储器（RS）型指令；</li></ul></li><li>按指令字长度分类：<ul><li>单字长指令；</li><li>半字长指令；</li><li>双字长指令；</li><li>注：多字长指令能提供更大的地址空间，但必须多次访问内存取出一整条指令；</li><li>等长指令字结构 vs. 变长指令字结构；</li></ul></li><li>扩展操作码指令格式：其中，前缀1111作为特征位，用于区分这是几地址指令；<img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/1.png" alt=""></li><li>指令助记符：<ul><li>助记符 $\rightarrow$ 二进制操作码：汇编（汇编器实现）；</li><li>二进制操作码 $\rightarrow$ 助记符：反汇编；</li></ul></li></ul><h1>指令和数据的寻址方式</h1><p>在存储器中，读/写操作数/指令字的方式有：</p><ul><li>地址指定方式；</li><li>相联存储方式（按内容寻址）；</li><li>堆栈存取方式；</li></ul><h2 id="地址指定方式">地址指定方式</h2><h3 id="指令寻址方式">指令寻址方式</h3><h4 id="顺序寻址方式">顺序寻址方式</h4><p>通过<strong>程序计数器PC</strong>来计数指令的顺序号，该顺序号就是指令在内容中的地址；</p><h4 id="跳跃寻址方式">跳跃寻址方式</h4><p>用于实现条件转移、无条件转移和子程序调用等；</p><h3 id="操作数寻址">操作数寻址</h3><p>形成操作数有效地址的方法，称为操作数寻址方法；<br>一种单地址指令的结构如下：<br><img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/2.png" alt=""></p><ul><li>操作数地址由变址X、间址I、形式地址A(也称偏移量offset)组成；</li></ul><h4 id="隐含寻址">隐含寻址</h4><p>隐含默认地给出操作数的地址；</p><h4 id="立即寻址">立即寻址</h4><p>地址码字段是操作数本身而不是操作数的地址(<strong>立即数</strong>)；</p><h4 id="直接寻址">直接寻址</h4><p>在地址码字段直接给出操作数在内存中的地址A；即形式地址A就是操作数的有效地址EA：<br>$$<br>EA = A<br>$$</p><h4 id="间接寻址">间接寻址</h4><p>在地址码字段给出的是操作数地址的地址，需要两次访存，即：<br>$$<br>EA = (A)<br>$$</p><blockquote><p><strong>注</strong>：一般用寻址特征位 $I$ 区分两种方式，$I = 0$表示直接寻址，$I = 1$表示间接寻址；</p></blockquote><h4 id="寄存器寻址">寄存器寻址</h4><p>操作数地址并不是内存的地址，而是寄存器的编号；地址码字段直接取指定寄存器的内容，就是操作数；</p><h4 id="寄存器的间接寻址">寄存器的间接寻址</h4><p>地址码字段指定的寄存器的内容是操作数的地址；</p><h4 id="偏移寻址">偏移寻址</h4><h5 id="相对寻址">相对寻址</h5><p>程序计数器PC的内容加上偏移量A(有符号数)形成操作数的有效地址；<br><img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/3.png" alt=""></p><h5 id="基址寻址">基址寻址</h5><p>基址寄存器的内容加上偏移量A(有符号数)形成操作数的有效地址；<br><img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/4.png" alt=""></p><h5 id="变址寻址">变址寻址</h5><p>变址寄存器的内容加上偏移量A(有符号数)形成操作数的有效地址；其中变址寄存器的内容会自动递增或递减；</p><h3 id="段寻址方式">段寻址方式</h3><p><img src="/2025/04/04/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(5)%EF%BC%9A%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/5.png" alt=""></p><ul><li>段寄存器左移4位形成20位物理地址；</li></ul><h3 id="堆栈寻址">堆栈寻址</h3><h4 id="寄存器堆栈">寄存器堆栈</h4><ul><li><strong>栈顶不动，数据移动</strong>；</li><li>数据的读出具有破坏性；</li><li>堆栈大小受限；</li></ul><h4 id="存储器堆栈">存储器堆栈</h4><p>在主存中划分出一片堆栈区域，CPU用一个专门的寄存器 SP（Stack Pointer，栈顶指示器）存储栈顶的位置；</p><ul><li><strong>栈顶移动，数据不动</strong>；</li><li>堆栈空间可以自行分配；</li><li>栈顶指示有2种方式：<ul><li>SP 指向空单元；</li><li>SP 指向满单元；</li></ul></li></ul><h1>CISC(Complex Instruction Set Computing, 复杂指令集)计算机</h1><ul><li>指令系统庞大；</li><li>指令长度不固定；</li><li>指令格式复杂；</li><li>寻址方式多；</li><li>通用寄存器数量少；</li><li>各种指令的指令时间相差很大；</li><li>各种指令的使用频度相差较大；</li><li>使用微程序控制器；</li></ul><h1>RISC(Reduced Instruction Set Computing, 精简指令集)计算机</h1><ul><li>选取使用频率最高的一些简单指令，指令数量少；</li><li>指令长度固定；</li><li>指令格式种类少；</li><li>寻址方式简单；</li><li>只有 Load / Store 指令访问存储器，其他均在寄存器之间进行；</li><li>通用寄存器数量较多，减少访存次数；</li><li>大部分指令在一个机器周期内完成；</li><li>使用硬布线控制器；</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组学习笔记(4)：存储系统I</title>
    <link href="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/"/>
    <url>/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/</url>
    
    <content type="html"><![CDATA[<h1>存储器的分类</h1><ul><li>按照介质分类：<ul><li>半导体存储器、磁介质存储器、光存储器；</li></ul></li><li>按照存储器与CPU的耦合程度：<ul><li>内存（主存 + cache）、外存；</li></ul></li><li>按照存储器的读写功能：<ul><li>读写存储器RWM；</li><li>只读存储器ROW；</li></ul></li><li>按照掉电后存储的信息是否保持：<ul><li>易失性；</li><li>非易失性；</li></ul></li><li>按照数据存取的随机性：<ul><li>随机存取RAM：指随机给定一个地址就可以拿到数据并与前一个访问的地址无关；</li><li>顺序存取SAM：比如磁带；</li><li>直接存取DAM：确定区域后顺序存取；</li></ul></li><li>按照半导体存储器的信息存储方法：<ul><li>静态Static；</li><li>动态Dynamic；</li></ul></li><li>习惯分类：<ul><li>RAM vs. ROM；</li><li>SRAM vs. DRAM(内存条) vs. 闪存；</li><li>MASK ROM(掩膜) vs. PROM(可编程)；<ul><li>EPROM(可擦除PROM)<ul><li>紫外线擦除；</li><li>电擦除；</li></ul></li></ul></li></ul></li></ul><h1>存储器目标</h1><ul><li>大容量；</li><li>高速度；</li><li>低价格；</li></ul><h2 id="层次结构存储器系统">层次结构存储器系统</h2><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/1.png" alt=""></p><h2 id="并行技术">并行技术</h2><ul><li>单体多字：一个读写体，每次存取多个字；</li><li>多体单字：多个读写体，交叉编址，向多个地址读取内容；</li></ul><h2 id="存储容量">存储容量</h2><p>存储容量 = 存储字数（存储单元数） $\times$ 存储字长（每单元的比特数）</p><h2 id="存取速度">存取速度</h2><ul><li>访问时间/存取时间$T_A$：从启动一次存储器操作到该操作完成所经历的时间，即从存储器接收到读/写命令到信息被读出或写入完成所需的时间；</li><li>存取周期$T_m$：存储器在连续读写过程中，完成一次完整的读/写操作所需的全部时间，即CPU连续两次独立访问存储器的最小时间间隔；</li><li>存储器带宽：单位时间内能传输的信息量；</li></ul><blockquote><p><strong>注</strong>：存取周期$T_m$一般大于存取时间$T_A$，因为存储器完成读/写操作后一般需要一段恢复内部状态的复原时间，即$存取周期 = 存取时间 + 恢复时间$；</p></blockquote><h1>SRAM</h1><h2 id="基本结构">基本结构</h2><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/2.png" alt=""><br><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/3.png" alt=""></p><h2 id="基本时序">基本时序</h2><h3 id="读周期">读周期</h3><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/4.png" alt=""></p><h2 id="写周期">写周期</h2><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/5.png" alt=""></p><h1>只读存储器</h1><h2 id="特点">特点</h2><ul><li>只能读出，不能写入；</li><li>不易失；</li><li>只读存储器写入数据的过程称为对其<strong>编程</strong>；</li></ul><h2 id="分类">分类</h2><ul><li>掩模式只读存储器：不能进行重写；</li><li>一次可编程只读存储器PROM：<ul><li>双极型PROM：<ul><li>熔丝烧断型；</li><li>PN结击穿型；</li></ul></li></ul></li><li>多次可编程只读存储器；<ul><li>光擦除EPROM：利用<strong>雪崩注入</strong>，擦除是对<strong>所有</strong>存储单元进行，不能实现选择性擦除；</li><li>电擦除EEPROM/E$^2$PROM；</li><li>电改写EAROM；</li></ul></li><li>闪存Flash Memory；<ul><li>NAND闪存：只允许顺序<strong>按页(Page)存取</strong>数据；<img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/6.png" alt=""></li><li>NOR闪存：具有完整地址/数据结构，能快速随机地读取任一单元；</li></ul></li></ul><blockquote><p><strong>NAND vs. NOR</strong><br><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/7.png" alt=""></p></blockquote><blockquote><p><strong>注</strong>：任何计算机必须有ROM，即必须要有经过编程的ROM（称为<strong>Bios</strong>，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序），用于计算机程序的初始装入，如果都是RAM，那么计算机初始状态下根本不存在程序和数据；</p></blockquote><h1>并行存储器</h1><h2 id="双端口存储器DPRAM">双端口存储器DPRAM</h2><h3 id="基本结构-2">基本结构</h3><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/8.png" alt=""></p><h3 id="实例：IDT7133">实例：IDT7133</h3><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/9.png" alt=""></p><blockquote><p><strong>注</strong>：其中Busy Flag用于控制能否访问，防止左右端口同时访问同一个地址造成冲突；Busy = 0表示不能访问；仲裁方式如下：</p></blockquote><p><img src="/2025/04/03/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%EF%BC%9A%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9FI/10.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云ESC + V2RayA实现科学上网</title>
    <link href="/2025/04/03/%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <url>/2025/04/03/%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>因为个人的阿里云国内服务器偶遇运营商垃圾跨境节点导致连接github及其不稳定，所以有了这篇帖子；</p></blockquote><h1>环境</h1><blockquote><p>操作系统：Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-202-generic x86_64)<br>云服务器：阿里云ESC<br>代理客户端：V2RayA，优点是适用于无图形化的操作系统；</p></blockquote><h1>V2RayA 简介</h1><blockquote><p>一个易用而强大的，跨平台的 V2Ray 客户端<br>使用 Golang 和 Vue.js 编写，运行时没有任何外部依赖库，可跨平台运行，借助任意一款浏览器均可操作；<br>对于无图形界面的操作系统，打开它提供的 Web UI 就能完成配置工作，对于远程服务器及其友好；</p></blockquote><h1>V2RayA 安装</h1><p>演示通过软件源安装，其他安装方法和操作系统请参考：<a href="https://v2raya.org/docs/prologue/installation">请选择你的英雄</a></p><blockquote><p><strong>添加公钥</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -qO - https://apt.v2raya.org/key/public-key.asc | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/keyrings/v2raya.asc<br></code></pre></td></tr></table></figure><blockquote><p><strong>添加 V2RayA 软件源</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [signed-by=/etc/apt/keyrings/v2raya.asc] https://apt.v2raya.org/ v2raya main&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/v2raya.list<br><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure><blockquote><p><strong>安装 V2RayA</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install v2raya v2ray<br></code></pre></td></tr></table></figure><p>出现以下信息，说明安装成功：<img src="%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/1.png" alt=""></p><h1>启动 V2RayA</h1><blockquote><p><strong>启动 V2RayA</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start v2raya.service<br></code></pre></td></tr></table></figure><blockquote><p><strong>设置 V2RayA 为开机自启动</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> v2raya.service<br></code></pre></td></tr></table></figure><blockquote><p><strong>检查V2RayA 启动状态</strong></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl status v2raya.service<br></code></pre></td></tr></table></figure><p>如果看到类似以下信息，说明启动成功：<img src="%E9%98%BF%E9%87%8C%E4%BA%91ESC%20+%20V2RayA%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/2.png" alt=""></p><h1>V2RayA 配置</h1>]]></content>
    
    
    <categories>
      
      <category>开发心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式语言与自动机学习笔记(2)</title>
    <link href="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<h1>正则集和正则式</h1><ul><li>正则集：字母表上一些特殊形式的字符串的集合，是正则式说表示的集合；</li><li>正则式：用类似代数表达式的方式表示正则语言；</li><li>运算：（按照运算优先级从高到低排序）<ul><li>$*$(closure)闭包；</li><li>$\cdot$ (concatenation)连接；</li><li>$+$ (union)联合</li></ul></li></ul><p>注：</p><ul><li>正则式相等等价于正则集相等；</li><li>一个正则式对应一个正则集，但一个正则集可能有多个正确的正则式；</li></ul><h1>右线性文法与正则式</h1><p>右限性文法又称正则文法。右线性文法和正则式都可以用代表正则语言；</p><h2 id="从右线性文法导出正则式">从右线性文法导出正则式</h2><p>设$x \rightarrow \alpha x + \beta(\Leftrightarrow x \rightarrow \alpha x 和x\rightarrow \beta)$，其中$\alpha \in T^<em>,\beta \in (N + T)^</em>,x\in N$，则：$x$的解为$x = \alpha^*\beta$；</p><h1>正则集与右线性文法</h1><ul><li>正则集是由右线性文法产生的语言；</li><li>右线性文法产生的语言都是正则集；</li><li>一个语言是正则集，当且仅当该语言问右线性语言；</li></ul><h1>正则式与有限自动机</h1><h2 id="从DFA构造等价的正则表达式">从DFA构造等价的正则表达式</h2><h3 id="状态消去法">状态消去法</h3><p><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/1.png" alt=""></p><p>具体步骤：<br><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/2.png" alt=""></p><h2 id="从正则式构造等价的-epsilon-NFA">从正则式构造等价的$\epsilon$-NFA</h2><h3 id="归纳构造法">归纳构造法</h3><p><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/3.png" alt=""><br><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/4.png" alt=""><br><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/5.png" alt=""></p><h1>右线性语言与有限自动机</h1><p><strong>定理</strong>：由任意右线性文法定义G定义的语言必然能被一个NFAM所接受，即$L(G) = L(M)$；</p><h2 id="构造与右线性文法等价的NFA">构造与右线性文法等价的NFA</h2><p><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/6.png" alt=""></p><p><strong>省流</strong>：</p><ol><li>新增一个状态作为终止状态；</li><li>对仍在扩展非终结符的生成式，则转移到对应状态；</li><li>对到达终结符的生成式，则转移到新增的结束状态；</li><li>结束状态不存在转移；</li></ol><h2 id="构造能接受NFAM定义的语言的有限性文法">构造能接受NFAM定义的语言的有限性文法</h2><p><img src="/2025/03/31/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)/7.png" alt=""></p><h1>DFA的极小化</h1><p>填表法；</p><h1>Pumping定理</h1><p>判定正则语言的必要条件；<br><strong>定理</strong>：设$L$是正则集，存在常数$n$，对字符串$\omega \in L$且$\left | \omega \right | &gt; n$，则$\omega$可以写成$\omega_1\omega_o\omega_2$，其中$\left | \omega_1 \omega_0\right | \le n$，$\left | \omega_0\right | &gt; 0$，对所有的$i \ge 0$，有$\omega_1\omega_0^i\omega_2 \in L$；</p><p>显然，该定理可以用来证明某个语言不是正则语言；</p><p><strong>证明步骤</strong>：</p><ol><li>对于足够大的n；</li><li>找到一个满足以下条件的串$\omega \in L$（串长至少为n）；</li><li>任选满足$\omega = \omega_1\omega_o\omega_2$，其中$\left | \omega_1 \omega_0\right | \le n$，$\left | \omega_0\right | &gt; 0$；</li><li>找到一个$i$，使得$\omega_1\omega_0^i\omega_2 \notin L$；</li></ol>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组学习笔记(2)：运算方法与运算器II</title>
    <link href="/2025/03/22/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/"/>
    <url>/2025/03/22/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/</url>
    
    <content type="html"><![CDATA[<h1>原码乘法运算</h1><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/1.png" alt=""></p><h2 id="部分积">部分积</h2><p>每次提$2^{-1}$，即右移1位：<br><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/2.png" alt=""></p><h1>原码除法运算</h1><h2 id="加减交替法">加减交替法</h2><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/3.png" alt=""></p><h1>浮点数的表示方法</h1><p>一个任意进制数$N$可以表示为：<br>$$<br>N = M \times R^E<br>$$</p><p>其中：</p><ul><li>$M$表示尾数，是一个小数；</li><li>$E$表示阶码/指数，是一个整数；</li><li>$R$表示基数，一般为2，8，16；</li></ul><p>尾数的有效数字位数决定了浮点数的表示精度；阶码的有效数字位数决定了浮点数的表示范围；<br><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/4.png" alt=""></p><h2 id="浮点数的规格化表示">浮点数的规格化表示</h2><p>对于基数为$R$的规格化浮点数，要求其尾数的绝对值范围：<br>$$<br>\frac{1}{R} \le |M| &lt; 1<br>$$</p><p>对于原码表示的浮点数，即要求最高数值位为1；<br><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/5.png" alt=""></p><h2 id="IEEE-754浮点数标准">IEEE 754浮点数标准</h2><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/6.png" alt=""></p><ul><li>e，阶：用移码表示，即$E = Exp - (2^{n - 1} - 1)$</li><li>Frac，小数字段：<ul><li>规格化数表示：$M = 1 + Frac$；</li><li>非规格化数表示：$M = Frac$；</li></ul></li></ul><h3 id="特殊的浮点数表示">特殊的浮点数表示</h3><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/7.png" alt=""></p><h3 id="浮点数可表示的数值范围">浮点数可表示的数值范围</h3><p><img src="%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/8.png" alt=""></p><h1>浮点数的加减法</h1><h2 id="步骤">步骤</h2><p>$$<br>x\pm y = (M_x 2^{E_x - E_y} \pm M_y)2^{E_y},E_x \le E_y<br>$$</p><ol><li>检查操作数是否为0；</li><li>对阶：小阶向大阶对齐；</li><li>用双符号位的尾数进行加减运算；</li><li>规格化：<ol><li>如果双符号位出现01、10的非法值，则向右规格化直至合法；</li><li>检查是否符合规格化小数的要求，向左规格化直至合法；</li></ol></li><li>舍入（可能再次规格化）：向偶数舍入；</li></ol><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');});</script>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网学习笔记(3)：数据链路层</title>
    <link href="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p>数据链路层对实际在物理层中传输的信号起到差错控制和流量控制的作用，特别是在广播信道中，需要解决多个发送方同时发送信号造成的共享信道冲突，一般由接受方控制发送方。</p><h1>Technologies</h1><h2 id="Framing">Framing</h2><h3 id="定义">定义</h3><p>Encapsulates network packet into a frame，封装成帧，即将网络层发送的Packet加上Header和Trailer，组成Frame。</p><h3 id="要求">要求</h3><p>由于数据链路层间是虚拟通信，实际信号传输通过物理层传输01比特串，这要求数据链路层从01比特串中能正确识别出帧（<em><strong>帧同步</strong></em>）。</p><ul><li>Simple，容易实现；</li><li>Code Independent，加上的内容与传输的消息内容无关；</li><li>Efficient，所用信号带宽尽量小；</li><li>Robustness，出错后能重新同步；</li></ul><h3 id="方式">方式</h3><h4 id="Character-Count-字符计数法">Character Count 字符计数法</h4><p>在每帧之前加上一个字符表示帧的长度，一错后面都错；</p><h4 id="Byte-Stuffing-字符填充法">Byte Stuffing 字符填充法</h4><p>用特定的标志表示帧的开始和结束：<img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/2.png" alt=""></p><p>如果帧的其他控制和数据部分含有帧的开始符或结束符怎么办？——<em><strong>Transparent Transmission透明传输</strong></em><br><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/3.png" alt=""></p><p>即：如果中间含有Flag，在Flag之前插入1个ESC；如果中间含有ESC，在ESC前面插入1个ESC；</p><h4 id="Bit-Stuffing-比特填充法">Bit Stuffing 比特填充法</h4><ol><li>用连续的6个1表示开始和结束标志：01111110；</li><li>中间部分，在从左到右每出现5个1之后插入1个0，可以有效避免中间部分被识别为开始符或结束符，且容易解码；</li></ol><h4 id="Physical-Layer-Coding-Violations-物理层编码违例法">Physical Layer Coding Violations 物理层编码违例法</h4><p>适用于比较特殊的编码，比如Manchester编码，用没有出现跳变的信号表示开始符和结束符；</p><h2 id="Error-control">Error control</h2><h3 id="基本概念">基本概念</h3><h4 id="Error-Types">Error Types</h4><ul><li>Lost Frames；</li><li>Damaged Frames；</li></ul><h4 id="Error-Detection-检错">Error Detection 检错</h4><ul><li>Parity Check 奇偶校验：单冗余码；</li><li>Cyclic Redundancy Check(CRC) 循环检错；</li><li>Checksum：在网络层中；</li></ul><h4 id="Error-Correction-纠错">Error Correction 纠错</h4><p>Error Correction Code(ECC) 纠错码，分为：</p><ul><li><em><strong>Forward Error Correction(FEC) 前向纠错</strong></em>：例如汉明编码；</li><li><em><strong>Automatic Repeat reQuest(ARQ) 自动重传请求</strong></em>：检错+重传；</li><li><em><strong>Hybrid Error Correction(HEC) 混合纠错</strong></em>；</li></ul><h4 id="Single-bit-Error-vs-Burst-Error">Single-bit Error vs. Burst Error</h4><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4.png" alt=""></p><p><em><strong>注意下图中突发错误的长度为5：从第一个错误的到最后一个错误的比特数</strong></em>；</p><h3 id="ECC纠错码：汉明距离">ECC纠错码：汉明距离</h3><p>在所有合法的码字中：</p><ul><li>如果需要检测出 t 位比特错误，需要最小汉明距离为 t + 1；</li><li>如果需要纠正出 t 位比特错误，需要最小汉明距离位 2t + 1；</li></ul><h4 id="The-Num-of-Check-Bits-to-Correct-Single-Bit-Error">The Num of Check Bits to Correct Single Bit Error</h4><p>只考虑纠正一位错误：</p><ul><li>$m$：原始信息长度；</li><li>$r$：check bits，即需要增加的校验位长度；</li><li>$n$：码字长度，即$n = m + r$；</li></ul><p>根据原始信息长度，推出存在$2^m$个合法信息，每一个合法信息按照$n$的码字传输，能产生和它有一位比特差错的种类有$n$个，所有共有$(n + 1)2^m$个码字；<br>$n$位码字的种类共有$2^n$个，所以要求：</p><p>$$<br>(n + 1)2^m \le 2^n \Leftrightarrow m + r + 1 \le 2^r<br>$$</p><h4 id="汉明编码：Correction-of-Single-Bit-Error">汉明编码：Correction of Single Bit Error</h4><ul><li>只允许在$2^i$位置处放置校验位Check Bits；</li><li>剩下的位置填充数据位；</li></ul><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/5.png" alt=""><br><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/6.png" alt=""></p><h3 id="Error-Detection-Code">Error Detection Code</h3><h4 id="Even-Parity-Checking-偶校验">Even-Parity Checking 偶校验</h4><h4 id="Polynomial-Code-多项式编码">Polynomial Code 多项式编码</h4><p>也称为<em><strong>CRC(Cyclic Redundancy Check，循环冗余校验)</strong></em> 或 <em><strong>FCS(Frame Check Sequence，帧校验序列)</strong></em> ；</p><ul><li>$M(x)$：将要传输的比特看成多项式，比如：$110001 \Rightarrow x^5 + x^4 + x^0$；</li><li>运算定义为模2运算，即$x + y = x - y = x\oplus y$；</li><li>$G(x)$：生成多项式；</li></ul><h5 id="计算过程">计算过程</h5><ol><li>$M(x) * x^r$，即在传输的数据右边增加$r$个0；</li><li>$M(x) * x^r / G(x) \cdots R(x)$，即作除法后得到余数多项式$R(x)$；</li><li>Sender发送方：$T(x) = M(x) * x^r + R(x) = M(x) * x^r - R(x)$；</li><li>Receiver接收方：$T(x) / G(x)$，余数一定为0；</li></ol><h5 id="检查过程">检查过程</h5><ol><li>接收方如果收到错误的信息，即$T(x) + E(x)$；</li><li>正常不出错的情况下，$T(x) / G(x)$余数为0；</li><li>出错的情况下，结果为$E(x) / G(x)$的余数；</li><li>能捕捉到所有的错误；</li></ol><h2 id="Flow-control">Flow control</h2><h3 id="Flow-Control-Protocols">Flow Control Protocols</h3><h4 id="Elementary-Protocols">Elementary Protocols</h4><ul><li><em><strong>Utopian Simplex Protocol 乌托邦单工协议</strong></em>；<ul><li>通信是单通的；</li><li>通信是无错的；</li><li>接收方缓存空间无限；</li><li>无需差错控制和流量控制；</li></ul></li><li>***Simplex Stop-and-Wait Protocol for Error-Free Channel 停等协议<ul><li>通信是单通的；</li><li>通信是无错的；</li><li>接收方缓存空间有限；</li><li>需要流量控制：Stop-and-Wait<ul><li>发送方发送一个Frame，等待；</li><li>接收方如果正确收到信息，发送一个<em><strong>ACK(Acknowledgement，应答)</strong></em>；</li><li>发送方接收到ACK后，发送下一个Frame；</li></ul></li><li>如果通信不可靠，会产生如下问题：帧错误、帧丢失或ACK丢失<img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/7.png" alt=""></li><li>其中，如果ACK丢失，发送方会在超时后发送第二个相同的帧，但是接收方并不知道！解决方法：<em><strong>Sequence Number</strong></em>；</li></ul></li><li><em><strong>Protocol 3: Positive ACK with Retransmission(PAR) 带有重试的主动确认协议</strong></em><ul><li><em><strong>ARQ(Automatic Repeat reQuest) 自动重传请求</strong></em><ul><li>在每个Frame之前添加序号，来区分该Frame是重传的还是新的；</li><li>链路层只需要1bit，即编号空间大小为2；</li><li>传输层需要更大的编号空间；</li><li>但是还是有问题：如果ACK传输延迟了，如下图所示，那么当那个重复发送的Frame0收到后返回给发送方时，发送方认为这是Frame1的应答信号，错误地认为Frame1已经正确发送到接收方；<img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/8.png" alt=""></li><li>所以需要给ACK也添加序号：<img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/9.png" alt=""></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SEQ 1</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> <br>frame_arrival, <br>cksum_err, <br>timeout <br>&#125; event_type;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;protocol.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span> &#123;<br>seq_nr next_frame_to_send = <span class="hljs-number">0</span>;<br>frame s;<br>packet buffer;<br>event_type event;<br><br>from_network_layer(&amp;buffer);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>s.info = buffer;<br>s.seq = next_frame_to_send;<br>to_physical_layer(&amp;s);<br>start_timer(s.seq);<br>wait_for_event(&amp;event);<br><br><span class="hljs-keyword">if</span> (event == frame.arrival) &#123;<br>from_physical_layer(&amp;s);<br><span class="hljs-keyword">if</span> (s.ack == next_frame_to_send) &#123;<br>stop_timer(s.ack);<br>from_network_layer(&amp;buffer);<br>next_frame_to_send = <span class="hljs-number">1</span> - next_frame_to_send;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> &#123;<br>seq_nr frame_expected = <span class="hljs-number">0</span>;<br>frame r, s;<br>event_type event;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>wait_for_event(&amp;event);<br><br><span class="hljs-keyword">if</span> (event == frame.arrival) &#123;<br>from_physical_layer(&amp;r);<br><span class="hljs-keyword">if</span> (r.seq == frame_expected) &#123;<br>to_network_layer(&amp;r.info);<br>frame_expected = <span class="hljs-number">1</span> - frame_expected;<br>&#125;<br>s.ack = <span class="hljs-number">1</span> - frame_expected;<br>to_physical_layer(&amp;s);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><em><strong>Piggybacking 捎带应答</strong></em><ul><li>通信是全双工Full-duplex的；</li><li>当接收方收到帧后，不立刻发送ACK，而是等待网络层有发送请求时，将ACK添加到需要发送的帧中一起发送；</li><li>缺点是在如果长时间没有发送请求，会因等待应答而造成信道阻塞；</li></ul></li></ul><h4 id="Sliding-Window-Protocols-滑动窗口协议">Sliding Window Protocols 滑动窗口协议</h4><h5 id="特点">特点</h5><ul><li>可靠，面向连接的服务；</li><li>信道是全双工的；</li><li>通过CRC+重传进行差错控制；</li><li>通过滑动窗口进行流量控制；</li></ul><h5 id="Protocol-4-Sliding-Window-of-Size-1-大小为1的滑动窗口协议">Protocol 4: Sliding Window of Size 1 大小为1的滑动窗口协议</h5><ul><li>实际上就是停等协议，只不过变成了全双工，既能发又能收；</li><li>在两端同时发送数据时会出现帧重复；</li><li>信道效率低，特别是带宽时延积较大的信道，比如卫星通信；</li></ul><h5 id="Protocol-5-GBN-Go-Back-N-回退N步">Protocol 5: GBN(Go Back N 回退N步)</h5><ul><li>默认情况下接收窗口$W_r = 1$；</li><li>$W_t + W_r \le 2^n$，所以发送窗口需要满足$W_t \le 2^{n} - 1$；</li><li>如果收到的帧出错，之后接受到的帧都丢弃，直到出错的帧重新发送后被正确接收，在此期间接收方保持沉默，并不会应答；</li><li>如果收到的帧与预期收到的不符，丢弃该帧，并回送ACK为当前最后一个已经收到的正确的帧的序号；发送方收到后需要从该ACK序号之后的帧开始重传；</li><li>发送方在接收到ACK或帧计时器超时后，需要回退到发错的那一帧并重传；</li><li>注意ACK的应答可以采用<em><strong>Cumulative ACK</strong></em>（累计ACK）：不需要每一帧都回送一个ACK，当接收方发送ACK = n时，表示n以及n之前的数据帧都已经正确收到；</li><li>对于 $n$ bits的序列号码，$MAX_SEQ = 2^n - 1$；</li><li>默认接受方的Buffer缓存空间 $= MAX_SEQ + 1$；</li></ul><p><em><strong>Protocol 4 vs. Protocol 5</strong></em>：<br><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/10.png" alt=""></p><h5 id="Protocol-6-SR-ARQ-Selective-Repeat-选择重传">Protocol 6: SR ARQ(Selective Repeat 选择重传)</h5><ul><li>只有被拒绝的帧才需要重传；</li><li>一般默认$W_t = W_r = 2^{n-1}$，注意与Protocol 5区分；</li><li>一般，认为接收方需要的Buffer空间 $= W_r$，帧缓存的位置 = $frame.seq % W_r$，这样能否有效保证任意位置接受窗口内的帧不在同一位置；</li><li><em><strong>Frame Timer</strong></em>：发送方每一个缓存的帧都需要一个Timer；</li><li><em><strong>ACK Timer</strong></em>：只需要一个，以第一个为准；</li><li><em><strong>NCK</strong></em>：以下两种情况，接收方会发送NCK用于加速重传：<ul><li>收到的数据帧校验出错；</li><li>收到的数据帧和预期的不符合；</li><li>NCK的序号就是出错帧（指的是预期的帧）的序号；</li></ul></li><li>向网络层提交数据是一个循环的过程：从接收窗口下沿开始依次提交收到的帧并向前滑动接收窗口直到空闲Buffer出现；</li></ul><h5 id="协议456的比较">协议456的比较</h5><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/11.png" alt=""></p><h3 id="Performance">Performance</h3><p>$$<br>\alpha = \frac{T_{prop}}{T_{trans}}<br>$$</p><h4 id="Error-free-Stop-and-Wait">Error-free Stop-and-Wait</h4><p>$$<br>efficiency = \frac{1}{1+2\alpha}<br>$$</p><h4 id="Stop-and-Wait-with-error">Stop-and-Wait with error</h4><p>$$<br>efficiency = \frac{1 - p}{1 + 2\alpha}<br>$$</p><h4 id="Error-free-Sliding-Window">Error-free Sliding-Window</h4><p>$$<br>efficiency = \left{\begin{matrix}<br>\frac{W_T}{1 + 2\alpha},W_T &lt; 1 + 2\alpha \<br>1, W_T \ge 1 + 2\alpha<br>\end{matrix}\right.<br>$$</p><h4 id="Error-free-Sliding-Window-with-Piggybacking">Error-free Sliding-Window with Piggybacking</h4><p>$$<br>efficiency = \frac{W_T}{2 + 2\alpha}<br>$$</p><h2 id="Media-Access-Control">Media Access Control</h2><p>见计网学习笔记(4)：介质访问控制；</p><h1>Services(to Network Layer)</h1><ul><li>Connectionless services<ul><li>Unacknowledged connectionless services：大多数局域网LAN使用无确认；</li><li>Acknowledged connectionless services：wireless system；</li></ul></li><li>Acknowledged connection-oriented services：</li></ul><h1>Implement</h1><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/1.png" alt=""></p><p>方框内表示一整个Router路由器，一般有3个接口，其中1和2组成路由器的网卡(NIC，Network interface cart)；</p><h1>Examples of Point-to-Point DataLink Protocols</h1><h4 id="HDLC-High-Level-DataLink-Control-高级数据链路控制">HDLC(High-Level DataLink Control, 高级数据链路控制)</h4><h5 id="特点-2">特点</h5><ul><li>可靠，面向连接<ul><li>流量控制，差错控制；</li><li>GoBackN ARQ，Selective Repeat ARQ；</li></ul></li><li>Synchronous serial transmission 同步串行链路传输；</li><li>error detection：CRC；</li><li>不支持相关链路和网络参数协商；</li><li>不支持认证；</li></ul><h5 id="Frame-Type">Frame Type</h5><p>采用零比特填充。<br><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/12.png" alt=""></p><h5 id="Station-Type">Station Type</h5><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/13.png" alt=""></p><h4 id="Point-to-Point-Protocol-PPP-点对点协议">Point-to-Point Protocol(PPP, 点对点协议)</h4><h5 id="特点-3">特点</h5><ul><li>只支持点到点；</li><li>Connectionless unacknowledged service；</li><li>采用字节填充；</li><li>适配多种网络层协议；</li><li>支持身份认证；</li><li>物理层可以采用异步和同步传输；</li></ul><h5 id="Frame-Format">Frame Format</h5><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/14.png" alt=""></p><ul><li>Address = 0xFF，表示支持所有站点；</li><li>Control = 0x03，表示无编号模式；</li><li>以上两个字段非必需，可以不要；</li></ul><h4 id="协议对比">协议对比</h4><p><img src="/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/15.png" alt=""></p><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');// 可以在这里添加额外的回调函数});</script>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组学习笔记(2)：运算方法与运算器Ⅰ</title>
    <link href="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/"/>
    <url>/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<h1>数据表示方法</h1><h2 id="定点数">定点数</h2><p><img src="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/1.png" alt=""></p><h2 id="机器码">机器码</h2><p>将有符号数中的符号位进行数字化编码得到机器码，原有符号数称为真值。</p><h3 id="原码">原码</h3><ul><li>用第一位表示符号位，正0负1；</li><li>真值转化为原码只需根据正负添加符号位；</li><li>0有2种表示；</li><li>运算不便；</li></ul><h3 id="补码">补码</h3><ul><li>正数补码和原码相同；</li><li>负数的原码转补码相当于+$2^{n - 1}$；从二进制码来看就是除符号位之外的数值位取反再加1；</li></ul><h3 id="反码">反码</h3><ul><li>正数的补码和反码相同；</li><li>负数的反码转补码，除符号位之外的数值位取反；</li></ul><h3 id="移码">移码</h3><p>$$<br>[x_{移}] = x + 2^{n-1}<br>$$</p><ul><li>移码可用来表示浮点数的指数；</li><li>移码和补码尾数相同，符号位相反；</li></ul><h2 id="补码运算">补码运算</h2><p>$$<br>[x + y]<em>{补} = [x]</em>{补} + [y]<em>补<br>$$<br>$$<br>[x - y]</em>{补} = [x]<em>{补} - [y]</em>{补}<br>$$<br>$$<br>-[y]<em>{补} = [-y]</em>{补}<br>$$</p><p>注：已知$y$的补码，求$-y$的补码，按位取反+1即可；</p><h2 id="溢出检测方法">溢出检测方法</h2><h3 id="双符号位法">双符号位法</h3><h4 id="变形补码">变形补码</h4><p>正数符号位用00表示，负数符号位用11表示；</p><ul><li>运算后符号位变01，表示发生正溢出；</li><li>运算后符号位变10，表示发生负溢出；</li><li>运算后符号位为00或11，未溢出；</li><li>正确结果应该是最高符号位；</li></ul><p>通过以上结果可以发现，溢出的情况有以下两种：</p><ul><li>最高有效位发生进位，但第1符号位（即正常补码的符号位）未发生进位；</li><li>第1符号位发生进位，但最高有效位未发生进位；</li></ul><p>所以，现代计算机中直接采用单符号位法用于溢出检测。</p><h3 id="单符号位法">单符号位法</h3><p>$$<br>OF = C_f \oplus C_0<br>$$</p><p>其中：</p><ul><li>$OF$，溢出标志；</li><li>$C_f$，符号位的进位；</li><li>$C_0$，最高有效位的进位；</li></ul><h1>加法器</h1><h2 id="1位全加器">1位全加器</h2><p>$$<br>S_i = A_i\oplus B_i \oplus C_i<br>$$</p><p>$$<br>C_i = A_iB_i + (A_i\oplus B_i)C_i<br>$$</p><p>电路图如下：<br><img src="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/2.png" alt=""></p><h2 id="n位行波进位的补码加法器">n位行波进位的补码加法器</h2><p><img src="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/3.png" alt=""></p><p>观察上图，考虑$n = 2$的简单情况：</p><ul><li>高1位等待低1位产生进位的时间为$3T + 3T + T + T = 3T + 3T + 2T$；</li><li>在得到低一位的进位后，产生该位进位需要$2T$；</li><li>最后产生溢出标志和进位标志需要$3T$；</li></ul><p>所以对于$n$位行波进位加法器，时间延迟为$3T + 3T + (n - 1) * 2T + 2T + 3T = （2n + 9)T$；</p><p>如果不考虑溢出检测，最后不需要通过$2T + 3T$，直接产生结果需要$3T$，时间延迟为$3T + 3T + 2(n - 1)T + 3T = 2(n - 1)T + 9T$；</p><h2 id="先行进位加法器">先行进位加法器</h2><p>加法器进位链的基本逻辑关系为：<br>$$<br>C_{i + 1} = A_iB_i + (A_i+B_i)C_i<br>$$</p><p>令：</p><ul><li>$G_i = A_iB_i$，本地进位；</li><li>$P_i = A_i + B_i$，进位传递条件；</li></ul><p>于是：<br>$$<br>C_{i+1} = G_i + P_iC_i<br>$$</p><p>由此可以递推出如下关系：<br><img src="/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/4.png" alt=""></p><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');});</script>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Agentic Design Pattern AI代理设计模式学习</title>
    <link href="/2025/03/13/Agentic%20Design%20Pattern%20AI%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/13/Agentic%20Design%20Pattern%20AI%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>零、概述 Overview</h1><p>我们要让 LLM 一次性根据我们的提示生成一个应用的所有前端代码或一整篇论文，LLM 一次性输出最终 Token，不修改，显然是较为困难并且效果不佳的。但是，如果使用代理设计流（Agent Workflow），让 LLM 按照编排的工作流，多次提示，每个步骤都有优化任务，不断迭代改进输出，类似人拆解复杂任务、收集信息、改进迭代并最终达到满意结果的过程。</p><p>以编写文档为例，工作流大致涉及以下步骤：</p><ol><li>撰写文档大纲；</li><li>查询本地知识库或网络收集资料；</li><li>撰写初稿；</li><li>检查初稿并修正不合理之处；</li><li>如此迭代到文档符合要求；</li></ol><p>代理设计模式主要包括：</p><ol><li><strong>Reflection Pattern</strong>：反思模式，LLM 可以通过反思自己的行为成为更有效的代理；</li><li><strong>Tool Use Pattern</strong>：工具使用模式；</li><li><strong>Planning Pattern</strong>：规划模式；</li><li><strong>Multi-Agent Pattern</strong>：多代理模式；</li></ol><h1>壹、Reflection Pattern</h1><p>反思模式类似于我们直接与大模型对话，通过不断提示大模型达到我们想要的输出。代理设计模式中，需要将提供反馈的步骤自动化。</p><p>比如可以设计 Prompt 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">现有以下任务<span class="hljs-attribute">X</span>：略；以下是用于任务<span class="hljs-attribute">X</span>的代码：略；请你仔细检查代码的正确性、风格和效率，并就如何改进它给出建设性的批评和建议；<br></code></pre></td></tr></table></figure><p>然后，将之前生成的代码和检查后的反馈一起作为 Context 输入给 LLM，让 LLM 根据反馈建议修改代码；</p><p>一个简单的示意图如下：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504081117237.png" alt=""></p><p>当然，实际应用中会涉及多次迭代，以获得更高的精度；</p><h2 id="应用：SELF-RAG">应用：SELF-RAG</h2><p>SELF-RAG 在检索以及生成的过程中引入了自我反思机制，下图直观呈现了它和传统 RAG 的区别：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504081124295.png" alt=""></p><h1>贰、Tool Use Pattern</h1><p>代理通过调用 API 来获取预训练模型权重中缺少的额外信息，比如调用 Web 搜索、访问本地知识库、执行代码等等；</p><h1>叁、Planning Pattern</h1><p>前面已经提到，复杂的问题往往需要拆解为多个步骤。我们可以事先就搭建好代理工作流，但是在代理规划模式下，Agent 能动态决定需要采取的步骤。</p><p>关于任务的分解，主要有以下几种方式：</p><h2 id="Chain-of-Thought-思维链CoT">Chain of Thought(思维链CoT)</h2><p>通过“逐步思考”实现复杂推理，</p><blockquote><p>可参考内容</p></blockquote><p>[1]  <a href="https://arxiv.org/abs/2201.11903?utm_campaign=The%20Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8Kh954rkXmE4vgpKvro3Klpjhn7IuT-Y_eXIYtgVIq9PTzwa5zFWX7FZZqv1tuDEEsTDuY">Chain-of-Thought Prompting Elicits Reasoning in Large Language Models</a>, Wei et al. (2022)；</p><h2 id="Tree-of-Thought">Tree of Thought</h2><p>在前者的基础上进行了扩展，对于每个步骤生成了多个思考，建立树状结构，然后执行 BFS 或 DFS，通过分类器或多数投票进行评估；</p><h1>肆、Multi-Agent Collaboration</h1><p>Multi-Agent Collaboration，即多代理协作，顾名思义，对于一个复杂的任务，拆分成不同的任务，并交给不同代理去做。虽然现在 LLM 的上下文限制不断提升，但对于一个复杂的任务，比如开发一个较为复杂的软件系统，单个 LLM 并不一定能达到较好的效果。而如果像游戏公司一样，将不同部分交给专业的人去做，比如策划、客户端开发、服务端开发、TA、QA、美术等等，让不同的 Agent 完成不同的子任务，可能能达到更好的效果。</p><blockquote><p>可参考内容</p></blockquote><p>[1]  <a href="https://arxiv.org/abs/2307.07924?utm_campaign=The%20Batch&amp;utm_source=hs_email&amp;utm_medium=email&amp;_hsenc=p2ANqtz-8TZzur2df1qdnGx09b-Fg94DTsc3-xXao4StKvKNU2HR51el3n8yOm0CPSw6GiAoLQNKua">Communicative Agents for Software Development</a>, Qian et al. (2023)；</p>]]></content>
    
    
    <categories>
      
      <category>科研学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网学习笔记(2)：物理层</title>
    <link href="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1>基本概念</h1><ul><li><strong>Bandwidth信道带宽</strong>：$f_{max} - f_{min}$，单位Hz；<ul><li>Analog Bandwidth，模拟信号用Hz表示；</li><li>Digital Bandwidth，数字信号用bps（bit per second）表示；</li><li>Low-pass channel，低通信道，$f_{min} = 0$；</li><li>Band-pass channel，带通信道，$f_{min} &gt; 0$；</li></ul></li><li><strong>Bit Rate(bps)</strong>：比特率；</li><li><strong>Baud Rate(Baud)</strong>：波特率，每秒钟表示bit所需的信号单元的数量；<ul><li>T：一个信号单元的时间；</li><li>Baud Rate = $\frac {1}{T}$；</li><li><em><strong>Bit Rate = Baud Rate $\times$ 一个信号单元携带的bit数 = Baud Rate $\times$ $log_2 {有效状态数}$；</strong></em></li></ul></li><li><strong>信道容量</strong>：信道的最大数据率；</li><li><strong>吞吐量</strong>：单位时间内网络可以传送的数据位数，单位bps；</li><li><strong>负载Load</strong>：单位时间内注入网络的数据位数，单位bps；</li><li><strong>误码率</strong>；</li><li><strong>Delay时延</strong>：第一位开始发送与最后一位数据被接受的时间差；<ul><li><strong>发送时延Transmission Delay</strong>：发送一个数据块需要的时间；<ul><li>Transmission Delay = $\frac {Message Length(bits)}{Bandwidth(bps)}$；</li></ul></li><li><strong>传播时延Propagation Delay</strong>：信号通过传输介质的时间；<ul><li>Propagation Delay = $\frac {length of physical link}{propagation speed in medium}$；</li></ul></li><li>节点处理时延；</li><li>排队时延；</li></ul></li><li><strong>带宽时延积bandwidth-delay product</strong>：表示充满整个链路的bit数（有点像体积），表示信道的缓存能力；<ul><li>Bandwidth-Delay Product = propagation delay $\times$ bandwidth；</li></ul></li></ul><h1>信道</h1><h2 id="Noiseless-Channel-无噪信道">Noiseless Channel 无噪信道</h2><p>理想信道的比特率通过Nyquist Bit Rate（奈奎斯特公式，1924）给出：<br>$$<br>C(Capacity) = Bit Rate = 2 \times bandwidth\times log_2{信道级数(即有效状态数)}<br>$$<br>注意上述公式给出的是理想情况下最大可能的传输速率；</p><h2 id="Noisy-Channel-有噪信道">Noisy Channel 有噪信道</h2><p>有噪信道的传输速率通过Shannon Capacity（香农公式，1948）给出：<br>$$<br>Capacity = bandwidth\times log_2{1 + \frac{signal_power}{noise_power}}<br>$$<br>其中，<strong>信噪比(SNR，Signal-to-Noise Ratio)</strong> 又可以取对数用db(decibels)来表示：<br>$$<br>S/N_{db} = 10log_{10}{(S/N)}<br>$$</p><h1>传输介质Transmission Media</h1><h2 id="传输介质的分类">传输介质的分类</h2><ul><li>磁介质Magnetic Media</li><li>导向型（有线）<ul><li><em><strong>Twisted Pair双绞线</strong></em></li><li><em><strong>Coaxial Cable 同轴电缆</strong></em></li><li><em><strong>Fiber Optics光纤</strong></em></li><li>Power Lines电力线</li></ul></li><li>非导向型（无线）<ul><li><em><strong>Radio无线电</strong></em></li><li><em><strong>Microwave地面微波</strong></em> and <em><strong>Satellite卫星通信</strong></em></li></ul></li></ul><h2 id="频率范围Electromagnetic-Spectrum">频率范围Electromagnetic Spectrum</h2><ul><li>Twisted Pair双绞线：$0$ ~ $10^8$Hz；</li><li>Coaxial Cable同轴电缆：$10^3$ ~ $10^9$Hz；</li><li>Fiber Optics光纤：$10^{14}$ ~ $10^{15}$Hz；（基本属于可见光的范围）</li><li>Radio无线电波：$10^4$ ~ $10^9$；</li></ul><h2 id="传输介质的特性">传输介质的特性</h2><ul><li><em><strong>带宽</strong></em></li><li><em><strong>传播时延</strong></em></li><li><em><strong>最大传输距离</strong></em>（不加放大器等的情况下）</li><li><em><strong>抗干扰能力</strong></em></li><li><em><strong>安全性</strong></em></li><li>安装与维护难易程度、成本</li></ul><h2 id="有线传输介质">有线传输介质</h2><h3 id="Twisted-Pair双绞线">Twisted Pair双绞线</h3><ul><li>两根通电铜导线拧合在一起；（使两根通电导线产生的磁场相互抵消）</li><li>既能传模拟信号（电话线），又能传数字信号（以太网）；</li><li>拧得越紧，辐射强度越小，抗干扰能力越强；</li><li>UTP(Unshielded TP) and STP(Shielded TP)；（有屏蔽的双绞线多了一个Metal Shield，能减少向外辐射，减少衰减，增强抗干扰能力）</li><li>Catogory（越大带宽也高）；</li></ul><h3 id="Coaxial-Cable同轴电缆">Coaxial Cable同轴电缆</h3><ul><li>better shielding and greater bandwidth；（带宽大于双绞线）</li><li>粗缆和细缆<ul><li>50-ohm cable：基带同轴（电话交换机，早期用在以太网上）；</li><li>70-ohm cable：宽带同轴（适合传输模拟信号，比如电视网）；</li></ul></li><li>抗干扰能力也比较强；</li></ul><h3 id="Fiber-Optic光纤">Fiber Optic光纤</h3><ul><li>利用了光的全反射；</li><li>一般是好几根固定在一起作为一根；</li><li>我们称一种入射角度为一个模：<ul><li><em><strong>Multimode多模光纤</strong></em>：有多种入射角；</li><li><em><strong>Single-mode单模光纤</strong></em>：只有一种入射角；（光线相互之间干扰很小，<em><strong>带宽更宽</strong></em>）</li></ul></li><li>光纤的工作窗口：对应波长/频率的光波适合在这个光纤内传输，损失最小；</li><li>光纤环网：<img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/1.png" alt=""><ul><li>Opitcal Receiver用于将光信号转化为电信号（光敏电阻）；</li><li>Signal Regenerator用于对电信号进行放大和整形，此时可以选择发送到计算机或者继续传输；</li><li>Optical Transmitter用于将电信号重新转化为光信号（发光二极管）；</li></ul></li><li>优点：<ul><li>带宽大；</li><li>抗干扰能力好，安全；</li><li>轻便（相较于铜导线）；</li></ul></li></ul><h2 id="无线传输介质">无线传输介质</h2><p>总体来说（相较于有线传输）：</p><ul><li>误码率更高；</li><li>传播时延更高；</li><li>传输损耗更大；</li><li>安全性也更弱；</li><li>抗干扰能力更差；</li><li>带宽不可再生，可用的是有限的；</li><li>同一个空间内，同一频率会相互干扰；</li></ul><h3 id="Radio无线电波">Radio无线电波</h3><h4 id="传播方式">传播方式</h4><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/2.png" alt=""></p><ul><li>较低的频段，波长较大，可以沿地球表面传播；</li><li>高频，波长较小，沿直线传播，在中继站之间传播；</li><li>超高频以上，需要用在视距范围内的中继站传播；</li></ul><h3 id="Microwave微波">Microwave微波</h3><p>直线传输，适合长距离通信，当需要地面中继站（<em><strong>典型设备：中继器Repeater，进行再生信号，即信号的整形和放大</strong></em>）才能进行远距离；</p><h3 id="红外线和可见光通信">红外线和可见光通信</h3><p>略</p><h2 id="卫星通信">卫星通信</h2><p>通信卫星相当于微波通信中中继站Repeater的作用，只不过在大气层以外。</p><h3 id="典型设备：Transponder转发器">典型设备：Transponder转发器</h3><ul><li>监听由地面天线发出的上行电波；</li><li>将收到的电波进行Amplify(放大)；</li><li>将电波以<em><strong>另一种频率</strong></em>的下行电波<em><strong>广播</strong></em>发送给范围内的地面天线；</li></ul><h3 id="通信卫星的分类">通信卫星的分类</h3><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/3.png" alt=""></p><ul><li>GEO：地球同步轨道；</li><li>MEO：中地轨道；</li><li>LEO：近地轨道；</li></ul><blockquote><p>轨道高度越高，需要覆盖全球的卫星数量越小，但时延越高；</p></blockquote><h3 id="卫星通信的特点">卫星通信的特点</h3><ul><li>Long propagation delay，时延长；</li><li>broadcast media，先天的广播介质；</li><li>传输成本和传输距离无关；</li><li>不受地面环境影响；</li></ul><h1>数字通信系统</h1><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/4.png" alt=""></p><h2 id="典型设备">典型设备</h2><ul><li>Modem调制/解调器：将信号调整为适合信道传输的频率范围（baseband signal基带信号 $\rightarrow$ passband signal带通信号）；<ul><li>基带信号：$0$ ~ $f_{max}$ Hz；</li><li>带通信号：$f_{1}$ ~ $f_{2}$ Hz，$f_1 &gt; 0$；</li></ul></li><li>CodeC编解码器；</li><li>Multiplxer多路复用器：将多路信号复用在一条传输介质上，提高信道利用率；</li><li>信道编码器：将01信号转化为抗干扰能力更强的方波；</li></ul><h2 id="Line-Code线路编码">Line Code线路编码</h2><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/5.png" alt=""></p><ul><li>NRZ不归零编码：抗干扰能力不强；</li><li>Manchester编码：用“low to high”表示0，“high to low”表示1；指定电平的变化必须发生在时钟周期的中间；这样同时传输来信号和时钟，有着<em><strong>自同步</strong></em>功能；</li><li>AMI编码：1用“+1”“-1”间隔表示；</li></ul><h3 id="评价指标">评价指标</h3><ul><li>Clock Recovery时钟恢复：能在信号流中提取时钟频率；<img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/6.png" alt=""></li><li>Balanced Signals平衡信号：消除直流分量；Manchester编码和AMI编码都可以；</li><li>Bandwidth Efficiency信道效率：Manchester编码只有50%；</li></ul><h2 id="调制技术Modulation">调制技术Modulation</h2><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/7.png" alt=""></p><p>从上到下依次是：</p><ul><li>原始二进制信号；</li><li>2ASK：振幅调制（幅移键控）；</li><li>2FSK：频率调制；</li><li>2PSK：相位调制；</li></ul><h3 id="多级调制技术">多级调制技术</h3><p>同时利用不同的振幅以及相位来表示传输的比特位，从而提高每个信号单元携带的比特数量；</p><ul><li>QPSK：正交相移键控；</li><li>QASK：正交幅度调制；<br><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/8.png" alt=""></li></ul><p>其中：</p><ul><li>振幅：点与原点的距离；</li><li>相位：点与原点的连线和x轴的夹角；</li></ul><h2 id="模拟信号数字化PCM">模拟信号数字化PCM</h2><p><em><strong>PCM：Pluse Coding Modulation（脉冲编码调制）；</strong></em><br>分为以下三个阶段：</p><ul><li>Sampling采样：根据Nyquist Theory，<em><strong>数字信号的采样率应至少是信号最高频率的2倍</strong></em>。</li><li>Quantizing量化；</li><li>Encoding编码；<br>典型设备：CodeC编码解码器；</li></ul><h2 id="复用Multiplexing">复用Multiplexing</h2><ul><li>TDM时分复用；</li><li>FDM频分复用；</li><li>WDM波分复用；</li><li>CDM码分复用；</li></ul><h3 id="关键设备Multiplexer">关键设备Multiplexer</h3><p>例如，<em><strong>Digital Subscriber Line Access Multiplex(DSLAM，数字用户线接入复用器)</strong></em>；</p><h3 id="Frequency-Division-Multiplexing-频分复用">Frequency Division Multiplexing 频分复用</h3><p>将多路信号通过傅立叶变换分成频率范围各不相同的信号合成一路进行传输，再通过带通滤波器实现分离；<br>注意信号之间一般存在<em><strong>保护频带</strong></em>；</p><h3 id="Time-Division-Multiplexing-时分复用">Time Division Multiplexing 时分复用</h3><p>将每路信号在时间上分为多个<em><strong>timeslot(时隙)</strong></em>，信号被分到不同时间片进行发送</p><h4 id="Synchronous-TDM同步时分复用">Synchronous TDM同步时分复用</h4><p>每一个<em><strong>发送帧Frame</strong></em>都为每路信号保留发送空间，缺点是对于数字信号的传播，一般不连续，易造成资源浪费；在电话网络中应用较广；</p><h4 id="Statistical-TDM统计-异步时分复用">Statistical TDM统计/异步时分复用</h4><p>只发送需要发送的数据，在需要时分复用时才进行复用，但需要加上地址头Address作为用户标识；</p><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/13.png" alt=""></p><ul><li>其中，T1为24路，E1位30/32路(其中2路为控制信号)；</li></ul><h3 id="Code-Division-Multiplexing码分复用">Code Division Multiplexing码分复用</h3><p>不同用户可以在任意时间使用整个信号发送信息，不同用户发送的信息通过编码理论进行区分；<br>比如，在班级里，同学间分为不同小组进行讨论，但不同组用不同语言交流，并且同时大声说话，我需要接受某信息就需要知道该信息的组所用的语言，屏蔽其他组。但如果组越多，噪声越大，就越不容易接受。</p><h3 id="Wavelength-Division-Multiplexing波分复用">Wavelength Division Multiplexing波分复用</h3><p>波长和频率成反比，所以波分复用和频分复用类似，一般用在<em><strong>Fiber Optic光纤通信</strong></em>中。<br><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/14.png" alt=""></p><blockquote><p>Line Code：线路编码，用于基带传输Baseband Transmission；<br>Modulation：调制，用于带通传输；</p></blockquote><h2 id="Example-电话网">Example: 电话网</h2><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/9.png" alt=""></p><ol><li>首先，语音信号通过<em><strong>Local Loop(本地环路)</strong></em>，到达<em><strong>CodeC(编解码器)</strong></em>，将模拟信号转化为数字信号；</li><li>语音信号的带宽一般是$4$kHz左右，根据Nyquist Theorm，复原该语音信号需要每秒$8$k的采样率，即每$125$usec采样一次，而$1 sample = 8bits$(非线性编码)，所以比特率为$8k \times 8bits = 64kbps$；</li><li>CodeC将数字信号通过<em><strong>Trunk(中继线)</strong></em>，继续发往路由器/交换机，其中用到了时分复用；</li></ol><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/10.png" alt=""></p><ol><li>电脑通过电话线接入网络，由于电脑发送的是01比特串，所以先通过<em><strong>Modem(调制解调器，使用QAM，正交幅度调制)</strong></em>，将数字信号转化为模拟信号；</li><li>之后的步骤类似电话网络；</li></ol><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/11.png" alt=""><br>其中，$-1$bit是因为1位用于检错；</p><h3 id="DSL-Digital-Subscriber-Lines数字用户线">DSL: Digital Subscriber Lines数字用户线</h3><ul><li>DSL在短距离内可以提供较大的带宽；</li><li>随着距离增加，带宽急剧下降；</li></ul><h4 id="ADSL-Asymmetric-DSL非对称数字用户线">ADSL: Asymmetric DSL非对称数字用户线</h4><p>该服务将本地贿赂上的$1.1$MHz频谱分为$256$条独立的信道，每条信道的带宽约为$4.3$KHz：</p><ul><li>Channel 0用于<em><strong>电话服务(POTS，Plain Old Telephone Service)</strong></em>；</li><li>Channel 1～4用于保护隔离；</li><li>剩下的250条信道被分为上行流Upstream和下行流Downstream，其中有2条用于控制，即实际用于传输用户数据的是248条；</li></ul><h4 id="技术：DMT-Discrete-Multitone-Modulation，离散多音调制">技术：DMT(Discrete Multitone Modulation，离散多音调制)</h4><p><img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/12.png" alt=""></p><h3 id="Switching-交换">Switching 交换</h3><h4 id="Circuit-Switching电路交换">Circuit Switching电路交换</h4><ul><li>面向连接：<ul><li>circuit establishment</li><li>data transfer</li><li>circuit</li></ul></li><li>需要提前分配路径和资源；</li><li>优点：<ul><li>Small Delay；</li><li>Good Quality；</li><li>容易控制；</li></ul></li><li>缺点：<ul><li>在建立连接的过程中需要花费较长时间；</li><li>带宽固定；</li><li>如果双方不发送数据，会造成信道浪费；</li></ul></li><li>例子：电话网</li></ul><h4 id="Message-Switching报文交换">Message Switching报文交换</h4><ul><li>在每个节点，收到的整个消息都被存储到节点内再进行转发；（Store-and-Forward）<img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/15.png" alt=""></li><li>缺点：需要开较大的缓存空间，不适合较大的消息；</li><li>例子：邮局；</li></ul><h4 id="Packet-Switching分组交换">Packet Switching分组交换</h4><ul><li>数据在发送前被分为不同的<em><strong>组Packet</strong></em>，再进行传输，每个包独立进行<em><strong>路由选择（显然，每个包都需要携带相应的路由信息）</strong></em>，每个包到达节点后进行<em><strong>存储-转发</strong></em>，过程中资源是<em><strong>动态分配</strong></em>的；</li><li>与电路交换的对比：<img src="/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/16.png" alt=""></li></ul><h1>物理层协议</h1><ul><li>Mechanical Features机械特性：接口形状和尺寸、引线数目和排列、固定和锁定装置等；</li><li>Electrical Features电气特性：电缆线上的电压范围；</li><li>Functional Features功能特性：某条线上出现的某一电平的电压保持何种意义；</li><li>Procedure Features过程特性：对于不同功能的各种可能事件的出现顺序；</li></ul><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');// 可以在这里添加额外的回调函数});</script>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形式语言与自动机学习笔记(1)</title>
    <link href="/2025/03/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2025/03/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<h1>一、概述</h1><ul><li><strong>形式语言</strong>：形式化描述的字母表上的字符串构成的集合；</li><li><strong>自动机</strong>：具有离散输入输出的数学模型；</li></ul><blockquote><p>形式语言与自动机的关系：<br>形式语言——字符串，自动机——字符串的识别系统<img src="/2025/03/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/1.png" alt=""></p></blockquote><ul><li><strong>文法</strong>：定义语言的数学模型；</li><li><strong>元语言</strong>：描述语言的语言；</li></ul><h1>二、Chomsky文法体系</h1><h2 id="概念简述">概念简述</h2><p>文法$G$是一个四元组$G=(N，T，P，S)$，其中：</p><ul><li>$N$：非终结符的有限集合；</li><li>$T$：终结符的有限集合，且$N\cap T = \phi$；</li><li>$P$：形式为$\alpha \rightarrow \beta$的生成式的有限集合，且$\alpha \in (N \cup T)^* N^+ (N \cup T), \beta \in(N\cup T)^*$，即$\alpha$中至少含有一个非终结符；</li><li>$S$：起始符，且$S\in N$；</li></ul><p>应用生成式就是将非终结符不断替换为终结符+非终结符的符号串，再替换得到的新的字符串中的非终结符，最终得到只含有终结符的符号串；<br>我们将中间过程的符号串称为句型，最终推导出的只含有终结符的符号串称为句子，显然，<em><strong>句型包含句子</strong></em>。</p><p>我们将文法产生的语言记为$L(G)$：<br>$$<br>L(G) = { \omega \mid \omega \in T^* \text{ 且 } S \Rightarrow^* \omega }<br>$$<br>即必须是由终结符组成，并且由起始串$S$推导得到；</p><p>关于Chomsky文法体系，对生成式做出一些限制，分为以下4类：</p><h2 id="0型文法">0型文法</h2><ul><li>无限制</li><li>对应递归可枚举语言</li><li>对应图灵机</li></ul><h2 id="1型文法">1型文法</h2><ul><li>上下文有关文法</li><li>对应上下文有关语言</li><li>对应线性有界自动机（不考虑空串）</li></ul><p>1型文法对生成式做出了如下限制：$\alpha \rightarrow \beta$，其中$|\alpha| \leq |\beta|$，且$\alpha, \beta \in (N \cup T)^*$，且$\alpha$至少含有一个非终结符号；<br>该限制的意义是保证了推到过程中字符串长度单调不减；</p><h2 id="2型文法">2型文法</h2><ul><li>上下文无关文法</li><li>对应上下文无关语言</li><li>对应下推自动机</li></ul><p>2型文法对生成式做出了如下限制：$A \rightarrow \alpha$，其中$A$是一个非终结符，$\alpha$是由非终结符和终结符组成的任意字符串（可以是空串）；<br>该限制的意义是每次替换单独一个非终结符，支持递归结构的解析；</p><h2 id="3型文法">3型文法</h2><ul><li>正则文法（分为左线性文法和右线性文法）</li><li>对应正则语言</li><li>对应优先自动机</li></ul><p>左线性文法对生成式做出了如下限制：$A \rightarrow B\omega$或$A \rightarrow \omega$，其中$A,B$为非终结符，$\omega$为终结符；<br>右线性文法对生成式做出了如下限制：$A \rightarrow \omega B$或$A \rightarrow \omega$，其中$A,B$为非终结符，$\omega$为终结符；<br>该限制的意义是，生成式只能在字符串的左边或者右边扩展非终结符，限制了语言的复杂性和递归性；</p><h1>有限自动机</h1><h2 id="DFA">DFA</h2><p>DFA是一个五元组$M = (Q,T,\delta. q_0, F)$；</p><ul><li>$Q$：有限状态集合；</li><li>$T$：有限的输入字母表；</li><li>$\delta$：转移函数：$Q \times T \rightarrow Q$；</li><li>$q_0$：起始状态；</li><li>$F$：终止状态的集合；</li></ul><p><strong>$\delta’$函数</strong>：接受一个字符串输入的状态转移函数：<br>$$<br>\delta’:Q\times T^* \rightarrow Q<br>$$<br>对任何$q \in Q$，作出如下定义：</p><ul><li>$\delta’(q, \varepsilon) = q$；</li><li>若$\omega$为字符串，$a$为一个字符，则$\delta’(q, a\omega) = \delta(\delta’(q, \omega), a)$；</li></ul><p><strong>被DFA接受的字符串</strong>：输入结束后使DFA达到终止状态；</p><p><strong>格局</strong>：当前状态$q$，待输入字符串$\omega$，用$(q, \omega)$表示当前瞬时状态；</p><h2 id="UFA-不确定的有限自动机">UFA 不确定的有限自动机</h2><p>在某个状态，对应某个输入，有多个转移，能到达多个状态；UFA和DFA的定义上的区别只有$\delta$函数：<br>$$<br>\delta：Q\times T\rightarrow 2^Q<br>$$<br>如果接受一个字符串后UFA能够到达的状态集合包含一个及以上F中的元素，则称为该字符串能被UFA接受；</p><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');// 可以在这里添加额外的回调函数});</script>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象的程序设计(Java)</title>
    <link href="/2025/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(Java)/"/>
    <url>/2025/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(Java)/</url>
    
    <content type="html"><![CDATA[<h1>面向对象的三大特性</h1><ul><li>封装、继承、多态<ul><li>封装：对抽象的事物抽象成一个对象，并对其对象的属性私有化，同时能提供一些能被外部访问属性的方法。<ul><li>对象：属性+方法；<ul><li>成员变量：生存期是对象的生存期，作用域在类的内部；<ul><li>访问属性：private vs. public vs. friendly<ul><li>private：针对类而不是针对对象的，即同一个类的不同对象的私有属性之间可以相互访问；</li><li>friendly：既没有public也没有private修饰，可以在同一个package内进行访问；</li><li>public：一个编译单元（.java文件）只能有一个public类，并且名称要求相同；</li><li>protected：自己、同一个package内、子类可访问；</li></ul></li></ul></li><li>本地变量：生存期和作用域都是函数内部；</li><li>对象初始化：<ul><li>构造函数（无返回类型，接收无参和有参两种构造方式，即多个同名但参数表不同的函数构成了函数<em><strong>重载</strong></em>）；</li><li>初始化顺序：定义初始化$\rightarrow$构造器；如果继承了父类，先进行父类初始化，并需要确保父类的属性得到了正确的初始化；</li></ul></li></ul></li></ul></li><li>继承：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；<ul><li>Cpp和Java的一个重要区别是，Cpp支持多继承，并且有指针的概念；Java是单继承，但可以用接口来实现多继承；</li></ul></li><li>多态：<ul><li>多态变量：对象变量能对应多种类型，具体可分为静态类型和动态类型；</li><li>造型Cast：<ul><li>造型并不是类型转换；</li><li>向上造型Upcasting：子类对象可以当作父类对象来使用，即子类对象可以用父类对象来赋值；</li></ul></li><li>函数调用的绑定：通过对象类型去调用函数时，调用哪个函数称为绑定；<ul><li>静态绑定：根据变量的声明类型决定；在编译期间确定，被称为静态分派，比如函数的重载；</li><li>动态绑定：根据变量的动态类型决定；在程序运行时确定，被称为动态分派，比如方法的重写（同名同参数表的子类方法会覆盖(override)父类方法）；</li></ul></li><li>多态的底层实现是动态绑定，实际就是方法调用动态分派的过程。如果子类方法覆盖了父类方法，在多态调用时，会先确定实际类型为子类，然后先搜索子类中的该方法。</li></ul></li></ul></li></ul><h1>static vs. final</h1><ul><li>Static：<ul><li>static修饰属性：类变量，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用；</li><li>static修饰方法：类函数，随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用 this；</li></ul></li><li>final：<ul><li>final修饰变量：<ul><li>如果修饰基本数据类型，那相当于常量，不能改变值；</li><li>如果修饰引用数据类型的变量（即对象的引用），那么不能改变对象的引用（即存储地址），即初始化后不能再让其指向一个新的对象；</li></ul></li><li>final修饰方法：相当于禁用了重写，继承类不能修改该方法的含义；</li><li>final修饰类：<ul><li>该类不能被继承；</li><li>final类中的所有成员⽅法都会被隐式地指定为final⽅法；</li><li>该类的成员变量不受影响；</li><li>该类可以有内部类；</li><li>当然，也可以通过私有化构造方法来禁止该类被继承（单例模式）；</li></ul></li></ul></li></ul><h1>抽象类 vs. 接口Interface</h1><ul><li>抽象类：包含抽象方法的类，即使用abstract修饰的类；有抽象函数的类一定是抽象类；<ul><li>抽象类不能用于实例化对象；</li><li>抽象类只能被继承；</li></ul></li><li>接口：接口是一个抽象类型，是抽象方法的集合；<ul><li>接口支持多继承；</li><li>接口中定义的方法，默认是 public abstract 修饰的抽象方法；</li></ul></li><li>相同点：<ul><li>两者均不能被实例化；</li><li>子类/实现类必须重写抽象类/接口中定义的抽象方法；</li></ul></li><li>不同点：<ul><li>抽象类有构造方法，接口没有构造方法；</li><li>抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8 之后可以）；</li><li>抽象类只能单继承，接口可以多继承；</li><li>抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量；</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>就业八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些有关Large Language Model(LLM)的学习记录</title>
    <link href="/2025/02/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Large%20Language%20Model(LLM)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/02/27/%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Large%20Language%20Model(LLM)%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>：</p><blockquote><p>由于本人之前对于大模型的学习学的急功近利，偏向于应用（<s>乱用bushi</s>），回头看来对LLM本身过于肤浅，所以浅开一个坑，用于补齐原理性的知识；</p><p><s>BUPT课设太TM多了</s>。不定期随便填坑。</p></blockquote><p><strong>参考资料</strong>：</p><blockquote><p>【1】［美] 塞巴斯蒂安·拉施卡 著，叶文滔 译. 大模型技术30讲[M]. 北京：人民邮电出版社，2024.<br>【2】Raschka S. <em>Build a Large Language Model (From Scratch)</em>[M]. Shelter Island, NY: Manning, 2024.</p></blockquote><h1>一、Understanding LLM</h1><h2 id="1-1-What-is-LLM">1.1 What is LLM?</h2><p><strong>定义 1.1</strong>：<strong>Large Language Model</strong></p><blockquote><p>An LLM is a neural network designed to understand, generate, and respond to human-like text;</p></blockquote><ul><li>“Large” means, datasets on which it’s trained and parameters(the model’s size);<ul><li><strong>parameters</strong> are the adjustable weights in the network that are optimized during training to predict the next word in a sequence;</li></ul></li><li>LLM‘s architecture – <strong>Transformer</strong>, which enables them to pay selective attention to different parts of the input when making predictions;</li><li>LLM is also called <strong>Generative AI</strong>(生成式AI);</li></ul><p>至于其中使用到的两种手段 —— machine learning and deep learning，将在之后具体阐释。（后者是前者的一个子集，主要区别是是否需要手动提取特征。然而机器学习的经典算法已经快被淘汰了，令人感慨）；</p><h2 id="1-2-Application-of-LLM">1.2 Application of LLM</h2><p>无需多言，用过都说好；</p><h2 id="1-3-Stages-of-building-and-using-LLMs">1.3 Stages of building and using LLMs</h2><ul><li><strong>Pretraining 预训练</strong>：在多领域的庞大数据集下训练；</li><li><strong>Finetuning 微调</strong>：针对特定任务通过特定领域的标注数据集在Pretrained LLM的基础上进行训练；<ul><li><strong>Instruction Finetuning 指令微调</strong>：简单来说，就是<em><strong>标注数据 = 指令 + 正确答案</strong></em>；</li><li><strong>Classification Finetuning 分类微调</strong>：<em><strong>标注数据 = 文本 + 分类标签</strong></em>；</li></ul></li></ul><p>两者的具体区别如下图所示：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171352752.png" alt=""></p><h2 id="1-4-Introducing-the-transformer-architecture">1.4 Introducing the transformer architecture</h2><p>Transformer 的两个重要组件是 <strong>Encoder 编码器</strong> 和 <strong>Decoder 解码器</strong>，编码器将输入文本编码为向量，而解码器解码向量并生成相应文本。区别于传统的全连接型或卷积型，编码器和解码器之间采用 <strong>Self-attention mechanism 自注意力机制</strong> 连接；</p><p>在 Transformer模型的基础上，又衍生出了两种不同架构：<strong>Bert(Bidirectional encoder representations from transformers)</strong> 和 <strong>GPT(Generative pretrained transformers)</strong>；</p><p>从全拼也可以看出，这两种模型分别用于不同的任务，Bert模型主要用于 predict masked or hidden words 预测掩码值，适用于文本分类任务，以下是它和 GPT-Model 区别的图示：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171450135.png" alt=""></p><p>GPT-Model 又分为：</p><ul><li><strong>Zero-shot 零样本学习</strong>：能够处理从未在训练数据中见过的任务或类别，即模型在面对新任务时不需要额外的训练和微调也能做出合理的决策；</li><li><strong>Few-shot 少样本学习</strong>：模型在提供极少量样本或示例时，就能够理解并执行特定任务的能力；泛化能力强；</li></ul><p>下图具体说明了两者的区别：<br><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504171510313.png" alt=""></p><p>GPT-Model采用 <strong>自监督(Self-supervised learning)</strong> 的方式进行学习，即自标注形式(Self-labeling)。我们可以将句子或者文档中的下一个单词作为模型应该预测的标签进行训练。</p><blockquote><p><strong>注</strong>：模型能够执行未明确训练的任务的能力称为 <strong>Emergent Ability 涌现</strong>，模型并未针对专门任务进行训练，但是在大量数据集的训练下突然表现出未预料到的新行为或新能力。增加参数量往往会促进涌现行为的出现。</p></blockquote><h2 id="1-5-Building-a-large-language-model">1.5 Building a large language model</h2><p><img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504172235133.png" alt=""></p><h1>零、</h1>]]></content>
    
    
    <categories>
      
      <category>科研学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LLM</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网学习笔记(1)：引言</title>
    <link href="/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/"/>
    <url>/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1>什么是计算机网络</h1><p>a group of <strong>separate but interconnected(相连的)</strong> computers.</p><blockquote><p>可能混淆的概念：</p><ol><li><strong>Distributed Systems 分布式系统</strong>：A software system built on top of a network。一组独立的计算机组成，表现出来就是一台计算机，底层是透明的(不可见的)；</li><li><strong>Computer networks</strong>：一组自主工作的计算机通过一种技术实现互连，所有计算机对用户都是可见的；</li></ol></blockquote><p>计算机网络不是：</p><blockquote><ol><li><strong>Internet 因特网</strong>：通常指全球范围的互联网，即由无数网络和设备组成的庞大系统；</li><li><strong>WWW 万维网</strong>：A distributed system (or an application) running on top of Internet。一种基于计算机网络提供的应用/服务；</li></ol></blockquote><p>注意区分<strong>Internet(因特网)</strong> 和 <strong>internet(互联网)</strong>；</p><h1>QOS(Quality of Service)网络服务质量</h1><ul><li><strong>Latency/Delay 延迟</strong>：绝对时间差</li><li><strong>Jitter 抖动</strong>：不同数据包到达的时间差（相对时间差）</li><li><strong>Bandwidth 带宽</strong>：网络在单位时间内传输的数据量，通常以bps（比特每秒）为单位</li><li><strong>Bit-Error-Rate(BER) 比特差错率</strong>：传输过程中出错的比特数与总比特数的比率</li></ul><blockquote><p>实时视频会议中，比较重要的QOS指标？<br>Latency and Bandwidth；</p></blockquote><h1>计算机网络的硬件组成</h1><ul><li><strong>Nodes</strong>：<ul><li>Computers/Hosts(主机)/End Systems(终端)；</li><li>Switch(交换机)/Routers(路由)；</li></ul></li><li><strong>Communication Links 链路</strong>：有线 or 无线；</li></ul><blockquote><p><strong>Infrastructure network vs. Ad hoc network(自组织网络)</strong>：</p><ol><li>Infrastructure network：基于固定基础设施（如路由器、交换机、接入点）构建的网络；</li><li>Ad hoc network：去中心化的网络，设备直接相互通信，无需依赖固定基础设施；</li></ol></blockquote><h1>计算机网络的分类</h1><h2 id="By-Position：">By Position：</h2><ul><li>Access Network；</li><li>Data Center Network；</li><li>Transmission Network；</li></ul><h2 id="By-Transmission-Tech">By Transmission Tech</h2><ul><li><strong>Unicasting(单播)</strong>：点对点链路，中间设备一般是Router；比如WANS，如果用广播，通信量太大；</li><li>Broadcasting(广播)：Multicasting(多播)；</li></ul><h2 id="By-Scale">By Scale</h2><ul><li>PAN，个域网；蓝牙、RFID等短距射频通信；</li><li>LAN，局域网；Ethernet、WiFi；</li><li>MAN，城域网；cable TV广播电视；</li><li>WAN，广域网；3G、4G、5G；</li><li>The Internet，因特网；特指诞生于美国的全球范围的网络</li></ul><blockquote><p>注意与互联网internet区分，互联网的定义是网络的网络network of networks；</p></blockquote><h1>计算机网络体系结构</h1><p><img src="/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/1.png" alt=""></p><blockquote><p><strong>Tips：一些关键概念</strong></p><ol><li><strong>Protocol协议</strong>：对等层之间约定；</li><li><strong>Interface接口</strong>：相邻两层之间，<em><strong>下层为与其相邻的上一层</strong></em>提供服务/接口；</li><li><strong>Peers对等实体</strong>；</li><li><strong>Network Architecture网络体系结构</strong>：<em><strong>包括Layers和Protocals，不包括Interface，并且协议实现的细节也与体系结构无关；</strong></em></li><li><strong>Protocal Stack协议栈</strong>；</li><li><strong>PDU协议数据单元</strong>：即对等层之间进行虚拟通信的数据包，由协议决定；</li><li><strong>Encapsulation封装</strong>：上一层在往下一层传输时前面或后面加上特定的<em><strong>控制消息头</strong></em>，构成本层的数据包(<em><strong>PDU协议数据单元</strong></em>)；</li></ol></blockquote><h1>服务分类</h1><h2 id="Connetcion-Oriented-面向连接">Connetcion-Oriented 面向连接</h2><ol><li>先建立连接；</li><li>再传送数据（Message报文 &amp;&amp; Packet）；</li><li>最后释放资源；</li></ol><blockquote><p>特点是传输的顺序是固定的，较为可靠；</p></blockquote><h2 id="Connectionless">Connectionless</h2><blockquote><p>特点是动态分配资源（数据传输到了再分配），每条消息和包都需要携带完整的目标地址，数据易丢失；</p></blockquote><h2 id="服务原语Service-Primitives">服务原语Service Primitives</h2><blockquote><p>基本概念：</p><ol><li>Service Provider(Layer $n$)，Service User(Layer $n + 1$)；</li><li>SAP：Service Access Point服务访问点，即接口Interface；</li></ol></blockquote><p>服务原语：<br><img src="/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/2.png" alt=""></p><h3 id="DNS解析的例子">DNS解析的例子</h3><p><img src="/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/3.png" alt=""></p><h3 id="浏览网页的例子">浏览网页的例子</h3><p><img src="/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/4.png" alt=""></p><h2 id="服务和协议的关系">服务和协议的关系</h2><ul><li>该层协议的实现需要下层服务的服务，即下层服务的变化可能会影响上一层协议的实现；</li><li>该层协议的实现需要本层服务的支持；</li><li>该层服务不变时，本层协议实现变化不影响上层；</li></ul><h1>参考模型</h1><h2 id="OSI模型">OSI模型</h2><p><img src="/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/5.png" alt=""></p><ul><li>通过中间的路由传输时实际只涉及物理层1、数据链路层2、网络层3；</li><li>只有两端的节点涉及传输层4、会话层5、表示层6、应用层7；<br><img src="/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/6.png" alt=""></li></ul><h2 id="TCP-IP模型">TCP/IP模型</h2><p>标准定义是4层：Application、Transport、Internet网际层、Link；</p><blockquote><p><strong>Internet网际层</strong>：packet switching、connectionless；<em><strong>IP(Internet Protocol)</strong></em>；<br><strong>Transport</strong>：<em><strong>TCP(Transmission Control Protocol)</strong></em>、<em><strong>UDP(User Datagram Protocol)</strong></em>；</p><blockquote><p><strong>TCP</strong>：connection-oriented；<br><strong>UDP</strong>：connectionless；</p></blockquote></blockquote><p><img src="/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/7.png" alt=""></p><h2 id="Hybrid-Model混合模型">Hybrid Model混合模型</h2><p>5层，在TCP/IP的基础上将物理层划分了出来；<br>Application Layer；Transport Layer；Network Layer；Data Link Layer；Physical Layer；</p><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');// 可以在这里添加额外的回调函数});</script>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组学习笔记(1)：计算机概述</title>
    <link href="/2025/02/27/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/"/>
    <url>/2025/02/27/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1>计算机性能指标</h1><ol><li><strong>处理器字长</strong>：运算器中一次能完成的二进制数运算的位数；</li><li><strong>总线宽度</strong>：数据总线的宽度，即处理器与存储器之间进行互连用于传送数 据的信号线数；</li><li><strong>存储器容量</strong>；</li><li><strong>存储器带宽</strong>：单位时间内从存储器读取的字节数（类似网络带宽），单位字节/秒；</li><li><strong>主频/时钟周期</strong>：CPU的工作节拍受主时钟控制，主时钟的频率称为CPU的主频，单位是MHz($10^6$)、GHz($10^9$)；主频的倒数称为CPU时钟周期；</li><li><strong>吞吐量</strong>：单位时间内能够完成的任务数，也称为带宽；</li><li><strong>利用率</strong>：在给定的时间间隔内系统被实际使用的时间所占的 比率，用百分比表示；</li><li><strong>响应时间</strong>：计算机完成某任务的总时间，包括硬盘访问、 内存访问、I/O活动、操作系统开销和CPU执行时间。也称为执行时间；</li><li><strong>CPU执行时间</strong>：特指执行某一任务在CPU上花的时间，又分为用户CPU时间(程序执行时花费的CPU时间)和系统CPU时间(为执行程序而花费在操作系统上的时间)；</li><li><strong>CPI(Clock Cycles Per Instruction)</strong>：单条指令需要花费的CPU时钟周期数，事实上是平均数，即 CPI = 程序执行所需的CPU时钟周期总数 / 程序的指令总数；</li><li><strong>CPU性能公式</strong>： 程序的CPU执行时间 = 程序的指令数 $\times$ CPI $\times$ 时钟周期长度；</li><li><strong>MIPS 每秒百万指令数</strong>：MIPS = 指令总数 / 程序执行时间 $\times 10^{-6}$；</li><li><strong>MFLOPS</strong>：每秒百万次浮点操作次；</li><li><strong>TFLOPS</strong>：每秒万亿次浮点操作次；</li></ol><script>window.addEventListener('hexo-blog-decrypt', function() {console.log('文章已成功解密！');// 可以在这里添加额外的回调函数});</script>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAG（Retrieval-augmented generation）个人学习笔记</title>
    <link href="/2025/02/22/RAG%EF%BC%88Retrieval-augmented%20generation%EF%BC%89%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/02/22/RAG%EF%BC%88Retrieval-augmented%20generation%EF%BC%89%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>为什么需要RAG？</h1><p>传统的LLM模型主要存在以下2个问题：幻觉以及外部知识/最新知识的缺失，RAG可以通过结合基于检索和生成模型的优势来提供更准确和上下文相关的响应，可以添加自己的预料构建知识库。</p><h1>RAG vs. fine-tuning a LLM model</h1><p>下图源自<a href="https://github.com/Tongji-KGLLM/RAG-Survey/">RAG-Survey</a><br><img src="./RAG%EF%BC%88Retrieval-augmented%20generation%EF%BC%89%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RAG_FT_Table.jpg" alt=""><br>结合个人理解：</p><ol><li>RAG更适合知识库需要动态更新的情景，这部分数据不作为用于LLM的训练数据，而是通过LLM的能力进行检索。</li><li>RAG由于采用检索的形式，数据来源是可知的，而LLM是黑箱。</li><li>RAG 可以对生成过程提供更多控制。</li></ol><h1>Query Classification 查询分类</h1><p>并非所有查询都需要用到检索增强，需要将查询分类为需要使用RAG和直接用LLM生成两类。</p><blockquote><p>持续更新中…</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>科研学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>RAG</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSFC爬虫练习</title>
    <link href="/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/"/>
    <url>/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>需求</h1><p>从国家自然科学基金大数据知识管理服务门户爬取论文数据。</p><h1>搜索API</h1><ol><li>打开浏览器的<strong>开发者工具</strong>（如 Chrome 的 F12）；</li><li>在网络（Network）选项卡中，监控搜索的请求；</li><li>找到接口()[<a href="https://kd.nsfc.cn/api/baseQuery/completionQueryResultsData">https://kd.nsfc.cn/api/baseQuery/completionQueryResultsData</a>]；</li><li>其请求体如下：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;A01&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;fuzzyKeyword&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;complete&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;isFuzzySearch&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;conclusionYear&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2020&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;dependUnit&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;pageNum&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;pageSize&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;personInCharge&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;projectName&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;projectType&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;218&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;subPType&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;psPType&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ratifyNo&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ratifyYear&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;order&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;enddate&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;ordering&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;desc&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;codeScreening&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;dependUnitScreening&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;keywordsScreening&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;projectTypeNameScreening&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>需要用到的字段只有：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">code <span class="hljs-comment">// 申请代码</span><br>conclusionYear <span class="hljs-comment">// 结题年度</span><br>projectType <span class="hljs-comment">// 资助类别</span><br></code></pre></td></tr></table></figure><ol start="5"><li>观察其返回内容：<img src="/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/1.png" alt="">为一串无规律的长字符串，初步判断是经过了某种加密；</li></ol><h1>解密</h1><p>页面的HTML文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>We&#x27;re sorry but 国家自然科学基金大数据知识管理服务门户 doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/chunk-vendors.559d99e0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/app.17b88e26.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在网页的 JavaScript 文件中，尝试寻找相关的解密代码，最终在app.17b88e26.js中找到以下内容（注释为后期补充）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 定义密钥</span><br>    <span class="hljs-keyword">var</span> t = p.<span class="hljs-property">a</span>.<span class="hljs-property">enc</span>.<span class="hljs-property">Utf8</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&quot;IFROMC86&quot;</span>);<br>    <br>    <span class="hljs-comment">// 使用 DES 解密方法</span><br>    <span class="hljs-keyword">var</span> n = p.<span class="hljs-property">a</span>.<span class="hljs-property">DES</span>.<span class="hljs-title function_">decrypt</span>(<br>        &#123;<br>            <span class="hljs-attr">ciphertext</span>: p.<span class="hljs-property">a</span>.<span class="hljs-property">enc</span>.<span class="hljs-property">Base64</span>.<span class="hljs-title function_">parse</span>(e) <span class="hljs-comment">// 解析 Base64 编码的密文</span><br>        &#125;,<br>        t, <span class="hljs-comment">// 解密密钥</span><br>        &#123;<br>            <span class="hljs-attr">mode</span>: p.<span class="hljs-property">a</span>.<span class="hljs-property">mode</span>.<span class="hljs-property">ECB</span>, <span class="hljs-comment">// 使用 ECB 模式</span><br>            <span class="hljs-attr">padding</span>: p.<span class="hljs-property">a</span>.<span class="hljs-property">pad</span>.<span class="hljs-property">Pkcs7</span> <span class="hljs-comment">// 使用 PKCS7 填充方式</span><br>        &#125;<br>    );<br><br>    <span class="hljs-comment">// 将解密后的内容解析为 UTF-8 字符串并转为 JSON</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(n.<span class="hljs-title function_">toString</span>(p.<span class="hljs-property">a</span>.<span class="hljs-property">enc</span>.<span class="hljs-property">Utf8</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Python 的 pycryptodome 库来实现解密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pycryptodome<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> DES<br><span class="hljs-keyword">from</span> Crypto.Util.Padding <span class="hljs-keyword">import</span> unpad<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decrypt_des_ecb</span>(<span class="hljs-params">ciphertext</span>):<br>    <span class="hljs-comment"># 密钥</span><br>    key = <span class="hljs-string">b&quot;IFROMC86&quot;</span><br>    <span class="hljs-comment"># Base64 解码</span><br>    encrypted_data = base64.b64decode(ciphertext)<br>    <br>    <span class="hljs-comment"># 初始化 DES 解密器</span><br>    cipher = DES.new(key, DES.MODE_ECB)<br>    <br>    <span class="hljs-comment"># 解密数据并移除填充</span><br>    decrypted_data = unpad(cipher.decrypt(encrypted_data), DES.block_size)<br>    <br>    <span class="hljs-comment"># 解密后的字符串转为 JSON 格式</span><br>    <span class="hljs-keyword">return</span> json.loads(decrypted_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure><p>对网页发送请求，成功得到解密后的JSON文件：<br><img src="/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/2.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>开发心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文白嫖阿里云服务器+配置基本开发环境+博客等服务部署</title>
    <link href="/2025/01/17/%E4%B8%80%E6%96%87%E7%99%BD%E5%AB%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8+%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83+%E5%8D%9A%E5%AE%A2%E7%AD%89%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"/>
    <url>/2025/01/17/%E4%B8%80%E6%96%87%E7%99%BD%E5%AB%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8+%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83+%E5%8D%9A%E5%AE%A2%E7%AD%89%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1>零、~~（白嫖）~~步骤</h1><p>阿里云的学生优惠会送一张无门槛300元代金券（传送门： <a href="https://university.aliyun.com/">阿里云高校计划_云工开物_助力高校科研与教育加速-阿里云</a> ），刚好够白嫖用券专区中的小服务器一整年（还多出15块可以买个20g的流量包）；个人配置如下：</p><ul><li><strong>实例规格</strong>：<a href="https://help.aliyun.com/document_detail/25378.html?spm=5176.ecscore_server.0.0.38314df5CTmW3g#e">ecs.e-c1m1.large</a>；</li><li><strong>CPU&amp;内存</strong>：2核2G；</li><li><strong>操作系统</strong>：Ubuntu 22.04 LTS 64位；</li><li><strong>带宽计费方式</strong>：按使用流量；</li><li><strong>公网带宽</strong>：5 Mbps；</li></ul><blockquote><p><s><strong>注</strong>：别选固定带宽，这是另外的价钱；</s></p></blockquote><p>白嫖完后，进入配置；</p><h1>一、本地远程连接</h1><h2 id="1-1-密钥对认证">1.1 密钥对认证</h2><p>由于本人采用密钥对进行认证，在创建并绑定密钥对后会自动下载一个 <code>.pem</code> 的文件到本地，ssh连接需要采用以下方式：</p><ol><li>直接连接：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -i ~/.ssh/你的私钥文件 用户名@服务器IP<br></code></pre></td></tr></table></figure><ol start="2"><li>简化连接方式</li></ol><p>每次手动输入私钥文件显然过于不便了，我们可以将私钥文件添加到SSH配置文件中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.ssh/config<br></code></pre></td></tr></table></figure><p>增加配置如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host 服务器别名(随便取)<br>  HostName 服务器IP <br>  <span class="hljs-keyword">User</span> <span class="hljs-title">用户名 </span><br><span class="hljs-title">  IdentityFile</span> ~/.ssh/你的私钥文件 <br>  Port <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>按下 <code>^x</code> 和 <code>y</code> 保存后，可以直接采用服务器别名连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh 服务器别名<br></code></pre></td></tr></table></figure><h2 id="1-2-常见问题">1.2 常见问题</h2><ol><li>连接时报错：</li></ol><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">Warning: Permanently added <span class="hljs-string">&#x27;你的服务器IP&#x27;</span> (ED25519) to the list of known hosts. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions <span class="hljs-number">0644</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;你的私钥文件地址&#x27;</span> are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Load key <span class="hljs-string">&quot;你的私钥文件地址&quot;</span>: bad permissions 用户名@服务器IP: Permission denied (publickey).<br></code></pre></td></tr></table></figure><p>这是因为SSH出于安全考虑，要求私钥文件的权限必须足够严格，不允许其他用户访问。你需要修改私钥文件的权限，确保只有你自己可以读取和写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 ~/.ssh/你的私钥文件<br></code></pre></td></tr></table></figure><h1>二、基本环境配置</h1><h2 id="2-1-基本工具安装">2.1 基本工具安装</h2><ol><li>系统更新</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt upgrade -y<br></code></pre></td></tr></table></figure><ol start="2"><li>基本工具安装（有些已经自带）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install -y build-essential curl wget git vim htop net-tools<br></code></pre></td></tr></table></figure><ol start="3"><li>防火墙配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install -y ufw<br><span class="hljs-built_in">sudo</span> ufw allow ssh<br><span class="hljs-built_in">sudo</span> ufw allow http<br><span class="hljs-built_in">sudo</span> ufw allow https<br><span class="hljs-built_in">sudo</span> ufw <span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure><h2 id="2-2-安装Docker">2.2 安装Docker</h2><p>以下步骤也可以直接参考 <a href="https://docs.docker.com/engine/install/ubuntu/">Docker 官方文档</a>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装所需依赖</span><br><span class="hljs-built_in">sudo</span> apt install -y apt-transport-https ca-certificates gnupg lsb-release<br><br><span class="hljs-comment"># 添加 Docker 的官方 GPG 密钥（通过阿里云镜像）</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /etc/apt/keyrings &amp;&amp; \<br>curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | <span class="hljs-built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg &amp;&amp; \<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null &amp;&amp; \<br><span class="hljs-built_in">sudo</span> apt-get update<br><br><span class="hljs-comment"># 安装最新的 Docker</span><br><span class="hljs-built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure><h3 id="常见问题">常见问题</h3><p>由于运营商网络等不稳定因素可能导致镜像加速器无法成功拉取到指定版本的容器镜像，阿里云提供了免费的镜像加速器，配置步骤如下：</p><ol><li>登录<a href="https://cr.console.aliyun.com/?spm=a2c4g.11186623.0.0.27881d82EVUzaG">容器镜像服务控制台</a>。</li><li>在左侧导航栏选择<strong>镜像工具</strong> &gt; <strong>镜像加速器</strong></li><li>在<strong>镜像加速器</strong>页面获取<strong>加速器地址</strong>。</li></ol><p>接下来，在云服务器上更新 Docker 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /etc/docker <br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span> <br>&#123; <br><span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;你的镜像加速器地址&quot;</span>] <br>&#125; <br>EOF<br><span class="hljs-built_in">sudo</span> systemctl daemon-reload <br><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><p>最后，验证是否可以成功拉取 Docker Hub镜像：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><p>如果看到以下输出，说明成功拉取！</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Hello <span class="hljs-keyword">from</span> Docker!<br>This message shows <span class="hljs-keyword">that</span> your installation appears <span class="hljs-keyword">to</span> be working correctly.<br></code></pre></td></tr></table></figure><h2 id="2-3-配置-git">2.3 配置 git</h2><ol><li>这里采用使用 SSH 密钥认证，首先在云服务器上生成 SSH 密钥对；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>可以直接一路回车到底，默认情况下，密钥会保存到 <code>~/.ssh/id_rsa</code>；</p><ol start="2"><li>将公钥添加到 GitHub 账户</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看公钥内容</span><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>复制后，登录到 <strong>GitHub</strong>，进入 <strong>Settings</strong> -&gt; <strong>SSH and GPG keys</strong>，点击 <strong>New SSH key</strong>，将公钥复制到 GitHub 的文本框中并保存；</p><ol start="3"><li>验证连接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 测试连接</span><br>ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果配置成功，会观察到输出如下信息：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi username! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><h2 id="2-4-安装-Anaconda">2.4 安装 Anaconda</h2><ol><li>下载 Anaconda 的安装包</li></ol><p>你可以在 <a href="https://repo.anaconda.com/archive/">官网</a> 自行查找需要的版本，替换以下链接即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://repo.anaconda.com/archive/Anaconda3-2024.10-1-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><ol start="2"><li>安装anaconda</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 授予可执行权限</span><br><span class="hljs-built_in">chmod</span> +x Anaconda3-2024.10-1-Linux-x86_64.sh<br><br><span class="hljs-comment"># 执行</span><br>./Anaconda3-2024.10-1-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>然后疯狂回车（中间需要输入一次yes）即可；</p><ol start="3"><li>验证安装</li></ol><p>打开新的终端，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda --version<br></code></pre></td></tr></table></figure><p>如果输出正确的 conda 版本，则说明安装成功并且正确配置环境变量；</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> <span class="hljs-number">24</span>.<span class="hljs-number">9</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2-5-安装-MySQL">2.5 安装 MySQL</h2><ol><li>安装 MySQL APT 存储库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> wget https://dev.mysql.com/get/mysql-apt-config_0.8.33-1_all.deb<br></code></pre></td></tr></table></figure><ol start="2"><li>安装 MySQL 服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装 MySQL 服务器</span><br><span class="hljs-built_in">sudo</span> apt install -y mysql-server<br><span class="hljs-comment">#启动 MySQL 服务</span><br><span class="hljs-built_in">sudo</span> systemctl start mysql<br><span class="hljs-comment">#检查启动状态</span><br><span class="hljs-built_in">sudo</span> systemctl status mysql<br><span class="hljs-comment">#在系统启动时自动启动。</span><br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> mysql<br></code></pre></td></tr></table></figure><ol start="3"><li>安装安全向导（可选）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql_secure_installation<br></code></pre></td></tr></table></figure><p>它会让你自信选择安全策略，包括如下内容：</p><ul><li>Would you like to setup VALIDATE PASSWORD component?<ul><li>是否需要启用 <code>VALIDATE PASSWORD</code> 组件？</li></ul></li><li>There are three levels of password validation policy:<ul><li>LOW    Length &gt;= 8</li><li>MEDIUM Length &gt;= 8, numeric, mixed case, and special characters</li><li>STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary file</li><li>这里选择输入 2 ，表示设置密码策略要求密码至少包含一个大写字母、一个小写字母、一个数字和一个特殊字符，并且密码总长度至少为8个字符；</li></ul></li><li>Remove anonymous users?<ul><li>是否移除匿名用户？</li><li>这里输入 y ，表示移除；</li></ul></li><li>Disallow root login remotely?<ul><li>禁止MySQL的 <code>root</code> 用户从远程登录；</li><li>这里选择 y；</li></ul></li><li>Remove test database and access to it?<ul><li>是否需要移除MySQL自带的 <code>test</code> 数据库？</li><li>无所谓，删了吧；</li></ul></li><li>Reload privilege tables now?<ul><li>输入 y ，重新加载权限表，使得更改生效；</li></ul></li></ul><ol start="4"><li>配置安全组规则</li></ol><p>配置安全组时，MySQL 默认使用3306端口。确保实例安全组的入站规则开放3306端口。如果选择了不同的端口，请根据实际情况调整安全组设置。具体步骤请参考<a href="https://help.aliyun.com/zh/ecs/user-guide/add-a-security-group-rule#concept-sm5-2wz-xdb">添加安全组规则</a>。</p><ol start="5"><li>添加用于远程访问的用户</li></ol><p>将以下输入的 <code>&lt;username&gt;</code> 和 <code>&lt;password&gt;</code> 部分自行修改；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql -uroot -p \<br>-e <span class="hljs-string">&quot;CREATE USER &#x27;&lt;username&gt;&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;&lt;password&gt;&#x27;;&quot;</span> \<br>-e <span class="hljs-string">&quot;GRANT ALL PRIVILEGES ON *.* TO &#x27;&lt;username&gt;&#x27;@&#x27;%&#x27; WITH GRANT OPTION;&quot;</span> \<br>-e <span class="hljs-string">&quot;FLUSH PRIVILEGES;&quot;</span><br></code></pre></td></tr></table></figure><p>执行后需要输入 root 账户的密码；</p><ol start="6"><li>登录 mysql 账户验证</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mysql -u &lt;username&gt; -p<br></code></pre></td></tr></table></figure><p>输入密码后，进入 mysql 环境，成功！</p><p>输入以下内容可以退出 mysql 环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit;<br></code></pre></td></tr></table></figure><h2 id="2-6-配置-Node-js-开发环境">2.6 配置 Node.js 开发环境</h2><ol><li>下载 NVM 源码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://gitee.com/mirrors/nvm.git ~/.nvm &amp;&amp; <span class="hljs-built_in">cd</span> ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags`<br></code></pre></td></tr></table></figure><ol start="2"><li>配置环境变量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> sh -c <span class="hljs-string">&#x27;echo &quot;. ~/.nvm/nvm.sh&quot; &gt;&gt; /etc/profile&#x27;</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><ol start="3"><li>设置镜像源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node<br></code></pre></td></tr></table></figure><ol start="4"><li>自行下载所需版本，例如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install v23.3.0<br></code></pre></td></tr></table></figure><p>若观察到以下输出，说明安装成功：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Computing</span> checksum with sha256sum<br><span class="hljs-attribute">Checksums</span> matched!<br><span class="hljs-attribute">Now</span> using node v23.<span class="hljs-number">3</span>.<span class="hljs-number">0</span> (npm v10.<span class="hljs-number">9</span>.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">Creating</span> default alias: default -&gt; v23.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="2-7-配置-Java-环境">2.7 配置 Java 环境</h2><ol><li>安装所需版本的JDK（以Java 1.8 为例）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install -y openjdk-8-jdk<br></code></pre></td></tr></table></figure><p>如果需要下载其他版本，可以运行以下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt search openjdk<br></code></pre></td></tr></table></figure><ol start="2"><li>验证安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version<br></code></pre></td></tr></table></figure><h2 id="2-8-Screen-工具">2.8 Screen 工具</h2><p>在通过 Scp 等远程传输文件时，特别是大文件时，往往因为 SSH 连接不稳定而导致中断。而 Screen 工具提供了从单个 SSH 会话中使用多个 shell 窗口的能力。当会话被分离或网络中断时 Screen 会话中启动的进程仍将运行，我们可以随时重新连接到 Screen 会话。</p><ol><li>安装 Screen</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install screen<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个会话</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><ol start="3"><li>挂起一个会话</li></ol><p>按下 <code>Ctrl</code> + <code>a</code> + <code>d</code> 即可保持这个 Screen 到后台并回到我们 SSH 的主终端；</p><ol start="4"><li>恢复一个会话</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -r -d <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>即可重新进入该 Screen；</p><ol start="5"><li>查看已经存在的 Screen 终端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -<span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><h2 id="2-9-安装-Nginx-环境">2.9 安装 Nginx 环境</h2><ol><li>使用 Nginx 官方源安装；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#更新系统已安装软件并更新包管理工具</span><br><span class="hljs-built_in">sudo</span> apt update -y<br><span class="hljs-comment">#Nginx安装前必要环境</span><br><span class="hljs-built_in">sudo</span> apt install -y curl gnupg2 ca-certificates lsb-release ubuntu-keyring<br><span class="hljs-comment">#导入官方Nginx签名密钥</span><br>curl https://nginx.org/keys/nginx_signing.key | gpg --dearmor | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /usr/share/keyrings/nginx-archive-keyring.gpg &gt;/dev/null<br><span class="hljs-comment">#设置apt仓库</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] http://nginx.org/packages/ubuntu `lsb_release -cs` nginx&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nginx.list<br><span class="hljs-comment">#安装nginx</span><br><span class="hljs-built_in">sudo</span> apt install -y nginx<br></code></pre></td></tr></table></figure><p>接下来根据实际需要修改配置文件；</p><h1>三、搭建 Cloudreve 云盘</h1><h2 id="3-1-快速部署">3.1 快速部署</h2><p>下载 Cloudreve 发布版本，你可以自行从 <a href="https://github.com/cloudreve/Cloudreve/releases">Release</a> 选择适合你的操作系统的；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/cloudreve/Cloudreve/releases/download/3.8.3/cloudreve_3.8.3_linux_amd64.tar.gz<br><br><span class="hljs-comment"># 创建程序目录</span><br><span class="hljs-built_in">mkdir</span> -p /usr/local/cloudreve<br><br><span class="hljs-comment"># 解压获取到的主程序到所在目录</span><br>tar -zxvf cloudreve_3.8.3_linux_amd64.tar.gz -C /usr/local/cloudreve<br><br><span class="hljs-built_in">cd</span> /usr/local/cloudreve<br><span class="hljs-comment"># 赋予执行权限</span><br><span class="hljs-built_in">chmod</span> +x ./cloudreve<br><br><span class="hljs-comment"># 启动 Cloudreve</span><br>./cloudreve<br></code></pre></td></tr></table></figure><p>观察到以下输出，说明启动成功：<img src="https://raw.githubusercontent.com/Yokumii/MyPicBucket/img/img/202504072229775.png" alt=""></p><p>在首次启动时，会创建初始管理员账号，请注意保管下方的管理员密码，<em><strong>此密码只会在首次启动时出现</strong></em>；</p><p>Cloudreve 默认会监听<code>5212</code>端口，你可以在浏览器中访问 <code>http://服务器IP:5212</code> 进入 Cloudreve。注意需要增加阿里云服务器的安全组规则。</p><h2 id="3-2-启动进程守护">3.2 启动进程守护</h2><ol><li>编辑配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /usr/lib/systemd/system/cloudreve.service<br><br>[Unit]<br>Description=Cloudreve<br>Documentation=https://docs.cloudreve.org<br>After=network.target<br>After=mysqld.service<br>Wants=network.target<br><br>[Service]<br>WorkingDirectory=/usr/local/cloudreve<br>ExecStart=/usr/local/cloudreve/cloudreve<br>Restart=on-abnormal<br>RestartSec=5s<br>KillMode=mixed<br><br>StandardOutput=null<br>StandardError=syslog<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ol start="2"><li>更新配置并启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新配置</span><br>systemctl daemon-reload<br><br><span class="hljs-comment"># 启动服务</span><br>systemctl start cloudreve<br><br><span class="hljs-comment"># 设置开机启动</span><br>systemctl <span class="hljs-built_in">enable</span> cloudreve<br></code></pre></td></tr></table></figure><ol start="3"><li>管理命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动服务</span><br>systemctl start cloudreve<br><br><span class="hljs-comment"># 停止服务</span><br>systemctl stop cloudreve<br><br><span class="hljs-comment"># 重启服务</span><br>systemctl restart cloudreve<br><br><span class="hljs-comment"># 查看状态</span><br>systemctl status cloudreve<br></code></pre></td></tr></table></figure><ol start="4"><li>访问前端服务</li></ol><p>通过  <code>https://你的服务器IP:5212</code> 即可访问；</p><h1>四、部署 hexo 博客</h1><blockquote><p>纯纯自用罢了；</p></blockquote><h2 id="4-1-服务端-git-的有关配置">4.1 服务端 git 的有关配置</h2><ol><li>创建一个单独的用户用于管理仓库；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> adduser git<br><span class="hljs-built_in">sudo</span> passwd git<br></code></pre></td></tr></table></figure><ol start="2"><li>设置 git 用户 sudo 权限；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 740 /etc/sudoers<br><span class="hljs-built_in">sudo</span> vim /etc/sudoers<br></code></pre></td></tr></table></figure><p>添加一行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>) <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure><p>按下 <code>:wq</code> 保存更改，然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 400 /etc/sudoers<br></code></pre></td></tr></table></figure><ol start="3"><li>上传公钥到服务器并添加到 git 用户</li></ol><p>在本机执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp ~/.ssh/id_rsa.pub root@&lt;你的服务器IP&gt;:/home/git/tempkey.pub -i ~/.ssh/你的私钥文件.pem<br></code></pre></td></tr></table></figure><p>然后登录服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh 你的服务器别名<br><span class="hljs-built_in">sudo</span> su - git<br><span class="hljs-built_in">mkdir</span> -p ~/.ssh<br><span class="hljs-built_in">cat</span> ~/tempkey.pub &gt;&gt; ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><p>你同样可以在本机化简配置：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host 你的服务器别名_2<br>  HostName 你的服务器公网IP<br>  <span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br>  IdentityFile ~/.ssh/id_rsa<br>  Port <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><h2 id="4-2-配置-Git-仓库和部署钩子">4.2 配置 Git 仓库和部署钩子</h2><ol><li>初始化一个裸仓库；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">su git<br><span class="hljs-built_in">cd</span> ~<br>git init --bare hexo.git<br></code></pre></td></tr></table></figure><ol start="2"><li>添加 post-receive 自动部署钩子；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi ~/hexo.git/hooks/post-receive<br></code></pre></td></tr></table></figure><p>输入以下内容并保存退出（:wq）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>GIT_WORK_TREE=/data/hexo git checkout -f<br></code></pre></td></tr></table></figure><p>赋予执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ~/hexo.git/hooks/post-receive<br></code></pre></td></tr></table></figure><ol start="3"><li>创建部署目录并授权</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /data/hexo<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> -R git:git /data/hexo<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> -R 755 /data/hexo<br></code></pre></td></tr></table></figure><h2 id="4-3-Hexo-配置">4.3 Hexo 配置</h2><h3 id="4-3-x-关于资源文件夹的问题">4.3.x 关于资源文件夹的问题</h3><p>当然，使用图床等工具，直接在 markdown 中插入外链是最方便的，并且不用担心在博客迁移时发生问题。不过如果你想要保存图片在本地，那么可以参考如下方法：</p><ol><li>保存图片在 <code>source/</code> 文件夹下；</li></ol><p>这是肯定的，区别只是在于后面的引用格式问题；</p><ol start="2"><li>如果图片的目录为 <code>source/img/example.png</code> ；</li></ol><p>那么，默认配置下，你的引用格式应该为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">img/example.png</span>)<br></code></pre></td></tr></table></figure><p>如果你希望不同文章的图片保存在不同目录，你可以自行修改保存路径和相应的引用格式（<strong>注意是相对于 source 文件夹的路径</strong>）；当然，你也可以使用 Hexo 提供的配置方式，将配置文件 <code>_config.yml</code> 修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>但你每次通过命令行新建一个文章时，它会自动在 <code>_posts</code> 文件夹下生成一个同名文件夹，你可以将文章图片都放在该文件夹中，此时引用格式为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">example.png</span>)<br></code></pre></td></tr></table></figure><p>但是，这并不是特别方便，特别是对于需要通过别的阅读器，比如 Typora 等进行阅读。如果你希望维持相对路径格式又能对图片进行分类，你可以通过修改 Typora 设置来进行，但我推荐使用插件 <code>hexo-asset-link</code> 插件，这个插件可以保留你原本写的路径结构，即：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](<span class="hljs-link">./文章名/example.png</span>)<br></code></pre></td></tr></table></figure><p>安装和配置方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-asset-link --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中添加：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">asset_link:</span><br>  <span class="hljs-params">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>重新生成并部署即可！</p><blockquote><p>其余部分暂略；</p></blockquote><h2 id="4-4-部署-Hexo-博客">4.4 部署 Hexo 博客</h2><h3 id="4-4-x-部署-Hexo-博客到云服务器">4.4.x 部署 Hexo 博客到云服务器</h3><ol><li>安装 <code>hexo-deployer-git</code> 插件；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ol start="2"><li>修改 <code>_config.yml</code> 中的 deploy 部分；</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@你的服务器别名_2:<span class="hljs-keyword">/home/</span>git/hexo.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><ol start="3"><li>运行以下命令进行部署；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><p>或直接写成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo c &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ol start="4"><li>修改 Nginx 配置文件；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">user</span>  nginx;<br><span class="hljs-attribute">worker_processes</span>  auto;<br><br><span class="hljs-attribute">error_log</span>  /var/log/nginx/<span class="hljs-literal">error</span>.log <span class="hljs-literal">notice</span>;<br><span class="hljs-attribute">pid</span>        /var/run/nginx.pid;<br><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span>  <span class="hljs-number">1024</span>;<br>&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span>       /etc/nginx/mime.types;<br>    <span class="hljs-attribute">default_type</span>  application/octet-stream;<br><br>    <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] &quot;<span class="hljs-variable">$request</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;<br><br>    <span class="hljs-attribute">access_log</span>  /var/log/nginx/access.log  main;<br><br>    <span class="hljs-attribute">sendfile</span>        <span class="hljs-literal">on</span>;<br>    <span class="hljs-attribute">keepalive_timeout</span>  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-attribute">include</span> /etc/nginx/conf.d/<span class="hljs-regexp">*.conf</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>修改虚拟主机配置；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/nginx/conf.d/default.conf<br></code></pre></td></tr></table></figure><p>如果没有域名，则修改为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>        <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>   [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  你的公网IP;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /data/hexo;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果仅有域名，则修改为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>        <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>   [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  yourdomain.com;<br>  <br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /data/hexo;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你有域名并申请过 SSL 安全证书，则修改为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>        <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>   [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  yourdomain.com;<br><br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)$</span> https://<span class="hljs-variable">$&#123;server_name&#125;</span><span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span> yourdomain.com;<br><br>    <span class="hljs-attribute">ssl_certificate</span>     /path/to/your/cert.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /path/to/your/key.pem;<br><br>    <span class="hljs-attribute">ssl_session_cache</span>   shared:SSL:<span class="hljs-number">1m</span>;<br>    <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;<br>    <span class="hljs-attribute">ssl_ciphers</span>         HIGH:!aNULL:!MD5;<br>    <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /data/hexo;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>        <span class="hljs-attribute">proxy_set_header</span>   X-Real-IP        <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>   Host             <span class="hljs-variable">$http_host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>   X-Forwarded-For  <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意将上面的域名、SSL 证书的路径字段替换为你实际的。</p><ol start="5"><li>启动 Nginx 进程；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start nginx<br><span class="hljs-built_in">sudo</span> systemctl status nginx<br><span class="hljs-built_in">sudo</span> systemctl reload nginx<br></code></pre></td></tr></table></figure><p>阿里云服务器一般默认开放了 80 和 443 端口，如果服务商不同，请自行开放防火墙；</p><ol start="6"><li>配置域名解析（如果没有域名，则无需进行这一步）；</li></ol><p>如果你使用的是阿里云的 DNS，那么你需要登录域名管理后台，添加一条 A 记录：</p><table><thead><tr><th><strong>主机记录</strong></th><th><strong>类型</strong></th><th><strong>记录值</strong></th><th><strong>TTL</strong></th></tr></thead><tbody><tr><td>blog</td><td>A</td><td>你的公网IP</td><td>600(s)</td></tr></tbody></table><p>解析是否生效可以通过以下命令进行验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping yourdomain.com<br></code></pre></td></tr></table></figure><p>如果你的域名 DNS 指向了非服务商，比如我使用了 <strong>Cloudflare 的 DNS</strong>，那么你需要在 Cloudflare 的控制面板中设置，添加 A 记录：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>主机名</strong></th><th><strong>内容（IP 地址）</strong></th><th><strong>TTL</strong></th><th><strong>代理状态</strong></th></tr></thead><tbody><tr><td>A</td><td>blog</td><td>你的服务器公网IP</td><td>自动</td><td>关闭小云朵（点一下变灰）</td></tr></tbody></table><p>说明：如果你只是做博客访问，<strong>把“代理状态”的小云朵关闭（变灰）</strong>，否则 Nginx 会收到 Cloudflare 的 IP 而不是你用户的真实 IP；</p><p><strong>特别说明：</strong></p><blockquote><p>如果你使用的是中国大陆的服务器，那么需要提交备案申请，<strong>未备案域名将无法通过 HTTP/HTTPS 正常访问</strong>，云服务商会限制端口 80 和 443。如果你想通过云服务器部署个人博客，请遵循有关规定。<s>不过我懒。</s></p></blockquote><p><strong>补充：</strong></p><blockquote><p>备案时应该要求你的域名 DNS 指向阿里云 DNS，否则存在不通过的风险。（我记得备案的时候用途就不能写个人博客来着）</p></blockquote><h3 id="4-4-y-配置服务到-Github-Page-或其他托管平台">4.4.y 配置服务到 Github Page 或其他托管平台</h3><p>把 Hexo 部署到 GitHub Pages 或其他托管平台并绑定你的域名也同样可行且省事，而且完全免费、无需备案。</p><ol><li>新建一个 Github 仓库；</li></ol><p>命名为：（啥也不用勾选，空的公开仓库即可）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">XXX.github.<span class="hljs-built_in">io</span><br></code></pre></td></tr></table></figure><ol start="2"><li>修改 Hexo 的配置文件；</li></ol><p>将 deploy 部分改为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> 你的仓库地址<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><blockquote><p>如果你默认 GitHub 用 master 分支，那就把 branch 改为 master 即可；</p></blockquote><ol start="3"><li>绑定域名；</li></ol><p>首先，添加一个名为 CNAME 的文件到 source 目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;yourdomain.com&quot;</span> &gt; <span class="hljs-built_in">source</span>/CNAME<br></code></pre></td></tr></table></figure><p>登录 Cloudflare ，添加如下记录：</p><table><thead><tr><th><strong>类型</strong></th><th><strong>名称</strong></th><th><strong>值</strong></th></tr></thead><tbody><tr><td>CNAME</td><td>blog</td><td><a href="http://XXX.github.io">XXX.github.io</a></td></tr></tbody></table><blockquote><p>确保开启了 <strong>小云朵（代理）图标</strong>，启用 CDN 与 HTTPS；</p></blockquote><p>重新部署博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ol start="4"><li>设置 GitHub Pages 部署配置；</li></ol><p>在你的仓库中打开「Settings」→「Pages」，设置以下内容：</p><ul><li><strong>Source</strong> 设为：main 分支（或者 master，看你哪个在用）</li><li><strong>Branch folder</strong> 选的是 / (root)</li><li><strong>Custom domain</strong> 应该已填写为：<a href="http://yourdomain.com">yourdomain.com</a></li></ul><p>在重新部署一次，如果 DNS 已生效，那么就可以正常浏览你的博客了！</p><blockquote><p><strong>注</strong>：不定期随缘更新中…</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>开发心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：矩阵的LU分解</title>
    <link href="/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%9A%84LU%E5%88%86%E8%A7%A3/"/>
    <url>/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%9A%84LU%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1>矩阵的LU分解</h1><h2 id="Gauss消元法">Gauss消元法</h2><p>在介绍LU分解之前，我们先通过Gauss消元法引入。</p><p>对于求解以下线性方程组的问题：</p><p>$$<br>\left{\begin{matrix}<br>a_{11}x_{11} + a_{12}x_{12} + \cdots + a_{1n}x_{1n} = b_1\<br>\vdots \<br>a_{n1}x_{n1} + a_{n2}x_{n2} + \cdots + a_{nn}x_{nn} = b_n \<br>\end{matrix}\right.<br>$$</p><p>其矩阵形式为：</p><p>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} &amp; b_1\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} &amp; b_n<br>\end{bmatrix} \triangleq (A \vdots  b)<br>$$</p><p><strong>Guass消元法</strong>的基本思想是将矩阵$ \boldsymbol{A}$通过初等行变换转化为阶梯型矩阵，我们假定该过程中不涉及“对换变换”，变换过程如下：</p><p>记</p><p>$$<br>A^{(1)} = A = \begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)}\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>a_{n1}^{(1)} &amp; a_{n2}^{(1)} &amp; \cdots &amp; a_{nn}^{(1)}<br>\end{bmatrix}<br>$$</p><p>若$a_{11}^{(1)} \ne 0$，则：</p><p>$$<br>A^{(1)} \xrightarrow{r_i - \frac{a_{21}^{(1)}}{a_{11}^{(1)}}r_1,i = 2,3,\cdots,n}<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)}\<br>0 &amp; a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)}\<br>\vdots &amp; \vdots &amp; \vdots &amp; \vdots\<br>0 &amp; a_{n2}^{(2)} &amp; \cdots &amp; a_{nn}^{(2)}<br>\end{bmatrix} \triangleq A^{(2)}<br>$$</p><p>若$a_{22}^{(2)} \ne 0$，则：</p><p>$$<br>A^{(2)} \xrightarrow{r_i - \frac{a_{32}^{(2)}}{a_{22}^{(2)}}r_1,i = 3,4,\cdots,n}<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; a_{13}^{(1)}&amp; \cdots &amp; a_{1n}^{(1)}\<br>&amp; a_{22}^{(2)} &amp; a_{23}^{(2)}&amp; \cdots &amp; a_{2n}^{(2)}\<br>&amp; &amp; a_{33}^{(3)} &amp; \cdots &amp; a_{3n}^{(3)}\<br>&amp; &amp; \vdots &amp; &amp; \vdots\<br>&amp; &amp; a_{n3}^{(3)} &amp; \cdots &amp; a_{nn}^{(3)}<br>\end{bmatrix} \triangleq A^{(3)}<br>$$</p><p>如此继续，如果能进行$n-1$步，那么可以将矩阵$ \boldsymbol{A}$化为上三角矩阵：</p><p>$$<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)}\<br>&amp; a_{22}^{(2)} &amp; \cdots &amp; a_{2n}^{(2)}\<br>&amp; &amp;  \ddots &amp; \vdots\<br>&amp; &amp; &amp; a_{nn}^{(n)}<br>\end{bmatrix} \triangleq A^{(n)}<br>$$</p><p>上述过程就是Guass消元法的矩阵描述。</p><p>在上述过程进行的过程中，易得，如果Guass消元法能进行到底：</p><p>$$<br>\Leftrightarrow a_{11}^{(1)}a_{22}^{(2)}\cdots a_{n-1n-1}^{(n-1)} \ne 0<br>$$</p><p>那么问题是，如何判断$ \boldsymbol{A}$的前$n-1$个主元$\ne 0$？</p><p>回溯上述过程可知：</p><p>$$<br>\begin{aligned}<br>&amp; a_{11}^{(1)} = a_{11}\<br>&amp; a_{11}^{(1)}a_{22}^{(2)} =<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)}\<br>0 &amp; a_{22}^{(22)}<br>\end{bmatrix} =<br>\begin{bmatrix}<br>a_{11} &amp; a_{12}\<br>a_{21} &amp; a_{22}<br>\end{bmatrix}\<br>&amp; \cdots \<br>&amp; a_{11}^{(1)}a_{22}^{(2)}\cdots a_{kk}^{(k)} =<br>\begin{bmatrix}<br>a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1k}^{(1)}\<br>&amp; a_{22}^{(2)} &amp; \cdots &amp; a_{2k}^{(2)}\<br>&amp; &amp;  \ddots &amp; \vdots\<br>&amp; &amp; &amp; a_{kk}^{(k)}<br>\end{bmatrix} =<br>\begin{bmatrix}<br>a_{11} &amp; \cdots &amp; a_{1k}\<br>\vdots &amp; &amp; \vdots\<br>a_{k1} &amp; \cdots &amp; a_{kk}<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>记：</p><p>$$<br>\begin{aligned}<br>&amp; \Delta_1 = a_{11} \<br>&amp; \Delta_2 = \begin{bmatrix}<br>a_{11} &amp; a_{12}\<br>a_{21} &amp; a_{22}<br>\end{bmatrix} \<br>&amp; \cdots \<br>&amp; \Delta_{n-1} = \begin{bmatrix}<br>a_{11} &amp; \cdots &amp; a_{1n-1}\<br>\vdots &amp; &amp; \vdots\<br>a_{n-11} &amp; \cdots &amp; a_{n-1n-1}<br>\end{bmatrix}<br>\end{aligned}<br>$$</p><p>可以发现，$\Delta_k$即为$ \boldsymbol{A}$的$k$阶<strong>顺序主子式</strong>。</p><p>所以，得到如下命题：</p><p><strong>命题 1</strong><br>当$\Delta_k \ne 0,k = 1,2,\cdots,n-1\Leftrightarrow a_{kk}^{(k)} \ne 0$</p><p>于是，自然得到：</p><p><strong>定理 1</strong><br>Guass消元法能进行到底 $\Leftrightarrow$ $\boldsymbol{A}$的前$n-1$个顺序主子式$\ne 0$；</p><h2 id="矩阵LU分解的步骤推导">矩阵LU分解的步骤推导</h2><p>从高斯消元法的过程，每一步初等行变换的过程相当于一个<strong>高斯变换</strong>，即左乘一个矩阵：</p><p>$$<br>L_1 = \begin{bmatrix}<br>1 &amp; &amp; &amp; \<br>l_1 &amp; 1 &amp; &amp;\<br>l_2 &amp;  &amp; 1 &amp; &amp; \<br>\vdots &amp;  &amp;  &amp; \ddots &amp; \<br>l_n &amp; &amp; &amp; &amp; 1<br>\end{bmatrix}<br>$$</p><p>其中，$l_i = -\frac{a_{i1}^{(1)}}{a_{11}^{(1)}},i = 2,3,\cdots,n$。</p><p>易得，高斯消元法的过程可以表示为：</p><p>$$<br>L_{n-1}L_{n-2}\cdots L_{1}A = U<br>$$</p><p>其中，$\boldsymbol{L}_i$为下三角矩阵，$\boldsymbol{U}$为上三角矩阵。</p><p>令 $\boldsymbol{L} = L_1^{-1}\cdots L_{n-2}^{-1}L_{n-1}^{-1}$，则有：</p><p>$$<br>\boldsymbol{A} =  \boldsymbol{L} \boldsymbol{U}<br>$$</p><p>这就是矩阵的<strong>LU分解</strong>。</p><p>求得 $\boldsymbol{L}$ 和 $\boldsymbol{U}$ 后，如何计算 $x$？</p><p>$$<br>Ax = LUx = b<br>$$</p><p>取中间变量 $y = Ux$，则 $Ly = b$。</p><p>那么，为什么LU分解能加速线性方程组的求解呢？</p><p>实际上，虽然从矩阵形式上看，$\boldsymbol{L}$ 需要计算 $n-1$ 个 $L_i$ 的逆，但是实际算法求解过程中，三角型的矩阵的乘法和逆是容易计算的，并且甚至不需要额外的空间存储开销 \cite{Matrix_Computations}：算法会将 $\boldsymbol{L}$ 和 $\boldsymbol{U}$ 的元素直接存储到原矩阵 $\boldsymbol{A}$ 的相应位置上：</p><ul><li>$\boldsymbol{L}$ 的下三角部分（不包括对角线）会存储在 $\boldsymbol{A}$ 的下三角部分。</li><li>$\boldsymbol{U}$ 的上三角部分和对角线会存储在 $\boldsymbol{A}$ 的上三角部分和对角线上。</li></ul><p>例如，对于矩阵</p><p>$$<br>\boldsymbol{A} =\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; a_{13} \<br>a_{21} &amp; a_{22} &amp; a_{23} \<br>a_{31} &amp; a_{32} &amp; a_{33}<br>\end{bmatrix}<br>$$</p><p>经过 LU 分解后，它的存储会变为：</p><p>$$<br>\boldsymbol{A} =\begin{bmatrix}<br>u_{11} &amp; u_{12} &amp; u_{13} \<br>l_{21} &amp; u_{22} &amp; u_{23} \<br>l_{31} &amp; l_{32} &amp; u_{33}<br>\end{bmatrix}<br>$$</p><p>其中：</p><ul><li>$l_{ij}$ 为第 $i$ 行，第 $j$ 列的乘子；</li><li>$u_{ij}$ 为第 $i$ 行，第 $j$ 列的上三角元素；</li></ul><p>通过这种方式，所有分解信息都存储在原矩阵中，无需额外空间。LU分解既降低了时间复杂度又降低了空间复杂度。</p><p>不过，从我们进行高斯消元法的过程就可以发现，要保证高斯消元法能进行到底，需要避免乘子中的除数（$A_{kk}$）出现 0（实际应用中，很小的情况也应该避免），所以一般不直接应用LU分解，而是应用<strong>列主元PLU分解</strong>，它通过交换行来避免出现相对很小的主元，实现稳定的LU分解 \cite{数值分析5}，其伪代码如算法 \ref{列选主元PLU分解法} 所示。</p><h3 id="算法：列选主元PLU分解法">算法：列选主元PLU分解法</h3><p><strong>输入：</strong> 矩阵 $A \in \mathbb{R}^{n \times n}$<br><strong>输出：</strong> 矩阵 $P, L, U$，使得 $P A = L U$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs algorithm">初始化：<br>U = A, L = I, P = I<br><br>for k = 1 to n-1 do:<br>    1. 寻找主元：<br>       pivot = max_&#123;i=k, ..., n&#125; |U[i, k]|<br>       记录主元行号 row<br>       <br>    2. 若 row ≠ k:<br>       构造置换矩阵 P_k，交换 U 的第 k 行与第 row 行：<br>       P_k = 交换 k 行与 row 行的单位矩阵<br>       <br>       更新 U: U = P_k U<br>       更新 P: P = P_k P<br>       <br>       若 k &gt; 1，则更新 L: L = P_k L<br>    <br>    3. 对于 i = k+1 到 n:<br>       计算消元因子：<br>       L[i, k] = U[i, k] / U[k, k]<br>       <br>       更新 U：<br>       U[i, :] = U[i, :] - L[i, k] * U[k, :]<br>       <br>返回 P, L, U<br></code></pre></td></tr></table></figure><p>$$<br>\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}<br>$$</p><p>其中，若矩阵 $\boldsymbol{A}$ 满秩，即 $\operatorname{rank} A = r$，则可利用 LU 分解或 PLU 分解构造其满秩分解：</p><p>• <strong>LU 分解构造满秩分解</strong></p><p>若 $\boldsymbol{A}$ 可分解为 $\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}$，则从 $\boldsymbol{L}$ 提取前 $r$ 列，从 $\boldsymbol{U}$ 提取前 $r$ 行：<br>$$<br>\boldsymbol{F} = \boldsymbol{L}[:, 0:r],\quad \boldsymbol{G} = \boldsymbol{U}[0:r, :]<br>$$</p><p>其中，$\boldsymbol{F}$ 为列满秩矩阵（$m \times r$），$\boldsymbol{G}$ 为行满秩矩阵（$r \times n$），从而得到矩阵的满秩分解。</p><p>• <strong>PLU 分解构造满秩分解</strong></p><p>设 $\boldsymbol{A}$ 通过列主元 LU 分解得：</p><p>$$<br>\boldsymbol{A} = \boldsymbol{P} \boldsymbol{L} \boldsymbol{U}<br>$$</p><p>同样取：<br>$$<br>\boldsymbol{B} = \boldsymbol{L}[:, 0:r],\quad \boldsymbol{C} = \boldsymbol{U}[0:r, :]<br>$$</p><p>代入分解式可得：<br>$$<br>\boldsymbol{A} = \boldsymbol{P} \boldsymbol{B} \boldsymbol{C}<br>$$</p><p>其中，$\boldsymbol{P}$ 为置换矩阵，显然满秩。</p><p>进一步推广，若方阵 $\boldsymbol{A}$ 可分解为：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \boldsymbol{D} \boldsymbol{U}<br>$$</p><p>其中，$\boldsymbol{D}$ 为对角矩阵，则称其为 <strong>LDU 分解</strong>。</p><p>由高斯消元法的推导，可得如下定理及推论：</p><p><strong>定理</strong>：矩阵 $\boldsymbol{A} = (a_{i j})_{n \times n}$ 存在唯一分解：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \boldsymbol{D} \boldsymbol{U}<br>$$</p><p>其中：</p><p>• $\boldsymbol{L}$ 为单位下三角矩阵，</p><p>• $\boldsymbol{U}$ 为单位上三角矩阵，</p><p>• $\boldsymbol{D}$ 为对角矩阵，其对角元：$d_{k} = \frac{\Delta_{k}}{\Delta_{k-1}}, \quad k=1,2,\dots,n \quad (\Delta_0 = 1)$</p><p>其中 $\Delta_k$ 为 $\boldsymbol{A}$ 的顺序主子式。</p><p><strong>推论</strong>：若 $\boldsymbol{A}$ 为非奇异矩阵，则其可进行三角分解：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}<br>$$</p><p>当且仅当 $\boldsymbol{A}$ 的顺序主子式：$\Delta_k \neq 0, \quad k=1,2,\dots,n$</p><p><strong>进一步推广</strong>：对 <strong>Doolittle、Crout、Cholesky 分解</strong>，定义如下：</p><p>• <strong>Doolittle 分解</strong>：设 $\boldsymbol{A}$ 具有唯一 LDU 分解，令：<br>$$<br>\hat{\boldsymbol{U}} = \boldsymbol{D} \boldsymbol{U}<br>$$</p><p>则有：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \hat{\boldsymbol{U}}<br>$$</p><p>• <strong>Crout 分解</strong>：令：<br>$$<br>\hat{\boldsymbol{L}} = \boldsymbol{L} \boldsymbol{D}<br>$$</p><p>则有：<br>$$<br>\boldsymbol{A} = \hat{\boldsymbol{L}} \boldsymbol{U}<br>$$</p><p>• <strong>Cholesky 分解</strong>（平方根分解）：设 $\boldsymbol{A}$ 为实对称正定矩阵，则其可分解为：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \widetilde{\boldsymbol{D}}^2 \boldsymbol{U}<br>$$</p><p>其中：<br>$$<br>\widetilde{\boldsymbol{D}} = \operatorname{diag}(\sqrt{d_1},\sqrt{d_2},\dots,\sqrt{d_n})<br>$$</p><p>进一步，可得：<br>$$<br>\boldsymbol{A} = \boldsymbol{L} \widetilde{\boldsymbol{D}}^2 \boldsymbol{L}^\top<br>$$</p><p>令：<br>$$<br>\boldsymbol{G} = \boldsymbol{L} \widetilde{\boldsymbol{D}}<br>$$</p><p>则有：<br>$$<br>\boldsymbol{A} = \boldsymbol{G} \boldsymbol{G}^\top<br>$$</p><p>这被称为 <strong>Cholesky 分解</strong>（对称三角分解）。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：矩阵函数和矩阵求导</title>
    <link href="/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0%E5%92%8C%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"/>
    <url>/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0%E5%92%8C%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵函数介绍">矩阵函数介绍</h2><p>矩阵函数与通常的函数类似，但是因变量和自变量都为 $n$ 阶矩阵。定义如下：</p><h3 id="定义">定义</h3><p>设一元函数 $f(z)$ 能展开为 $z$ 的幂级数：<br>$$<br>f(z) = \sum_{k = 0}^{\infty} c_k z^k, \quad (|z| &lt; r)<br>$$<br>其中 $r &gt; 0$ 表示该幂级数的收敛半径。当 $n$ 阶矩阵 $A$ 的谱半径 $\rho (A) &lt; r$ 时，把收敛矩阵幂级数 $\sum_{k = 0}^{\infty} c_k A^k$ 的和称为 <strong>矩阵函数</strong>，记为 $f(A)$，即：<br>$$<br>f(A) = \sum_{k = 0}^{\infty} c_k A^k<br>$$</p><p>通过以上定义和一些基本函数，可以导出 <strong>矩阵指数函数</strong> 和 <strong>矩阵三角函数</strong>，并推得一系列等式。</p><hr><h2 id="函数矩阵对矩阵的导数">函数矩阵对矩阵的导数</h2><p>我们已经在上一节中引入了矩阵函数的概念，类似地，也有微分和导数的定义。相较于标量导数，对矩阵函数的求导和微分较为复杂。在具体应用中，如梯度下降等算法，这部分内容具有重要意义，因此需要深入理解。</p><p>首先，我们将标量求导拓展到向量，对于 $\frac{\partial y}{\partial x}$，存在以下几种情况：</p><ol><li>$y$ 是标量：<ul><li>$x$ 是标量</li><li>$\boldsymbol{x}$ 是向量（默认为列向量，即 $\boldsymbol{x} = (x_1, x_2, x_3)^\top$）</li><li>$\boldsymbol{X}$ 是矩阵</li></ul></li><li>$\boldsymbol{y}$ 是向量，例如 $f_{3\times 1}(x) = (f_1, f_2, f_3)^\top$：<ul><li>标量变元</li><li>向量变元</li><li>矩阵变元</li></ul></li><li>$\boldsymbol{Y}$ 是矩阵，同样有三种变元。</li></ol><p>简单理解：</p><ul><li><strong>分子布局</strong>：分子是列向量形式，分母是行向量形式</li><li><strong>分母布局</strong>：分子是行向量形式，分母是列向量形式</li></ul><h3 id="向量化操作">向量化操作</h3><p>在具体分析之前，先介绍矩阵的 <strong>向量化操作</strong>。例如，对矩阵 $\boldsymbol{X} \in \mathbb{R}^{m \times n}$ 进行列优先展开：<br>$$<br>\text{vec}(\boldsymbol{X}) =<br>\begin{bmatrix}<br>x_{11} &amp; x_{21} &amp; \dots &amp; x_{m1} &amp; \dots &amp; x_{1n} &amp; x_{2n} &amp; \dots &amp; x_{mn}<br>\end{bmatrix}^\top<br>$$</p><h3 id="向量变元的实值标量函数">向量变元的实值标量函数</h3><ol><li><strong>行向量偏导（分子布局）</strong><br>$$<br>\boldsymbol{D}_{\boldsymbol{x}} f = \frac{\partial f}{\partial \boldsymbol{x}^\top} =<br>\begin{bmatrix}<br>\frac{\partial f}{\partial x_1} &amp; \frac{\partial f}{\partial x_2} &amp; \dots &amp; \frac{\partial f}{\partial x_n}<br>\end{bmatrix}<br>$$</li><li><strong>梯度向量偏导（分母布局）</strong><br>$$<br>\nabla_{\boldsymbol{x}} f = \frac{\partial f}{\partial \boldsymbol{x}} =<br>\begin{bmatrix}<br>\frac{\partial f}{\partial x_1} \<br>\frac{\partial f}{\partial x_2} \<br>\vdots \<br>\frac{\partial f}{\partial x_n}<br>\end{bmatrix}<br>$$</li></ol><h3 id="矩阵变元的实值标量函数">矩阵变元的实值标量函数</h3><p>从标量求导到矩阵求导，就是分子的 <strong>转置、向量化</strong> 和分母的 <strong>转置、向量化</strong> 的各种组合。</p><p>对于 <strong>分子布局</strong>：</p><ul><li>分子：标量、列向量、矩阵向量化后的列向量</li><li>分母：标量、列向量转置后的行向量、矩阵的转置矩阵、矩阵向量化后的列向量转置后的行向量</li></ul><p>对于 <strong>分母布局</strong>：</p><ul><li>分子：标量、列向量转置后的行向量、矩阵向量化后的列向量转置后的行向量</li><li>分母：标量、列向量、矩阵自身、矩阵向量化后的列向量</li></ul><p>在机器学习领域，常见的主要有以下三种形式：</p><ol><li><strong>梯度</strong>：<br>$$<br>\nabla_{\boldsymbol{x}} \overset{\mathrm{def}}{=} \left[\frac{\partial}{\partial x_{1}},\frac{\partial}{\partial x_{2}},\cdots,\frac{\partial}{\partial x_{n}}\right]^{T}=\frac{\partial}{\partial\boldsymbol{x}}<br>$$</li><li><strong>Hesse矩阵</strong>：<br>$$<br>H(f) =<br>\begin{bmatrix}<br>\frac{\partial^2f}{\partial x_1^2} &amp; \frac{\partial^2f}{\partial x_1\partial x_2} &amp; \cdots &amp; \frac{\partial^2f}{\partial x_1\partial x_n} \<br>\frac{\partial^2f}{\partial x_2\partial x_1} &amp; \frac{\partial^2f}{\partial x_2^2} &amp; \cdots &amp; \frac{\partial^2f}{\partial x_2\partial x_n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>\frac{\partial^2f}{\partial x_n\partial x_1} &amp; \frac{\partial^2f}{\partial x_n\partial x_2} &amp; \cdots &amp; \frac{\partial^2f}{\partial x_n^2}<br>\end{bmatrix}<br>$$</li><li><strong>Jacobi矩阵</strong>：<br>$$<br>\begin{bmatrix}<br>\frac{\partial y_1}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_1}{\partial x_n} \<br>\vdots &amp; \ddots &amp; \vdots \<br>\frac{\partial y_m}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_m}{\partial x_n}<br>\end{bmatrix}<br>$$</li></ol><p>不难发现：</p><ul><li>若 $f(x)$ 是一个标量函数，则 <strong>Jacobi矩阵是一个向量</strong>，等于 $f(x)$ 的梯度，Hesse矩阵是一个二维矩阵</li><li>若 $f(x)$ 是一个向量值函数，则 <strong>Jacobi矩阵是一个二维矩阵</strong>，Hesse矩阵是一个三维矩阵</li><li><strong>梯度是 Jacobi 矩阵的特例</strong>，梯度的 Jacobi 矩阵就是 Hesse 矩阵，这其实就是 <strong>一阶偏导与二阶偏导的关系</strong></li></ul><hr><h2 id="自动求导与链式法则">自动求导与链式法则</h2><p>在实际应用问题中，标量求导中的 <strong>链式法则</strong> 也可以拓展到向量乃至矩阵。在使用程序计算时，库函数一般采用 <strong>自动求导</strong> 方式，而不是一般的符号求导或数值求导。自动求导应用了链式法则，并将整个计算过程表示成一个 <strong>无环图</strong>，其中包括两种模式：</p><ol><li><strong>正向积累</strong>：<br>$$<br>\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{x}} =<br>\frac{\partial \boldsymbol{z}^{(i-1)}}{\partial \boldsymbol{x}} \cdot<br>\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{z}^{(i-1)}}<br>$$</li><li><strong>反向传递</strong>：<br>$$<br>\frac{\partial f}{\partial \boldsymbol{z}^{(i-1)}} =<br>\frac{\partial f}{\partial \boldsymbol{z}^{(i)}} \cdot<br>\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{z}^{(i-1)}}<br>$$</li></ol><p>反向传递过程需要存储中间变量，导致内存复杂度比正向积累高。</p><p>其在实际场景中的主要应用就是神经网络，在神经网络的正向传播中，我们将输入数据通过网络层逐层传递，计算出最终的输出值。我们的目标是计算神经网络的输出$\hat{y}$和损失函数$\mathcal{L}$的值。而反向传播用于计算损失函数对所有网络参数的梯度。</p><p>在实际应用问题中，由于反向传播的链路过长，涉及到多次激活函数关于净输入的偏导数矩阵、当前层输入关于净输入的偏导数矩阵的连乘，如果这个矩阵的谱半径小于一，那么随着反向传播的进行，回传的梯度信号衰减地越厉害，这使得越是网络浅层的参数地梯度越微弱，那么其越难得到很好地更新。这就是<strong>梯度消失</strong>问题。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：矩阵级数</title>
    <link href="/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%A7%E6%95%B0/"/>
    <url>/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="矩阵级数介绍">矩阵级数介绍</h3><p>在数学分析中，级数（特别是幂级数）的理论占有重要地位。在建立矩阵分析的理论时，矩阵级数，特别是幂级数，是建立矩阵函数的理论基础。</p><p>类似数列级数，我们给出其收敛、发散以及和的定义。</p><h4 id="定义-1">定义 1</h4><p>把矩阵序列所形成的无穷和 $A^{(0)} + A^{(1)} + A^{(2)} + \cdots + A^{(k)} + \cdots$ 称为 <strong>矩阵级数</strong>，记为 $\sum_{k = 0}^{\infty} A^{(k)}$。则有：<br>$$<br>\sum_{k=0}^\infty A^{(k)} = A^{(0)} + A^{(1)} + A^{(2)} + \cdots + A^{(k)} + \cdots<br>$$</p><h4 id="定义-2">定义 2</h4><p>记 $S^{(N)} = \sum_{k=0}^N A^{(k)}$，称其为矩阵级数的部分和。如果矩阵序列 ${S^{(N)}}$ <strong>收敛</strong>，且有极限 $S$，则有：<br>$$<br>\lim_{N \to \infty} S^{(N)} = S<br>$$<br>那么就称矩阵级数收敛，并且有 $S$，记为：<br>$$<br>S = \sum_{k=0}^\infty A^{(k)}<br>$$<br>不收敛的矩阵称为 <strong>发散</strong> 的。</p><p>若用 $s_{ij}$ 表示 $S$ 的第 $i$ 行第 $j$ 列元素，那么，和 $\sum_{k=0}^N A^{(k)} = S^{(N)}$ 的意义是：<br>$$<br>\sum_{k = 0}^{\infty}a_{ij}^{(k)} = s_{ij}, \quad (i=1,2,\dots,m; \quad j=1,2,\dots,n)<br>$$</p><h4 id="定义-3">定义 3</h4><p>如果上述级数中 $mn$ 个数项级数都是绝对收敛的，则称矩阵级数是 <strong>绝对收敛</strong> 的。</p><p>我们不再赘述有关矩阵级数绝对收敛的一些判别和性质，而是将重点放在矩阵的幂级数上。</p><p>首先，我们看一个比较简单的方阵幂级数。</p><h4 id="定理-1">定理 1</h4><p>方阵 $A$ 的 <strong>幂级数（Neumann 级数）</strong><br>$$<br>\sum_{k = 0}^{\infty} A^k = I + A + A^2 + \dots + A^k + \dots<br>$$<br>收敛的充要条件是 $A$ 为收敛矩阵，并且在其收敛时，其和为 $(I - A)^{-1}$。</p><p>如果用级数和来估算部分和矩阵，会存在一定误差：</p><h4 id="定理-2">定理 2</h4><p>设方阵 $A$ 对某一矩阵范数 $\Vert \cdot \Vert$ 有 $\Vert A\Vert &lt; 1$，则对任何非负整数 $N$，以 $(I-A)^{-1}$ 为部分和 $I + A + A^2 + \dots + A^N$ 的近似矩阵时，其误差为：<br>$$<br>\Vert (I-A)^{-1} - (I + A + A^2 + \dots + A^N)\Vert \le \frac{\Vert A\Vert ^{N+1}}{1 - \Vert A\Vert}<br>$$</p><p>现在，我们继续将矩阵幂级数 $\sum_{k = 0}^{\infty} c_kA^k$ 与对应的纯量幂级数 $\sum_{k = 0}^{\infty} c_kz^k$ 建立联系。</p><h4 id="定理-3">定理 3</h4><p>设幂级数<br>$$<br>f(z) = \sum_{k = 0}^{\infty}c_kz^k<br>$$<br>的收敛半径为 $r$，如果方阵 $A$ 满足 $\rho (A) &lt; r$，则矩阵幂级数<br>$$<br>\sum_{k = 0}^{\infty}c_kA^k<br>$$<br>是绝对收敛的；如果 $\rho (A) &gt; r$，则矩阵幂级数是发散的。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：矩阵序列</title>
    <link href="/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BA%8F%E5%88%97/"/>
    <url>/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵序列介绍">矩阵序列介绍</h2><p>在《线性代数》课程中主要学习了矩阵的代数运算，我们继续将《数学分析》中的理论推广至矩阵空间，对于矩阵的分析，类似数列，我们同样从极限理论开始，介绍矩阵序列的极限运算。</p><h3 id="定义">定义</h3><p>设 ${A^{(k)}}<em>{k=1}^\infty$ 是一个矩阵序列，其中 $A^{(k)} \in \mathbb{C}^{m \times n}$。当 $a</em>{ij}^{(k)} \to a_{ij}(k \to \infty)$ 时，称 ${A^{(k)}}$ 收敛，或成矩阵 $A = (a_{ij})<em>{m \times n}$ 为 ${A^{(k)}}$ 的极限，或称 ${A^{(k)}}$ 收敛于 $A$，记为<br>$$<br>\lim</em>{k \to \infty} A^{(k)} = A, A^{(k)} \to A<br>$$<br>不收敛的矩阵序列称为 <strong>发散</strong>。</p><p>同样，矩阵序列收敛有很多与数列收敛类似的性质，此处不再赘述，继续往下研究其收敛的等价条件。</p><h3 id="定理">定理</h3><p><strong>定理 1</strong> 设 $A^{(k)} \in \mathbb{C}^{m \times n}$，则</p><ol><li>$A^{(k)} \to O$ 的充要条件是 $\Vert A^{(k)}\Vert \to 0$；</li><li>$A^{(k)} \to A$ 的充要条件是 $\Vert A^{(k)} - A \Vert \to 0$；</li></ol><p>这里，$\Vert \cdot \Vert$ 是 $\mathbb{C}^{m \times n}$ 上任何一种矩阵范数。</p><p>至此，我们将矩阵收敛的判断与范数建立了联系。</p><h3 id="定义-2">定义</h3><p><strong>定义 1</strong> 矩阵序列 ${A^{(k)}}$ 称为 <strong>有界</strong> 的，如果存在常数 $M &gt; 0$，使得对于一切 $k$ 都有<br>$$<br>\left | a_{ij}^{(k)}\right | &lt; M(i = 1,2,\dots,m;j = 1,2,\dots,n)<br>$$</p><p><strong>定义 2</strong> 设 $A$ 为方阵，且 $A^k \to O(k \to \infty)$，则称 $A$ 为 <strong>收敛矩阵</strong>。</p><h3 id="定理-2">定理</h3><p><strong>定理 2</strong> $A$ 为收敛矩阵的充要条件是 $\rho(A) &lt; 1$。</p><p><strong>定理 3</strong> $A$ 为收敛矩阵的充分条件是只要有一种矩阵范数 $\left|\cdot\right|$，使得 $\Vert A \Vert &lt; 1$。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：矩阵可逆性条件、条件数和谱半径介绍</title>
    <link href="/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%8F%AF%E9%80%86%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%80%81%E6%9D%A1%E4%BB%B6%E6%95%B0%E5%92%8C%E8%B0%B1%E5%8D%8A%E5%BE%84%E4%BB%8B%E7%BB%8D/"/>
    <url>/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%8F%AF%E9%80%86%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%80%81%E6%9D%A1%E4%BB%B6%E6%95%B0%E5%92%8C%E8%B0%B1%E5%8D%8A%E5%BE%84%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵可逆性条件、条件数和谱半径介绍">矩阵可逆性条件、条件数和谱半径介绍</h2><p>在明确了范数的定义后，我们对它的几点应用进行列举。</p><h3 id="定理-2-6">定理 2.6</h3><p>设 $A\in \mathbb{C}^{n \times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A \Vert  &lt; 1$，则矩阵 $I-A$ 可逆（非奇异），且有：</p><p>$$<br>\Vert (I - A)^{-1} \Vert  \leq \frac{\Vert  I \Vert }{1 - \Vert  A \Vert }<br>$$</p><h3 id="定理-2-7">定理 2.7</h3><p>设 $A\in \mathbb{C}^{n \times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A \Vert  &lt; 1$，则有：</p><p>$$<br>\Vert I - (I - A)^{-1} \Vert  \leq \frac{\Vert  A \Vert }{1 - \Vert  A \Vert }<br>$$</p><h3 id="逆矩阵的摄动">逆矩阵的摄动</h3><p>在实际应用问题中，矩阵参数往往为非准确值，即带有误差 $\delta$，我们希望其构成的近似矩阵 $A$ 的逆矩阵 $A^{-1}$ 与准确矩阵 $A + \delta a_{ij}(i,j = 1,2,\dots,n)$ 的逆矩阵 $(A + \delta a_{ij})^{-1}$ 尽量接近。</p><p>一般称 $\delta a_{ij}$ 为 <strong>扰动</strong>，$\delta A$ 为 $A$ 的 <strong>摄动矩阵</strong>。</p><h3 id="摄动定理">摄动定理</h3><p><strong>定理 2.8</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$ 且 $A$ 可逆，$B\in \mathbb{C}^{n\times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A^{-1}B \Vert  &lt; 1$，则有：</p><ul><li>$A + B$ 可逆；</li><li>记 $F = I - (I + A^{-1}B)^{-1}$，则 $\Vert F \Vert \leq \frac{\Vert A^{-1}B \Vert }{1 - \Vert A^{-1}B \Vert }$；</li><li>$\frac{\Vert A^{-1} - (A + B)^{-1} \Vert }{A^{-1}} \leq \frac{\Vert  A^{-1}B \Vert }{1 - \Vert  A^{-1}B \Vert }$。</li></ul><p>若令 $\delta$ 是个小量，并且令</p><p>$$<br>cond(A) = \Vert A \Vert \Vert A^{-1}\Vert<br>$$</p><p>则当 $\Vert A^{-1}\Vert \Vert \delta A \Vert &lt; 1$ 时，</p><p>$$<br>\frac{\Vert A^{-1} - (A + \delta A)^{-1}\Vert}{\Vert A^{-1}\Vert}\leq \frac{cond(A)\frac{\Vert \delta A\Vert}{\Vert A\Vert}}{1 - cond(A)\frac{\Vert\delta A\Vert}{\Vert A\Vert}}<br>$$</p><p>称 $cond(A)$ 为矩阵 $A$ 的 <strong>条件数</strong>，一般情况下，条件数越大，$(A + \delta A)^{-1}$ 和 $A^{-1}$ 的相对误差就越大。往往在用算法进行矩阵求逆时，先计算条件数，判断矩阵的逆是否“好求”。</p><h3 id="矩阵谱半径">矩阵谱半径</h3><p><strong>定义</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$ 的 $n$ 个特征值为 $\lambda_1,\lambda_2,\dots,\lambda_n$，称</p><p>$$<br>\rho (A) = \max\limits_{i}\left|\lambda_i\right|<br>$$</p><p>为 $A$ 的 <strong>谱半径</strong>。</p><p><strong>定理 2.9</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$，则对 $\mathbb{C}^{n\times n}$ 上任何一种矩阵范数 $\Vert  \cdot  \Vert $，都有</p><p>$$<br>\rho (A) \leq \Vert  A \Vert<br>$$</p><p><strong>定理 2.10</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$，对 $\forall \epsilon &gt; 0,\exists \Vert  \cdot  \Vert ,s.t.$</p><p>$$<br>\Vert  A  \Vert _M \leq \rho (A) + \epsilon<br>$$</p><p>由上述定理可见，谱半径小于等于任意矩阵范数，同时也必存在一个算子范数，小于等于谱半径加上一个很小的正数。</p><h3 id="谱半径在迭代法中的应用">谱半径在迭代法中的应用</h3><p>谱半径在数值分析和迭代法中起到了关键作用，尤其是在矩阵幂法、迭代求解线性方程组的收敛性分析等领域。例如，当利用迭代法解线性方程组时，谱半径决定了迭代矩阵是否收敛。</p><p><strong>定理 2.11</strong></p><p>在数值线性代数中，迭代法通常用于求解线性方程组 $Ax = b$。设迭代法的一般形式为：</p><p>$$<br>x^{(k+1)} = B x^{(k)} + c,<br>$$</p><p>其中，$B$ 为迭代矩阵，$c$ 为常向量，$k$ 为迭代次数。</p><p>迭代法的收敛性由迭代矩阵 $B$ 的谱半径决定：</p><ol><li><strong>必要条件</strong>：如果迭代法收敛，即 $x^{(k)} \to x^<em>$ ($x^</em>$ 为精确解)，则迭代矩阵 $B$ 的谱半径必须满足：$\rho(B) &lt; 1$；</li><li><strong>充分条件</strong>：如果 $\rho(B) &lt; 1$，则对于任意初始值 $x^{(0)}$，迭代法都会收敛到线性方程组的唯一解 $x^*$。</li></ol>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：向量范数与矩阵范数</title>
    <link href="/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/"/>
    <url>/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="向量范数与矩阵范数">向量范数与矩阵范数</h2><h3 id="向量范数介绍">向量范数介绍</h3><p>我们知道，对于数列极限，我们有</p><p>$$<br>\lim_{n \to \infty} a_n = M \iff \forall \epsilon &gt; 0,\exists N &gt; 0,s.t. \forall n&gt;N,\left |  {a_n - M}  \right | &lt; \epsilon.<br>$$</p><p>在 $n$ 维向量空间 $R^n$ 内，我们希望对于一个向量序列 ${x^{(k)}}$，其中 $x^{(k)}= (\xi_1^{(k)},\xi_2^{(k)},\dots, \xi_n^{(k)})(k = 1,2,3,\dots)$。如果对于每一个分量 $\xi_i^{(k)}$，都有 $\lim_{k \to \infty} \xi_i^{(k)} = \xi_i$，即</p><p>$$<br>\lim_{k \to \infty} x^{(k)} = (\xi_1, \xi_2, \dots, \xi_n) = x<br>$$</p><p>则称向量序列 ${x^{(k)}}$ 收敛于 $x$。</p><p>但是，我们还是无法解决 $\left| x^{(k)} - x\right|$ 该如何定义和计算，显然它不能用向量 $x^{(k)} - x$ 的长度来刻画。为此，我们定义向量范数如下。</p><h4 id="定义-2-1">定义 2.1</h4><p>如果 $V$ 是数域 $K$ 上的线性空间，且对于 $\forall x \in V$，定义一个实值函数 $\Vert  x \Vert $，它满足以下三个条件:</p><ol><li><strong>非负性</strong>: 当 $x \ne 0$ 时，$\Vert  x \Vert  &gt; 0$，当且仅当 $x = 0$ 时为 $0$;</li><li><strong>齐次性</strong>: $\forall a \in K, \forall x \in V, \Vert  ax \Vert  = \left| a \right| \Vert  x \Vert$;</li><li><strong>三角不等式</strong>: $\forall x, y \in V, \Vert  x + y \Vert  \leq \Vert  x \Vert  + \Vert  y \Vert$;</li></ol><p>则称 $\Vert  x \Vert$ 为向量 $x$ 的范数。</p><p>我们要判断某个实值函数 $\Vert  x \Vert$ 是否是范数，即验证其是否满足上述三条性质即可。以下列举几种常见的范数(在线性空间 $\mathbb{C}^n$，即酉空间中)：</p><ul><li><strong>1-范数</strong>: $\Vert  x \Vert  = \sum \left| \xi_i \right|$</li><li><strong>2-范数</strong>: $\Vert  x \Vert  = \sqrt{(x,x)}$</li><li><strong>$\infty$-范数</strong>: $\Vert  x \Vert  = \max \left| x_i\right|$</li><li><strong>p-范数</strong>: $\Vert  x \Vert <em>p = (\sum</em>{i = 1}^{n} {\left|x_i\right|}^p)^{\frac{1}{p}}, (1 \leq p &lt; \infty)$</li></ul><h4 id="定理-2-1">定理 2.1</h4><p>设有限维线性空间 $V^n$ 中任意两个向量范数 $\Vert  x_\alpha \Vert ,\Vert  x_\beta \Vert$，如果 $\exists c_1, c_2,s.t.$</p><p>$$<br>{c_1\Vert  x_\beta \Vert  \leq \Vert  x_\alpha \Vert  &lt; c_2\Vert  x_\beta \Vert }<br>$$</p><p>则称向量范数 $\Vert  x_\alpha \Vert ,\Vert  x_\beta \Vert$ 等价。</p><h3 id="矩阵范数介绍">矩阵范数介绍</h3><p>对于矩阵空间 $\mathbb{C}^{m\times n}$，如果类似地将矩阵 $A_{m\times n}$ 看作“向量”，可以类似向量范数定义矩阵范数。但矩阵之间还有乘法运算，需要补充定义如下：</p><h4 id="定义-2-3">定义 2.3</h4><p>设 $A \in \mathbb{C}^{m\times n}$，定义一个实值函数 $\Vert  A \Vert$，它满足以下四个条件:</p><ol><li><strong>非负性</strong>: 当 $A \ne 0$ 时，$\Vert  A \Vert  &gt; 0$，当且仅当 $A = 0$ 时为 $0$;</li><li><strong>齐次性</strong>: $\forall \alpha \in C, \Vert  {\alpha A} \Vert  = \left| {\alpha} \right| \Vert  A \Vert$;</li><li><strong>三角不等式</strong>: $\Vert  A + B \Vert  \leq \Vert  A \Vert  + \Vert  B \Vert$;</li><li><strong>相容性</strong>: $\Vert  AB \Vert  \leq \Vert  A \Vert  \Vert  B \Vert$ (对于 $B \in \mathbb{C}^{n\times l}$)。</li></ol><p>则称 $\Vert  A \Vert$ 为矩阵 $A$ 的范数。</p><p>在数值方法中进行某种估计时，多数情况下，矩阵范数与向量范数常混合使用，而矩阵经常是作为两个线性空间上的线性变换出现的，为此引入矩阵范数和向量范数相容的概念如下：</p><h4 id="定理2-2">定理2.2</h4><p>对于$\mathbb{C}^{m \times n}$的矩阵范数$\Vert {\cdot} \Vert _M$和$\mathbb{C}^m,\mathbb{C}^n$上的同类向量范数$\Vert {\cdot} \Vert _V$，如果有</p><p>$$</p><p>\Vert Ax \Vert _V \leq \Vert A \Vert _M \Vert x \Vert _V(\forall A \in \mathbb{C}^{m \times n}, \forall x \in \mathbb{C}^n)</p><p>$$</p><p>则称矩阵范数$\Vert {\cdot} \Vert _M$与向量范数$\Vert {\cdot} \Vert _V$是相容的。</p><p>以下列举几种常用的矩阵范数：</p><ul><li><strong>F-范数</strong>: $\Vert  A \Vert <em>F = (\sum</em>{i = 1}^{m}\sum_{j = 1}^{n}\left|a_{ij}\right|^2)^{\frac{1}{2}} = (tr(A^H A))^{\frac{1}{2}}$</li></ul><p>其中，F-范数有一定理如下：</p><h4 id="定理-2-3">定理 2.3</h4><p>设 $A \in \mathbb{C}^{m \times n}$，且 $P \in \mathbb{C}^{m\times m}, Q\in \mathbb{C}^{n \times n}$ 都是酉矩阵，则有</p><p>$$<br>\Vert PA \Vert _F = \Vert A \Vert _F = \Vert AQ \Vert _F<br>$$</p><p>即 $A$ 左乘或右乘酉矩阵后，其 $\Vert {\cdot} \Vert$ 不变。</p><p>矩阵函数可以通过如下方法进行定义，并且定义的矩阵函数与已知的向量范数相容。</p><h4 id="定理2-4">定理2.4</h4><p>已知$\mathbb{C}^{m},\mathbb{C}^{n}$上的同类向量范数$\Vert {\cdot} \Vert$。设$A\in \mathbb{C}^{m\times n}$，则函数<br>$$<br>\Vert {A} \Vert = \max\limits_{\Vert x \Vert = 1}{\Vert {Ax} \Vert }<br>$$</p><p>是$\mathbb{C}^{m\times n}$上的矩阵范数，且与已知的向量范数相容。</p><p>分别取向量$x$的范数为$\Vert x \Vert _1,\Vert x \Vert _2,\Vert x \Vert _{\infty}$时，就可以得到以下三种矩阵范数：</p><h4 id="定理-2-5">定理 2.5</h4><p>设 $A = (a_{ij})_{m\times n} \in \mathbb{C}^{m\times n}$，可以得到以下三种矩阵范数的计算公式分别为:</p><ol><li><strong>列和范数</strong>: $\Vert A \Vert <em>1 = \max\limits</em>{j} \sum_{i = 1}^{m}\left|a_{ij}\right|$;</li><li><strong>谱范数</strong>: $\Vert A \Vert _2 = \sqrt{\max{\lambda(A^HA)}}$;</li><li><strong>行和范数</strong>: $\Vert A \Vert <em>{\infty} = \max\limits</em>{i} \sum_{j=1}^{n}\left|a_{ij}\right|$;</li></ol><p>在机器学习中，范数作为数学优化的重要工具，广泛应用于高维优化问题中，其具体表现和影响在模型的性能、计算复杂度、正则化等方面有重要体现。</p><p>在高维优化中，目标函数往往包含范数，用于度量模型参数或残差的大小；在机器学习模型训练中，损失函数通常衡量预测值与真实值之间的差距，而范数决定了误差的度量方式，例如L-1损失、L-2损失；正则化通过添加范数约束减少模型复杂度，缓解高维数据中的过拟合问题，例如L-1正则化，L-2正则化。</p><p>以上应用场景中，范数的引入通过度量大小、限制复杂性和提升泛化能力，影响了模型的性能和稳定性。选择合适的范数类型能有效在稀疏性、平滑性和数值稳定性之间实现权衡。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：欧式空间中线性变换的求法</title>
    <link href="/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E6%B1%82%E6%B3%95/"/>
    <url>/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E6%B1%82%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="欧式空间中线性变换的求法">欧式空间中线性变换的求法</h2><p>有了前两节的铺垫，下面，我们正式介绍欧式空间中线性变换的求法。</p><p>我们将问题描述如下：</p><p><strong>问题描述：</strong></p><ul><li>在欧式空间中给定线性变换 $T: \mathbb{V}^n \to \mathbb{V}^n$，比如：$T( \boldsymbol{X}) =  \boldsymbol{X} \boldsymbol{B}(\forall  \boldsymbol{X} \in \mathbb{V})$，其中 $\boldsymbol{B}$ 给定。</li><li><strong>目标：</strong> 寻找一组新基，使得 $T$ 在这组基下的矩阵表示为对角矩阵 $\boldsymbol{\Lambda}$ 或 Jordan 标准型 $\boldsymbol{J}$。</li></ul><p>首先，我们以课本 [矩阵论] 中的例题 1.36 为例，说明对称变换的求法：</p><h3 id="例-1-36">例 1.36</h3><p>在欧氏空间 $\mathbb{R}^{2 \times 2}$ 中，矩阵 $\boldsymbol{A}$ 与 $\boldsymbol{B}$ 的内积定义为 $$( \boldsymbol{A},  \boldsymbol{B})=tr ( \boldsymbol{A}^\top  \boldsymbol{B})$$，子空间</p><p>$$<br>V=\left{ \boldsymbol{X} =\begin{bmatrix} x_{1} &amp; x_{2}\ x_{3} &amp; x_{4} \end{bmatrix} \mid x_{3}-x_{4}=0\right}<br>$$</p><p>$V$ 中的线性变换为</p><p>$$<br>T( \boldsymbol{X})= \boldsymbol{X}  \boldsymbol{B}<em>{0}\quad (\forall  \boldsymbol{X} \in V), \boldsymbol{B}</em>{0}=\begin{bmatrix} 1 &amp; 2 \ 2 &amp; 1 \end{bmatrix}<br>$$</p><ol><li>求 $V$ 的一个标准正交基；</li><li>验证 $T$ 是 $V$ 中的对称变换；</li><li>求 $V$ 的一个标准正交基，使 $T$ 在该基下的矩阵为对角矩阵。</li></ol><h3 id="解：">解：</h3><h4 id="1-先找到一组普通的基，再进行-Schmidt-正交化">(1) 先找到一组普通的基，再进行 Schmidt 正交化</h4><p>$$<br>\boldsymbol{X}=\begin{bmatrix} x_{1} &amp; x_{2} \ x_{3} &amp; x_{4} \end{bmatrix}=x_{1}\begin{bmatrix} 1 &amp; 0 \ 0 &amp; 0 \end{bmatrix}+x_{2}\begin{bmatrix} 0 &amp; 1 \ 0 &amp; 0 \end{bmatrix}+x_{3}\begin{bmatrix} 0 &amp; 0 \ 1 &amp; 1 \end{bmatrix}<br>$$</p><p>一组标准正交基为：</p><p>$$<br>\boldsymbol{X}_1 = \begin{bmatrix} 1 &amp; 0\ 0 &amp; 0 \end{bmatrix} \quad \boldsymbol{X}_2 = \begin{bmatrix} 0 &amp; 1\ 0 &amp; 0 \end{bmatrix} \quad \boldsymbol{X}_3 = \frac{1}{\sqrt{2}}\begin{bmatrix} 0 &amp; 0\ 1 &amp; 1 \end{bmatrix}<br>$$</p><h4 id="2-计算-T-在这组基下的矩阵表示">(2) 计算 $T$ 在这组基下的矩阵表示</h4><p>$$<br>T(\boldsymbol{X}_1 , \boldsymbol{X}_2, \boldsymbol{X}_3) = (\boldsymbol{X}_1 , \boldsymbol{X}_2, \boldsymbol{X}_3)\boldsymbol{A} \Rightarrow \boldsymbol{A} = \begin{bmatrix} 1 &amp; 2 &amp; 0\ 2 &amp; 1 &amp; 0\ 0 &amp; 0 &amp; 3 \end{bmatrix}<br>$$</p><h4 id="3-计算新的正交基，使-T-在该基下为对角矩阵">(3) 计算新的正交基，使 $T$ 在该基下为对角矩阵</h4><p>$$<br>\boldsymbol{A} =  \boldsymbol{Q}  \boldsymbol{\Lambda}  \boldsymbol{Q}^\top<br>$$</p><p>其中：</p><p>$$<br>\boldsymbol{\Lambda}= \begin{bmatrix} 3 &amp; &amp; \ &amp; 3 &amp; \ &amp; &amp; -1 \end{bmatrix} \quad \boldsymbol{Q}=\begin{bmatrix} 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} \ 0 &amp; \frac{1}{\sqrt{2}} &amp; -\frac{1}{\sqrt{2}} \ 1 &amp; 0 &amp; 0 \end{bmatrix}<br>$$</p><p>计算得到的新基：</p><p>$$<br>\boldsymbol{Y}_1 = \frac{1}{\sqrt{2}}\begin{bmatrix} 0 &amp; 0\ 1 &amp; 1 \end{bmatrix} \quad \boldsymbol{Y}_2 = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1\ 0 &amp; 0 \end{bmatrix} \quad \boldsymbol{Y}_3 = \frac{1}{\sqrt{2}}\begin{bmatrix} -1 &amp; 1\ 0 &amp; 0 \end{bmatrix}<br>$$</p><h2 id="线性变换的一般求法">线性变换的一般求法</h2><p>若 $V$ 是欧式空间，$T$ 是 $V$ 上的一个线性变换：</p><ol><li><p>任意找到 $V$ 的一个基，并通过 Schmidt 正交化法得到 $V$ 的一个标准正交基，记为 $e_1,e_2,\cdots,e_n$；</p></li><li><p>求 $T$ 在该标准正交基下的矩阵表示 $\boldsymbol{A}_0$：</p><p>$$ T(e_1,e_2,\cdots,e_n) = (e_1,e_2,\cdots,e_n)\boldsymbol{A}_0 $$</p></li><li><p>将 $\boldsymbol{A}_0$ 化为 Jordan 标准型 $\boldsymbol{J}$：</p><p>$$ \boldsymbol{A}_0 = \boldsymbol{P}\boldsymbol{J} \boldsymbol{P}^{-1} $$</p></li><li><p>右乘 $\boldsymbol{P}$：</p><p>$$ T(e_1,e_2,\cdots,e_n)\boldsymbol{P} = (e_1,e_2,\cdots,e_n)\boldsymbol{P}\boldsymbol{J} $$</p></li><li><p>取新基 $(\boldsymbol{E}_1, \boldsymbol{E}_2, \cdots, \boldsymbol{E}_n) = (\boldsymbol{e}_1 , \boldsymbol{e}_2, \cdots, \boldsymbol{e}_n)\boldsymbol{P}$，则线性变换在新基下的矩阵表示为 $\boldsymbol{J}$。</p></li></ol><p>以上方法可用于简化计算，使得多项式函数 $z = (T^k)(x),x\in V$ 的求解更加简便。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：若尔当标准型</title>
    <link href="/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B/"/>
    <url>/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>线性变换既然有矩阵表示，我们希望其应用到向量上得到的象能方便得到，即我们希望线性变换对应的矩阵尽量简单，比如能变为对角矩阵。为此，我们首先引入线性变换的特征值和特征向量，它和普通方阵类似。</p><h4 id="特征值与特征向量">特征值与特征向量</h4><p><strong>定义 1</strong> 设 $T: V \to V$ 是一个线性变换，如果存在 $\lambda_0 \in K$，使得存在非零向量 $x \in V$ 满足：<br>$$ T x = \lambda_0 x$$<br>那么我们称 $\lambda_0$ 是 $T$ 的<strong>特征值</strong>，$x$ 是 $T$ 属于 $\lambda_0$ 的<strong>特征向量</strong>。</p><p><strong>定义 2</strong> 设 $\boldsymbol{A} = (a_{ij})<em>{n\times n}$ 是数域 $K$ 上的 $n$ 阶矩阵，$\lambda$ 是参数，$\boldsymbol{A}$ 的特征矩阵 $\lambda I - A$ 的行列式：<br>$$<br>\det (\lambda I-A) = \begin{vmatrix}<br>\lambda-a</em>{11} &amp; -a_{12} &amp; \cdots &amp; -a_{1n} \<br>-a_{21} &amp; \lambda-a_{22} &amp; \cdots &amp; -a_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>-a_{n1} &amp; -a_{n2} &amp; \cdots &amp; \lambda-a_{nn}<br>\end{vmatrix}<br>$$<br>称为矩阵 $\boldsymbol{A}$ 的<strong>特征多项式</strong>，记为 $\varphi(\lambda)$。它的根 $\lambda_0$ 称为 $\boldsymbol{A}$ 的<strong>特征值</strong>，而对应的非零解向量 $(\xi_1, \xi_2, \dots, \xi_n)^T$ 称为 $\boldsymbol{A}$ 的属于特征值 $\lambda_0$ 的<strong>特征向量</strong>。</p><h3 id="最小多项式">最小多项式</h3><p><strong>定义 3</strong> 设 $\boldsymbol{A}$ 的首项系数为 $1$，次数最小，且以 $\boldsymbol{A}$ 为根的 $\lambda$ 的多项式，称为 $\boldsymbol{A}$ 的<strong>最小多项式</strong>，记为 $m(\lambda)$。</p><h3 id="最小多项式与特征多项式的关系">最小多项式与特征多项式的关系</h3><p><strong>定理 1</strong> 设矩阵 $\boldsymbol{A}$ 的最小多项式 $m(\lambda)$ 可整除以 $\boldsymbol{A}$ 为根的任一首 $1$ 多项式 $\psi(\lambda)$，且 $m(\lambda)$ 是唯一的。</p><p><strong>定理 2</strong> 矩阵 $\boldsymbol{A}$ 的最小多项式 $m(\lambda)$ 与其特征多项式 $\varphi(\lambda)$ 的零点相同（不计重数）。</p><p><strong>定理 3</strong> 设 $n$ 阶矩阵 $\boldsymbol{A}$ 的特征多项式为 $\varphi(\lambda)$，特征矩阵 $\lambda I - A$ 的全体 $n-1$ 阶子式的最大公因式为 $d(\lambda)$，则 $\boldsymbol{A}$ 的最小多项式为：<br>$$ m(\lambda) = \frac{\varphi(\lambda)}{d(\lambda)} $$</p><h3 id="Jordan-标准型">Jordan 标准型</h3><p><strong>定义 4</strong> 设矩阵 $\boldsymbol{J}$ 由以下 Jordan 块构成：<br>$$<br>\boldsymbol{J} = \begin{bmatrix}<br>\boldsymbol{J}_1(\lambda_1) &amp; &amp; &amp; \<br>&amp; \boldsymbol{J}_2(\lambda_2) &amp; &amp; \<br>&amp; &amp; \ddots &amp; \<br>&amp; &amp; &amp; \boldsymbol{J}_s(\lambda_s)<br>\end{bmatrix}<br>$$<br>其中，Jordan 块的形式如下：<br>$$<br>\boldsymbol{J}_i(\lambda_i) =<br>\begin{bmatrix}<br>\lambda_i &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \<br>0 &amp; \lambda_i &amp; 1 &amp; \cdots &amp; 0 \<br>0 &amp; 0 &amp; \lambda_i &amp; \cdots &amp; 0 \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; 1 \<br>0 &amp; 0 &amp; 0 &amp; \cdots &amp; \lambda_i<br>\end{bmatrix}<br>$$<br>称 $\boldsymbol{J}$ 为矩阵 $\boldsymbol{A}$ 的<strong>Jordan 标准型</strong>。</p><h3 id="计算-Jordan-标准型的步骤">计算 Jordan 标准型的步骤</h3><ol><li><p><strong>求矩阵 $\boldsymbol{A}$ 的初等因子组</strong>，设为：<br>$$ (\lambda - \lambda_1)^{m_1}, (\lambda - \lambda_2)^{m_2}, \dots, (\lambda - \lambda_s)^{m_s} $$<br>且 $m_1 + m_2 + \cdots + m_s = n$。</p></li><li><p><strong>写出每个初等因子对应的 Jordan 块</strong>。</p></li><li><p><strong>构造 Jordan 标准型</strong>：<br>$$ \boldsymbol{J} = \begin{bmatrix}<br>\boldsymbol{J}_1(\lambda_1) &amp; &amp; &amp; \<br>&amp; \boldsymbol{J}_2(\lambda_2) &amp; &amp; \<br>&amp; &amp; \ddots &amp; \<br>&amp; &amp; &amp; \boldsymbol{J}_s(\lambda_s)<br>\end{bmatrix}$$</p></li></ol><h3 id="计算工具">计算工具</h3><p>在实际计算中，Python 提供了强大的 <code>NumPy</code> 和 <code>SymPy</code> 库，可以用于快速计算 Jordan 标准型。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵论：欧式空间与线性变换介绍</title>
    <link href="/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D/"/>
    <url>/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="欧式空间与线性变换介绍">欧式空间与线性变换介绍</h2><p>欧式（Euclid）空间作为一种特殊的线性空间，我们先引入线性空间的概念。</p><h3 id="定义-1-线性空间">定义 1: 线性空间</h3><p>设 $V$ 是一个非空集合，它的元素用 $x, y, z$ 等表示，称为向量；$K$ 是一个数域，它的元素用 $k, l, m$ 表示，如果 $V$ 满足以下条件：</p><ol><li><p>在 $V$ 中定义一个加法运算，即当 $x,y\in V$ 时，有唯一的和 $x + y\in V$，且满足以下性质：</p><ul><li><strong>结合律</strong>: $x + (y + z) = (x + y) + z$;</li><li><strong>交换律</strong>: $x + y = y + x$;</li><li><strong>零元素存在性</strong>: $\exists 0, s.t. x + 0 = x$;</li><li><strong>负元素存在性</strong>: $\forall x\in V,\exists y\in V, s.t.x + y = 0$，记 $y = -x$;</li></ul></li><li><p>在 $V$ 中定义数乘运算，即当 $x\in V,k \in K$ 时，有唯一的乘积 $kx\in V$，且满足以下性质：</p><ul><li><strong>因子分配律</strong>: $k(x+y) = kx + ky$;</li><li><strong>分配律</strong>: $(k+l)x = kx + lx$;</li><li><strong>结合律</strong>: $k(lx) = (kl)x$;</li><li><strong>中性元</strong>: $1 x = x$;</li></ul></li></ol><p>则称 $V$ 是数域 $K$ 上的线性空间。</p><p>定义中的 8 条性质非常重要。如果对于数域 $K$，向量空间 $V$，设加群 $(V, +)$（$+$ 为 $V$ 上满足交换律的运算），不难验证其满足群的定义。定义 $K \times V \rightarrow V: (k, \alpha) \rightarrow k\alpha$（即 $V$ 上的数乘运算），可以验证 $V$ 是一个 $K$-模。即，线性空间是一类特殊的模。</p><p>为借助数量运算以实现向量的运算，还要引入向量的坐标。</p><h3 id="定义-2-线性空间的基">定义 2: 线性空间的基</h3><p>设 $V$ 是数域 $K$ 上的线性空间，$x_1,x_2,\cdots,x_r\in V$，如果它满足：</p><ol><li>$x_1,x_2,\cdots,x_r$ 线性无关;</li><li>$\forall x \in V$ 都是 $x_1,x_2,\cdots,x_r$ 的线性组合;</li></ol><p>则称 $x_1,x_2,\cdots,x_r$ 是 $V$ 的一个 <strong>基</strong>，称 $x_i(i=1,2,\cdots,r)$ 为 <strong>基向量</strong>。</p><h3 id="定义-3-坐标系">定义 3: 坐标系</h3><p>称线性空间 $V^n$ 上的一个基 $x_1, x_2, \cdots, x_n$ 为 $V^n$ 的一个 <strong>坐标系</strong>。设向量 $x \in V^n$，它在该基下的线性表示式为</p><p>$$<br>x = \xi_1x_1 + \xi_2x_2 + \cdots + \xi_nx_n<br>$$</p><p>则称 $\xi_1,\xi_2,\cdots,\xi_n$ 为 $x$ 在该基下的 <strong>坐标</strong> 或 <strong>分量</strong>，记为</p><p>$$<br>(\xi_1,\xi_2,\cdots,\xi_n)^\top<br>$$</p><p>显然，线性空间 $V^n$ 存在多个不同的基，对应多个不同的坐标系，我们希望研究当基改变时，向量的坐标如何改变。</p><h3 id="基变换">基变换</h3><p>首先介绍 <strong>基变换</strong>，即 $V^n$ 的一个基 $\boldsymbol{X} = ( \boldsymbol{x}_1,  \boldsymbol{x}_2, \cdots,  \boldsymbol{x}_n)$ 变为另一个基 $\boldsymbol{Y} = ( \boldsymbol{y}_1,  \boldsymbol{y}_2, \cdots,  \boldsymbol{y}_n)$。</p><p>由基的定义可知：</p><p>$$<br>\boldsymbol{y}<em>i = c</em>{1i} \boldsymbol{x}<em>1 + c</em>{2i}  \boldsymbol{x}<em>2 + \cdots + c</em>{1n}  \boldsymbol{x}_n(i = 1,2,\cdots,n)<br>$$</p><p>上式可以写成矩阵乘法形式：</p><p>$$<br>( \boldsymbol{y}_1,  \boldsymbol{y}_2, \cdots,  \boldsymbol{y}_n) =<br>( \boldsymbol{x}_1,  \boldsymbol{x}_2, \cdots,  \boldsymbol{x}_n) \boldsymbol{C}<br>\tag{2.5.1}<br>$$</p><p>其中矩阵</p><p>$$<br>\boldsymbol{C} = \begin{bmatrix}<br>c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n}\<br>c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n}\<br>\vdots &amp; \vdots &amp; &amp; \vdots\<br>c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn}<br>\end{bmatrix}<br>$$</p><p>称为基变换的 <strong>过渡矩阵</strong>，式 (2.5.1) 称为 <strong>基变换公式</strong>。</p><p>显然，过渡矩阵是可逆矩阵，因为新基能变换为旧基。</p><h2 id="内积与欧式空间">内积与欧式空间</h2><p>在线性空间中，向量的基本运算仅为线性运算。例如，在熟悉的二维或三维向量空间中，我们发现向量的模长、向量间的夹角等度量概念未能被线性空间直接表达。因此，我们引入<strong>内积</strong>与<strong>内积空间</strong>的概念。</p><h3 id="内积的定义">内积的定义</h3><p><strong>定义</strong><br>设 $V$ 是实数域 $\mathbb{R}$ 上的线性空间，若对 $\forall x,y \in V$，按照某种规则定义一个实数 $(x,y)$，满足以下条件：</p><ol><li><strong>交换律</strong>：$(x,y) = (y,x)$；</li><li><strong>分配律</strong>：$(x,y+z) = (x,y) + (x,z)$；</li><li><strong>齐次性</strong>：$(kx,y) = k(x,y) = (x,ky), \forall k\in \mathbb{R}$；</li><li><strong>非负性</strong>：$(x,x) \geq 0$，且 $(x,x) = 0 \iff x = 0$。</li></ol><p>则称 $(x,y)$ 为向量 $x,y$ 的<strong>内积</strong>，称 $V$ 为<strong>欧式空间</strong>（Euclidean Space）。</p><h3 id="内积的性质">内积的性质</h3><p>内积具有以下基本性质：</p><ul><li>$( \boldsymbol{x}, k \boldsymbol{y}) = k( \boldsymbol{x}, \boldsymbol{y})$；</li><li>$( \boldsymbol{x}, \boldsymbol{0}) = 0$。</li></ul><h3 id="向量的模长">向量的模长</h3><p>在欧式空间中，我们可以定义向量的<strong>长度</strong>（模、范数）如下：</p><p><strong>定义</strong><br>在欧式空间 $V$ 中，非负实数<br>$$<br>\left|  \boldsymbol{x} \right| = \sqrt{( \boldsymbol{x}, \boldsymbol{x})}<br>$$<br>称为向量 $\boldsymbol{x}$ 的<strong>长度</strong>（或 <strong>2-范数</strong>，下一节将介绍）。</p><p><strong>单位向量与单位化</strong><br>在二维或三维向量空间中，通常选取 $(1,0,0)$ 等为坐标轴，这些长度为 $1$ 的向量称为<strong>单位向量</strong>。如果 $\boldsymbol{x} \neq 0$，可以通过<strong>单位化（规范化）</strong> 得到单位向量：<br>$$<br>\boldsymbol{x}_0 = \frac{\boldsymbol{x}}{\left|  \boldsymbol{x} \right|}<br>$$</p><h3 id="向量夹角">向量夹角</h3><p>在低维空间中，向量的夹角概念较直观。为了在欧式空间中定义向量夹角，我们利用 <strong>Cauchy–Schwarz 不等式</strong>：<br>$$<br>\left| \frac{( \boldsymbol{x}, \boldsymbol{y})}{\left|  \boldsymbol{x}\right|\left|  \boldsymbol{y}\right|} \right| \leq 1<br>$$<br>进而定义两个非零向量 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 的夹角 $\left\langle  \boldsymbol{x},  \boldsymbol{y} \right\rangle$ 的<strong>余弦值</strong>：<br>$$<br>\cos \left\langle  \boldsymbol{x},  \boldsymbol{y} \right\rangle = \frac{( \boldsymbol{x}, \boldsymbol{y})}{\left|  \boldsymbol{x} \right| \left|  \boldsymbol{y} \right|}<br>$$</p><h3 id="向量正交">向量正交</h3><p><strong>定义</strong><br>若欧式空间中的两个向量 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 满足：<br>$$<br>(x,y) = 0<br>$$<br>则称它们<strong>正交（垂直）</strong>。</p><p><strong>定理</strong><br>在欧式空间中，若向量组 ${x_1, x_2, \dots, x_n}$ 互相正交，则它们必然线性无关。</p><h3 id="正交基与标准正交基">正交基与标准正交基</h3><p><strong>定义</strong><br>在欧式空间 $V^n$ 中，由 $n$ 个非零向量组成的<strong>正交向量组</strong>称为 $V^n$ 的<strong>正交基</strong>。若正交基中的向量均为单位向量，则称为<strong>标准正交基</strong>。</p><h3 id="Schmidt-正交化">Schmidt 正交化</h3><p>如何从一组普通的基构造标准正交基？一种方法是<strong>Schmidt 正交化法（Gram-Schmidt 过程）</strong>。</p><h4 id="施密特正交化步骤">施密特正交化步骤</h4><p>给定线性无关的向量组 ${ \boldsymbol{v}_1,  \boldsymbol{v}_2, \dots,  \boldsymbol{v}_n}$，施密特正交化的目标是构造正交向量组 ${ \boldsymbol{u}_1,  \boldsymbol{u}_2, \dots,  \boldsymbol{u}_n}$：</p><ol><li><p><strong>初始向量处理</strong>：<br>令第一个正交向量：<br>$$<br>\boldsymbol{u}_1 = \boldsymbol{v}_1<br>$$<br>由于 $\boldsymbol{v}_1 \neq 0$，则 $\boldsymbol{u}_1 \neq 0$。</p></li><li><p><strong>构造第 $i$ 个向量的正交化</strong>：<br>从第二个向量开始，为了从 $\boldsymbol{v}_i$ 中去掉前面向量 $\boldsymbol{u}<em>1, \dots, \boldsymbol{u}</em>{i-1}$ 的分量，定义投影：<br>$$<br>\frac{( \boldsymbol{v}_i,  \boldsymbol{u}_k)}{( \boldsymbol{u}_k,  \boldsymbol{u}_k)}  \boldsymbol{u}_k<br>$$<br>表示 $\boldsymbol{v}_i$ 在 $\boldsymbol{u}_k$ 上的投影。</p><p>去掉与 $\boldsymbol{u}<em>1, \dots, \boldsymbol{u}</em>{i-1}$ 重叠的部分，得到：<br>$$<br>\boldsymbol{u}_i = \boldsymbol{v}<em>i - \sum</em>{k=1}^{i-1} \frac{( \boldsymbol{v}_i,  \boldsymbol{u}_k)}{( \boldsymbol{u}_k,  \boldsymbol{u}_k)}  \boldsymbol{u}_k<br>$$</p></li><li><p><strong>归一化</strong>：<br>将每个 $\boldsymbol{u}_i$ 归一化为单位向量：<br>$$<br>\boldsymbol{e}_i = \frac{ \boldsymbol{u}_i}{\left| \boldsymbol{u}_i\right|}<br>$$</p></li></ol><p>最终得到一组<strong>正交归一向量</strong>：<br>$$<br>{ \boldsymbol{e}_1,  \boldsymbol{e}_2, \dots,  \boldsymbol{e}_n}<br>$$</p><p>有了以上的铺垫，接下来我们正式引入线性变换的概念。线性变换提供了一种在线性空间之间进行映射的框架，其本质在于保持向量空间中的线性结构。通过线性变换，我们可以将一个线性空间的元素映射到另一个线性空间中，并保持加法和标量乘法的运算法则。</p><h3 id="线性变换">线性变换</h3><p>首先，我们引入 <strong>变换</strong> 的概念如下：</p><p><strong>定义 4:</strong> 设 $V$ 是属于 $K$ 上的线性空间，$T$ 是 $V$ 到自身的一个映射，使对任意向量 $x\in V$，$V$ 中都有唯一向量 $y$ 与之对应，则称 $T$ 是 $V$ 的一个 <strong>变换</strong> 或 <strong>算子</strong>，记为 $Tx = y$，称 $y$ 为 $x$ 在 $T$ 下的象，$x$ 是 $y$ 的原象。</p><p><strong>定义 5:</strong> 如果数域 $K$ 上的线性空间 $V$ 的一个变换 $T$ 具有以下性质：</p><p>$$<br>T(kx + ly) = k(Tx) + l(Ty)<br>$$</p><p>其中，$x,y \in V,k,l\in K$，则称 $T$ 为 $V$ 的一个 <strong>线性变换</strong> 或 <strong>线性算子</strong>。</p><h4 id="线性变换的性质">线性变换的性质</h4><p>不难验证，线性变换有如下性质，且线性空间 $V$ 上所有的线性变换的集合，在所论的线性运算下，构成一个新的线性空间，记为 $\text{Hom}(V, V)$，称为线性空间 $V$ 的 <strong>同态</strong>。</p><ol><li><strong>线性变换的加法</strong>：$(T_1+ T_2)x = T_1x+T_2x, \forall x\in V$，和仍为线性变换。<ul><li>$T_1 + T_2 = T_2 + T_1$;</li><li>$(T_1 + T_2) + T_3 = T_1 + (T_2 + T_3)$;</li><li>$T + T_0 = T$;</li><li>$T + (-T) = T_0$;</li><li>线性变换 $T$ 的 <strong>负变换</strong> $-T$ 定义为： $$<br>(-T)x = -(Tx), \forall x\in V<br>$$</li></ul></li><li><strong>线性变换的数乘</strong>：$(kT)x = k(Tx), \forall x\in V$，线性变换的数乘仍是线性变换。<ul><li>$k(T_1 + T_2) = kT_1 + kT_2$;</li><li>$(k+l)T = kT + lT$;</li><li>$(kl)T = k(lT)$;</li><li>$1 T = T$;</li></ul></li></ol><h4 id="线性变换的矩阵表示">线性变换的矩阵表示</h4><p>诸如二维平面上的旋转、微分和积分等都是线性变换。考虑到有限维线性空间的向量可以用坐标表示出来，进一步考虑则可以通过坐标把线性变换用矩阵表示出来，从而可以把抽象的变换转化成具体的矩阵来处理。故引入线性变换的 <strong>矩阵表示</strong>。</p><p>设 $T$ 是线性空间 $V^n$ 的线性变换，$x \in V^n$，且 $x_1, x_2, \dots, x_n$ 是 $V^n$ 的一个基，则有：<br>$$<br>x = a_1x_1 + a_2x_2 + \dots + a_nx_n<br>$$<br>$$<br>Tx = a_1(Tx_1) + a_2(Tx_2) + \dots + a_n(Tx_n)<br>$$</p><p>这表明，$V^n$ 的任一向量 $x$ 的像可以由基像组 $Tx_1,Tx_2,\dots,Tx_n$ 唯一确定，因为基像组仍 $\in V^n$，所以有：<br>$$<br>\left.<br>\begin{matrix}<br>Tx_1 = a_{11}x_1 + a_{21}x_2 + \dots + a_{n1}x_n\<br>Tx_2 = a_{12}x_1 + a_{22}x_2 + \dots + a_{n2}x_n\<br>\cdots \<br>Tx_n = a_{1n}x_1 + a_{2n}x_2 + \dots + a_{nn}x_n\<br>\end{matrix}<br>\right}<br>\tag{2.6.1}<br>$$<br>即：<br>$$<br>Tx_i = \sum_{j=1}^{n} a_{ji}x_j, \quad i = 1,2,\dots,n<br>$$<br>用矩阵乘法表示式 (2.6.1) 为：<br>$$<br>T(x_1,x_2,\dots,x_n) = (Tx_1,Tx_2,\dots,Tx_n) = (x_1,x_2,\dots,x_n) \boldsymbol{A}<br>\tag{2.6.2}<br>$$<br>其中：<br>$$<br>\boldsymbol{A} = \begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}\<br>\cdots &amp; \cdots &amp; &amp; \cdots\<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\<br>\end{bmatrix}<br>$$<br>即矩阵 $\boldsymbol{A}$ 的第 $i$ 列为 $Tx_i$ 的坐标。</p><p><strong>定义 3</strong> 式 (2.6.2) 中的矩阵 $\boldsymbol{A}$ 称为 $T$ 在 $V^n$ 的基 $x_1, x_2, \dots, x_n$ 下的矩阵，称 $\boldsymbol{A}$ 为线性变换 $T$ 的矩阵表示。</p><h4 id="特殊的线性变换">特殊的线性变换</h4><ol><li><strong>零变换</strong>：$T_0(x) = \boldsymbol{0}, \forall x\in V$</li><li><strong>恒等变换</strong>：$T_1(x) = x, \forall x\in V$</li></ol><h3 id="正交变换">正交变换</h3><p><strong>定义 4</strong> 设 $V$ 为欧式空间，$T$ 是 $V$ 上的一个线性变换，如果 $T$ 保持 $V$ 中任意向量 $\boldsymbol{x}$ 的长度不变，则有：<br>$$<br>(T \boldsymbol{x},T \boldsymbol{x}) = ( \boldsymbol{x}, \boldsymbol{x})<br>$$<br>那么称 $T$ 是 $V$ 的一个 <strong>正交变换</strong>。</p><p><strong>定理 1</strong> 欧式空间上的线性变换是正交变换 $\Leftrightarrow$ 它对于标准正交基的矩阵是正交矩阵。</p><h3 id="对称变换">对称变换</h3><p><strong>定义 5</strong> 设 $V$ 为欧式空间，$T$ 是 $V$ 上的一个线性变换，且对 $V$ 中任意两个向量 $\boldsymbol{x}, \boldsymbol{y}$，都有：<br>$$<br>(T \boldsymbol{x}, \boldsymbol{y}) = ( \boldsymbol{x},T \boldsymbol{y})<br>$$<br>那么称 $T$ 是 $V$ 的一个 <strong>对称变换</strong>。</p><p><strong>定理 2</strong> 欧式空间上的线性变换是对称变换 $\Leftrightarrow$ 它对于标准正交基的矩阵是实对称矩阵。</p><p>对于线性变换的进一步求解，将在下一节中叙述。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑与数字系统相关记背知识点</title>
    <link href="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1>Verilog</h1><h2 id="标识符">标识符</h2><ul><li>命名规则与C语言相同；</li><li>关键字必须小写；</li><li><strong>存盘文件名应与设计的模块名相同</strong>；</li></ul><h2 id="概述">概述</h2><ul><li><strong>四值逻辑</strong>：0、1、X(不定)、Z(高阻)；</li><li>模块由两部分构成：<strong>描述接口、描述功能</strong>；<img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/1.png" alt=""></li></ul><h2 id="数据类型">数据类型</h2><ul><li>数据I/O类型；<img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/2.png" alt=""></li><li><strong>always中被赋值的信号必须用reg类型的变量</strong>；</li><li>输入和双向端口不能声明为reg型；</li><li>parameter：符号常量，其定义只在本模块内有效；</li></ul><h2 id="运算符">运算符</h2><ul><li>位连接运算符{  } ，将两个或多个信号的某些位拼接起来。<strong>不允许连接非定长常数</strong>；</li><li>自动调整位宽。运算表达式结果的长度由最长的操作数决定；</li><li>操作结果的长度:  由赋值左端目标长度决定；</li></ul><h2 id="功能描述语句">功能描述语句</h2><ul><li><strong>assign , always , 元件例化，是并发语句</strong>；</li></ul><h3 id="assign">assign</h3><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/3.png" alt=""></p><h3 id="always">always</h3><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/4.png" alt=""></p><h3 id="敏感信号表">敏感信号表</h3><ul><li>敏感信号的变化才能启动进程；</li><li>组合逻辑中，所有输入都作为敏感信号,否则仿真结果和综合结果会不一致；</li></ul><h3 id="注意点">注意点</h3><ul><li><strong>不要在一个aways 中同时使用= ，&lt;=赋值</strong>；</li><li>if、case、for 语句必需在 always 块中；</li></ul><h2 id="设计组合电路">设计组合电路</h2><h3 id="要求">要求</h3><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/5.png" alt=""></p><h2 id="设计时序电路">设计时序电路</h2><h4 id="要求-2">要求</h4><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/6.png" alt=""></p><h4 id="注意点-2">注意点</h4><ul><li><strong>异步信号必须放在敏感信号表中；必须都是边沿</strong>；</li><li>锁存器的所有输入都放在敏感信号表中；锁存器敏感信号都是电平。</li></ul><h2 id="元件例化">元件例化</h2><ul><li>一个元件是一段结构完整的 module 模块；</li><li><strong>不能在always语句内部引用子模块</strong>；</li></ul><h1>存储系统</h1><h2 id="寄存器堆">寄存器堆</h2><ul><li>由多个寄存器构成的集合。常用于数据寄存。 有三组外部信号：地址（短地址）、数据、读/写控制；</li><li>多端口寄存器；</li><li>可同时读、写， 可同时输出两个数；</li></ul><h2 id="寄存器队列">寄存器队列</h2><ul><li>FIFO（First In First Out，先进先出），用若干个移位寄存器构建的 小型存储部件。用于指令队列；</li><li>无地址线，双端口存储器，可同时读写；</li><li>FIFO用于两个不同系统通信、数据采集传送、串并转换；</li></ul><h2 id="寄存器栈">寄存器栈</h2><ul><li>LIFO（ Last In First Out，后进先出）方式，用若干个双向移位 寄存器构建的小型存储部件；</li><li>用于减少函数调用时对内存的访问；</li></ul><h2 id="RAM">RAM</h2><ul><li>特性：能读能写、易失；</li><li>作用：存放编写的程序和数据</li><li>逻辑结构：<img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/7.png" alt=""></li><li><strong>逻辑结构包括：地址译码器、存储矩阵和读写控制电路</strong>；</li><li>分为SRAM(Static RAM)和DRAM(Dynamic RAM)；<img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/8.png" alt=""><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/9.png" alt=""><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/10.png" alt=""></li></ul><h2 id="ROM">ROM</h2><ul><li>ROM的逻辑构成＝ <strong>与门阵列（地址译码器）＋或门阵列（存储矩阵）</strong>；</li><li>分为PROM、EPROM等；</li></ul><h2 id="存储器容量计算">存储器容量计算</h2><ul><li>单元数$\times$每单元的位数；即字数$\times$字长；</li></ul><h1>可编程逻辑器件PLD</h1><h2 id="概述-2">概述</h2><ul><li>现代数字系统由三种积木块构成：CPU＋PLD＋RAM；</li></ul><h2 id="编程部位">编程部位</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/11.png" alt=""></p><h2 id="编程方法">编程方法</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/12.png" alt=""></p><h2 id="CPLD">CPLD</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/13.png" alt=""></p><h2 id="FPGA">FPGA</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/14.png" alt=""><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/15.png" alt=""></p><h3 id="在系统可编程ISP">在系统可编程ISP</h3><ul><li>传统的PLD在用于生产时，是先编程后装配；</li><li><strong>isp则可以在装配之前、装配过程中和装配之后再编程</strong>；</li></ul><h1>数字系统</h1><h2 id="概述-3">概述</h2><ul><li>具有存储、传输、处理信息能力的逻辑系统集合；</li><li>由“<strong>数据通路+控制逻辑</strong>”构成，其工作具有周期性；</li><li><strong>数字系统与逻辑功能部件的区别：有无控制器</strong>；</li><li>在各部件之间传送信息的公共通路，称为<strong>数据通路</strong>。由总线连接的运算单元（组合电路）和存储单元构成；</li></ul><h2 id="总线">总线</h2><p><img src="/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/16.png" alt=""></p><h2 id="设计方法">设计方法</h2><ul><li>自顶向下方法（from top to down ）：是将规模较大的系统从逻辑上划分为控制电路＋受控电路；</li><li>步骤：<ol><li>划分子系统、子模块；</li><li>数据通路；</li><li>用数学语言(工具)，描述控制器的控制过程；</li><li>设计控制器；</li><li>设计数据处理器；</li></ol></li></ul><h1>END</h1><blockquote><p>希望别出太偏捏</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的染色问题</title>
    <link href="/2025/01/07/%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2025/01/07/%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>相关定义概述</h1><ul><li><strong>$\chi (G)$</strong>：图的着色数，the chromatic number of G；</li><li>有点着色，边着色，面着色几种类型；</li><li>$P_G(k)$：色多项式，表示图$G$用$k$种颜色染色的方法数；</li></ul><h1>常见图的点着色数</h1><blockquote><p>零图（无边只有顶点）：1；<br>完全图$K_n$：n；<br>非零二部图：2；</p></blockquote><blockquote><p>定理：简单图的点着色数小于等于最大度数 + 1；</p></blockquote><h1>非连通图的着色</h1><blockquote><p>如果$G$为非连通图，那么它的色多项式等于它的所有连通分量的乘积；</p></blockquote><h1>商图</h1><p>把图的顶点按照某种等价类规则划分，直观上就是把两个点捏在一起；<img src="/2025/01/07/%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/%E5%95%86%E5%9B%BE.png" alt=""></p><h1>构建色多项式</h1><h2 id="法一、尝试通过删边得到好求的色多项式">法一、尝试通过删边得到好求的色多项式</h2><p><img src="/2025/01/07/%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/%E8%89%B2%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%AE%9A%E7%90%86.png" alt=""></p><h2 id="法二、韦尔奇鲍威尔法">法二、韦尔奇鲍威尔法</h2><ol><li>将顶点按照度数递减排序；</li><li>用第一种颜色对度数最大的顶点以及和该点不相邻的所有顶点进行染色；</li><li>对剩余顶点重复上述步骤；</li></ol><h2 id="法三、递推构建色多项式">法三、递推构建色多项式</h2><p><img src="/2025/01/07/%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/%E8%89%B2%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%80%92%E6%8E%A8%E6%9E%84%E5%BB%BA.png" alt=""></p><h1>色多项式性质</h1><p><img src="/2025/01/07/%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/%E8%89%B2%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%80%A7%E8%B4%A8.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP Exercises</title>
    <link href="/2025/01/06/CSAPP%20Exercises/"/>
    <url>/2025/01/06/CSAPP%20Exercises/</url>
    
    <content type="html"><![CDATA[<h1>第二章</h1><h2 id="2-21">2.21</h2><p><img src="CSAPP%20Exercises/2.21.png" alt=""></p><h2 id="2-23">2.23</h2><p><img src="CSAPP%20Exercises/2.23.png" alt=""></p><h2 id="2-24">2.24</h2><p><img src="CSAPP%20Exercises/2.24.png" alt=""><br>两种类型都是先截断（对对应的无符号数取模操作），补码的话再进行一次U2T转化；</p><h2 id="2-33">2.33</h2><p><img src="CSAPP%20Exercises/2.33.png" alt=""></p><h2 id="2-40">2.40</h2><p><img src="CSAPP%20Exercises/2.40.png" alt=""></p><h2 id="2-44">2.44</h2><p><img src="CSAPP%20Exercises/2.44.png" alt=""><br>A. 反例：$x = -1, x - 1= 0$；<br>B. $x &amp; 0111_2 \ne 0111_2$当$x$的低3位有1位等于0时即可成立，$x &lt;&lt; 29 &lt; 0$将$x$的低3位移到高三位。那么低三位如果全为1，后者为真，有0则前者为真，所以表达式恒为真；<br>C. 反例：$x$为一个比较大的正数，平方后超过$2^{31} - 1$；<br>D. 真：$x = Tmin, -x = Tmin$，其余情况x如果是负数，那么-x一定是非负数；<br>E. 反例：$x = Tmin, -x = Tmin$；<br>F. 真：首先，比较类型为无符号数比较；加法都按补码进行运算，两边二进制结果显然一致；<br>G.真：$-y = \sim y + 1\rightarrow \sim y = -y - 1\rightarrow x * \sim y + uy * ux = x * (-y + y - 1) = -x$；全部按二进制表示理解即可；</p><h2 id="2-45">2.45</h2><p><img src="CSAPP%20Exercises/2.45.png" alt=""></p><h2 id="2-47">2.47</h2><p><img src="CSAPP%20Exercises/2.47.png" alt=""></p><h2 id="2-54">2.54</h2><p><img src="CSAPP%20Exercises/2.54.png" alt=""><br>A. double范围和精度比int大；<br>B. 假，int转化为float可能会发生舍入；<br>C. 假，double转化为float会截断；<br>D. double范围和精度比float大；<br>E. 没毛病，只需改变符号位；<br>F. 两边都先转化为double类型再运算；<br>G. 没毛病，即使溢出到正无穷也是大于0；<br>H. 假，浮点数运算不满足结合律；</p><h2 id="2-60">2.60</h2><p><img src="CSAPP%20Exercises/2.60.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">replace_byte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> x, <span class="hljs-type">int</span> i, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b)</span> &#123;<br><span class="hljs-type">int</span> i_times_8 = i &lt;&lt; <span class="hljs-number">3</span>; <span class="hljs-comment">// 将字节单位转化为位；</span><br><span class="hljs-type">unsigned</span> mask = <span class="hljs-number">0xFF</span> &lt;&lt; i_times_8; <span class="hljs-comment">// 将0xFF左移i个字节，得到第i个字节为FF，其余全为0的字符串；</span><br><span class="hljs-comment">// x &amp; ~mask 可以将x的第i个字节清0；</span><br><span class="hljs-comment">// b &lt;&lt; i_times_8 将b移动到第i个字节上；</span><br><span class="hljs-comment">// 两者进行或运算即可实现替换；</span><br><span class="hljs-keyword">return</span> (x &amp; ~mask) | (b &lt;&lt; i_times_8);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-65">2.65</h2><p><img src="CSAPP%20Exercises/2.65.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">odd_ones</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> x)</span> &#123;<br><span class="hljs-comment">// x的高位和低位进行异或，如果1对0，得到1；如果1对1或0对0，得到0，那么高位有奇数个1还是偶数个1的信息就被转移到低位中；</span><br>x = x ^ (x &gt;&gt; <span class="hljs-number">16</span>); <span class="hljs-comment">// 将x的高16位与低16位异或</span><br>x = x ^ (x &gt;&gt; <span class="hljs-number">8</span>);<br>x = x ^ (x &gt;&gt; <span class="hljs-number">4</span>);<br>x = x ^ (x &gt;&gt; <span class="hljs-number">2</span>);<br>x = x &amp; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-67">2.67</h2><p><img src="CSAPP%20Exercises/2.67.png" alt=""><br>A. C标准中，在32位机器上，移位32位是一种未定义的行为；<br>B. 很简单，先移31位，再移一位即可；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> beyond_msb = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">32</span>;<br><span class="hljs-comment">// 改为</span><br><span class="hljs-type">int</span> beyond_msb = set_msb &lt;&lt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>C. 类似地（16位机器上，移动n + 16位和移动n位效果一样）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> set_msb = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>;<br><span class="hljs-type">int</span> beyond_msb = set_msb &lt;&lt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="2-68">2.68</h2><p><img src="CSAPP%20Exercises/2.68.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lower_one_mask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br><span class="hljs-type">unsigned</span> Part = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 各位全1</span><br><span class="hljs-type">unsigned</span> len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">8</span> - n; <span class="hljs-comment">// 右移位数</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(Part &gt;&gt; len);<br>&#125;<br></code></pre></td></tr></table></figure><h1>第三章</h1><h2 id="3-1">3.1</h2><p><img src="CSAPP%20Exercises/3.1.png" alt=""></p><h2 id="3-2">3.2</h2><p><img src="CSAPP%20Exercises/3.2.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asmx86">movl %eax, (%rsp)<br>movw (%rax), %dx<br>movb $0xFF, %bl<br>movb (%rsp, %rdx, 4), %dl<br>movq (%rdx), %rax<br>movw %dx, (%rax)<br></code></pre></td></tr></table></figure><p>评价是别管Src和Dest，看哪个对涉及对寄存器取值了；</p><h2 id="3-3">3.3</h2><p><img src="CSAPP%20Exercises/3.3.png" alt=""></p><ol><li><strong>%ebx不能用来存放内存地址！！！</strong>（此题存了立即数0xF的在内存中的地址）；</li><li>%rax配movq，movl配%eax；</li><li>Src和Dest都在对内存进行引用；</li><li>%sl是什么东西；</li><li>立即数不能作为Dest；</li><li>%rdx和mol不匹配；</li><li>%si配movw；</li></ol><h2 id="3-4">3.4</h2><p><img src="CSAPP%20Exercises/3.4.png" alt=""></p><h2 id="3-5">3.5</h2><p><img src="CSAPP%20Exercises/3.5.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">decode1</span><span class="hljs-params">(<span class="hljs-type">long</span> *xp, <span class="hljs-type">long</span> *yp, <span class="hljs-type">long</span> *zp)</span> &#123;<br><span class="hljs-type">long</span> x = *xp;<br><span class="hljs-type">long</span> y = *yp;<br><span class="hljs-type">long</span> z = *zp;<br>*yp = x;<br>*zp = y;<br>*xp = z;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6">3.6</h2><p><img src="CSAPP%20Exercises/3.6.png" alt=""><br><strong>lea是直接取寄存器！！！</strong></p><h2 id="3-7">3.7</h2><p><img src="CSAPP%20Exercises/3.7.png" alt=""></p><h2 id="3-9">3.9</h2><p><img src="CSAPP%20Exercises/3.9.png" alt=""></p><h2 id="3-15">3.15</h2><p><img src="CSAPP%20Exercises/3.15.png" alt=""><br>A. <code>4003fc + 0x02 = 4003fe</code>；<br>B. <code>400431 + 0xf4 = 400425</code>；<br>C. ja:<code>400547</code>；pop指定的地址 + 0x02 = ja的跳转地址，所以pop:<code>400545</code>；<br>D. <code>4005ed + 0x ff ff ff 73 = 400560</code>；</p><h2 id="3-18">3.18</h2><p><img src="CSAPP%20Exercises/3.18.png" alt=""></p><h2 id="3-20">3.20</h2><p><img src="CSAPP%20Exercises/3.20.png" alt=""></p><h2 id="3-26">3.26</h2><p><img src="CSAPP%20Exercises/3.26.png" alt=""><br>A. 中间翻译法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> Test;<br>Loop:<br>body;<br><br>Test:<br>t = test;<br><span class="hljs-keyword">if</span> (t) <span class="hljs-keyword">goto</span> Loop;<br>end;<br></code></pre></td></tr></table></figure><p>B.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>val = x ^ val;<br>x = x &gt;&gt; <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C. 从一个无符号长整数$x$的最高有效位开始，逐位移除最低有效位，直到剩下最后一个有效的非零位。然后检查该值的最低有效位是否为 1，并返回结果。即判断$x$的奇偶性；</p><h2 id="3-27">3.27</h2><p><img src="CSAPP%20Exercises/3.27.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Jump-to-middle</span><br>init:<br><span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">goto</span> test;<br>loop:<br>result *= i;<br>i++;<br><br>test:<br><span class="hljs-keyword">if</span> i &lt;= n:<br><span class="hljs-keyword">goto</span> loop;<br>done;<br><br><span class="hljs-comment">// guarded-do</span><br>init:<br><span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">goto</span> end;<br>loop:<br>result *= i;<br>i++;<br><span class="hljs-keyword">if</span> (t) <span class="hljs-keyword">goto</span> loop;<br>end;<br></code></pre></td></tr></table></figure><h2 id="3-31">3.31</h2><p><img src="CSAPP%20Exercises/3.31.png" alt=""></p><h2 id="3-32">3.32</h2><p><img src="CSAPP%20Exercises/3.32.png" alt=""></p><h2 id="3-33">3.33</h2><p><img src="CSAPP%20Exercises/3.33.png" alt=""></p><h2 id="3-36">3.36</h2><p><img src="CSAPP%20Exercises/3.36.png" alt=""></p><h2 id="3-37">3.37</h2><p><img src="CSAPP%20Exercises/3.37.png" alt=""></p><h2 id="3-38">3.38</h2><p><img src="CSAPP%20Exercises/3.38.png" alt=""></p><h2 id="3-44">3.44</h2><p><img src="CSAPP%20Exercises/3.44.png" alt=""></p><table><thead><tr><th>P1</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>i</td><td>i</td><td>i</td><td>i</td><td>c</td><td>X</td><td>X</td><td>X</td></tr><tr><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td></tr><tr><td>j</td><td>j</td><td>j</td><td>j</td><td>d</td><td>X</td><td>X</td><td>X</td></tr><tr><td>P1共占16个字节；</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>P2</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>i</td><td>i</td><td>i</td><td>i</td><td>c</td><td>d</td><td>X</td><td>X</td></tr><tr><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td></tr><tr><td>j</td><td>j</td><td>j</td><td>j</td><td>j</td><td>j</td><td>j</td><td>j</td></tr><tr><td>P2共占16个字节；</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>P3</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>w[0]</td><td>w[0]</td><td>w[1]</td><td>w[1]</td><td>w[2]</td><td>w[2]</td><td>c[0]</td><td>c[1]</td></tr><tr><td>8</td><td>9</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>c[2]</td><td>X</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>P3共占10个字节；</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>P4</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>w</td><td>w</td><td>w</td><td>w</td><td>w</td><td>w</td><td>w</td><td>w</td></tr><tr><td>8</td><td>9</td><td>10</td><td>…</td><td></td><td></td><td></td><td></td></tr><tr><td>w</td><td>w</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>16</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td>P4共占40个字节；</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>P5</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td>8</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>a</td><td>X</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td>16</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>a</td><td>a</td><td>a</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>24</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td></tr><tr><td>P5共占40个字节；</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="3-45">3.45</h2><p><img src="CSAPP%20Exercises/3.45.png" alt=""></p><table><thead><tr><th>rec</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td><strong>a</strong></td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td><strong>8</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>b</strong></td><td>b</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>16</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>c</strong></td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td><strong>24</strong></td><td></td><td></td><td></td><td><strong>28</strong></td><td></td><td></td><td></td></tr><tr><td>d</td><td></td><td></td><td></td><td><strong>e</strong></td><td>e</td><td>e</td><td>e</td></tr><tr><td><strong>32</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>f</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>40</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td></tr><tr><td><strong>48</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>h</strong></td><td>h</td><td>h</td><td>h</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>rec共占56个字节；</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>rec’</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td><strong>a</strong></td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td><strong>8</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>c</strong></td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td><strong>16</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>g</strong></td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td></tr><tr><td><strong>24</strong></td><td></td><td></td><td></td><td><strong>28</strong></td><td></td><td></td><td></td></tr><tr><td><strong>e</strong></td><td>e</td><td>e</td><td>e</td><td><strong>h</strong></td><td>h</td><td>h</td><td>h</td></tr><tr><td><strong>32</strong></td><td></td><td><strong>34</strong></td><td><strong>35</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>b</strong></td><td>b</td><td><strong>d</strong></td><td><strong>f</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>rec‘总共占40个字节；</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1>第七章</h1><h2 id="7-1">7.1</h2><p><img src="CSAPP%20Exercises/7.1.png" alt=""></p><h2 id="7-2">7.2</h2><p><img src="CSAPP%20Exercises/7.2.png" alt=""></p><h2 id="7-4">7.4</h2><p><img src="CSAPP%20Exercises/7.4.png" alt=""><br>A. <code>4004de + 1 = 4004df</code>（callq的机器码e8占一个字节）；<br>B. <code>0x 00 00 00 05</code>，注意小端法！！！</p><h2 id="7-5">7.5</h2><p><img src="CSAPP%20Exercises/7.5.png" alt=""><br>重定位条目包含了以下信息：</p><ul><li>R_X86_64_PC32表示采用PC相对寻址法；</li><li>offset表示偏移量为0xa = 10；</li><li>addend可以修正偏移量；<br>$r_{ptr} = 0x4004e8 - (0x4004d0 + 0xa) + (-4) = 10 = 0x0a$；<br>所以引用的值是0x 00 00 00 0a；在汇编代码中被更新为：<code>e8 0a 00 00 00</code>；</li></ul><h1>第十章</h1><h2 id="10-1">10.1</h2><p><img src="CSAPP%20Exercises/10.1.png" alt=""></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">fd2</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>原因是<code>Close(fd1)</code>后，文件描述符被释放；</p><h2 id="10-2">10.2</h2><p><img src="CSAPP%20Exercises/10.2.png" alt=""></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> f<br></code></pre></td></tr></table></figure><p>fd1读取一个字节后，文件位置确实++了，但fd1和fd2分两次打开，对应不同的描述符，从而对应不同的打开文件表，所以互不影响；</p><h2 id="10-3">10.3</h2><p><img src="CSAPP%20Exercises/10.3.png" alt=""></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> o<br></code></pre></td></tr></table></figure><p>父子进程共享同一个打开文件表；</p><h2 id="10-5">10.5</h2><p><img src="CSAPP%20Exercises/10.5.png" alt=""></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">c</span> <span class="hljs-operator">=</span> o<br></code></pre></td></tr></table></figure><p>dup2将fd1重定向到fd2；</p><p>最后祝自己明天考试好运吧！</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 16-io4</title>
    <link href="/2025/01/05/CSAPP%2016-io4/"/>
    <url>/2025/01/05/CSAPP%2016-io4/</url>
    
    <content type="html"><![CDATA[<h1>UNIX/Linux I/O</h1><ul><li>用户程序可通过调用特定的I/O函数的方式提出I/O请求。</li><li>在UNIX/Linux系统中，可以是<strong>C标准I/O库函数</strong>或<strong>系统调用的封装函数</strong>，前者如文件I/O函数<code>fopen()、fread()、fwrite()、fclose()</code>或控制台I/O函数<code>printf()、putc()、scanf()、getc()</code>等；后者如<code>open()、read()、write()、close()</code>等。</li><li>标准I/O库函数比系统调用封装函数抽象层次高，后者属于系统级I/O函数。与系统提供的API函数一样，前者是基于后者实现的。</li></ul><h2 id="概述">概述</h2><p>“一切皆文件”；</p><ul><li>Linux中的文件都是二进制比特串；</li><li>所有的I/O设备在系统中都以文件形式呈现：<ul><li>/dev/sda2</li><li>/dev/tty2</li></ul></li><li>内核也以文件形式呈现：<ul><li>/boot/vmlinuz-3.13.0-55-generic (kernel image)</li><li>/proc (kernel data structures)</li></ul></li></ul><h2 id="文件分类">文件分类</h2><h3 id="Regular-Files">Regular Files</h3><ul><li>Text files：用ASCII或Unicode字符编码的文件；</li><li>Binary files：可执行目标文件，图片；</li><li><strong>Kernal内核不能区分这两者</strong>；</li></ul><h3 id="Directories">Directories</h3><p>一些常用命令：</p><ul><li><code>mrdir</code>创建文件夹；</li><li><code>ls</code>查看文件夹内容；</li><li><code>rmdir</code>删除文件夹（文件夹必须是空的）；</li><li><code>.</code>链接自己，<code>..</code>链接它的父文件夹，<code>cd ..</code>即可返回上一级目录；<br>Linux 文件系统<strong>以 /（根目录）为起点</strong>，所有文件和目录都组织在这个树状层次结构下。</li></ul><h2 id="文件操作">文件操作</h2><h3 id="打开文件">打开文件</h3><p>打开文件时，内核会返回一个小的非负整数，称为<strong>描述符</strong>；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 成功则返回新文件描述符，失败返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><p>返回的是在进程中当前没有被打开的最小描述符，由于进程开始时都会创建三个文件：</p><ul><li>0：stdin；</li><li>1：stdout；</li><li>2：stderr；<br>所以文件描述符一般从3开始；</li></ul><h4 id="文件共享">文件共享</h4><p><img src="CSAPP%2016-io4/2.png" alt=""><img src="CSAPP%2016-io4/3.png" alt=""></p><h3 id="读写文件">读写文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> n)</span>; <span class="hljs-comment">// 返回成功读取的字节数，失败为-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> n)</span>; <span class="hljs-comment">// 同上</span><br></code></pre></td></tr></table></figure><p>注意ssize_t被定义为signed long类型，因为它需要返回-1，而size_t是unsigned long类型；<br><strong>Short count</strong>指的是当执行 I/O 操作（如 read 或 write）时，实际读取或写入的字节数小于请求的字节数，如遇到以下情况：</p><ul><li><strong>遇到文件末尾 (EOF)</strong></li><li><strong>从终端读取文本行</strong></li><li><strong>从网络套接字读取或写入</strong><br>当向磁盘读取或写入时一般不会发生；</li></ul><h1>创建进程</h1><h3 id="Fork语句">Fork语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Pid_t <span class="hljs-title function_">Fork</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>返回值为进程编号：</p><ul><li>0为子进程；</li><li><blockquote><p>0为父进程；</p></blockquote></li><li>-1为Fork失败；<br><img src="CSAPP%2016-io4/1.png" alt=""><br>fork会复制fork之后的所有代码创建子进程；其执行过程如下：<img src="CSAPP%2016-io4/4.png" alt=""><br>注意进程的调度规则不定，哪个先执行完都有可能；</li></ul><h1>I/O重定向</h1><p>比如，我们希望将当前进程的stdout改为另一个文件，即更改描述符表；通过dup2来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br></code></pre></td></tr></table></figure><p>如果原来fd1指向文件A，调用dup2(4,1)后：<img src="CSAPP%2016-io4/5.png" alt=""></p><h2 id="一个读的例子">一个读的例子</h2><p><img src="CSAPP%2016-io4/6.png" alt=""><br>需要明确子进程和父进程共享同一打开文件表；</p><ul><li><code>s = getpid() &amp; 0x1</code>决定了进程的执行顺序，如果s = 0，则父进程先执行，如果s = 1，则子进程先执行；</li><li>fork前的<code>Read(fd1, &amp;c1, 1)</code>，已经从打开文件中读取一个字符a到c1，打开文件表中的文件位置++；</li><li>执行fork后，父子中先执行的进程执行<code>Read(fd2, &amp;c2, 1)</code>，即c2 = b，同时文件位置++，并输出结果；</li><li>后执行的进程执行<code>Read(fd2, &amp;c2, 1)</code>，即c2 = c，同时文件位置++，并输出结果；<br>结果有2种可能：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Parent:</span> <span class="hljs-built_in">c1</span> = a, <span class="hljs-built_in">c2</span> = <span class="hljs-keyword">b</span><br><span class="hljs-symbol">Child:</span> <span class="hljs-built_in">c1</span> = a, <span class="hljs-built_in">c2</span> = c<br><br><span class="hljs-symbol">Child:</span> <span class="hljs-built_in">c1</span> = a, <span class="hljs-built_in">c2</span> = <span class="hljs-keyword">b</span><br><span class="hljs-symbol">Parent:</span> <span class="hljs-built_in">c1</span> = a, <span class="hljs-built_in">c2</span> = c<br></code></pre></td></tr></table></figure><h2 id="一个写的例子">一个写的例子</h2><p><img src="CSAPP%2016-io4/11.png" alt=""><br>首先需要明确一些标志的含义：</p><ul><li>O_CREAT：如果文件不存在，创建文件；</li><li>O_TRUNC：如果文件存在，则清空文件内容；</li><li>O_RDWR：文件以读写方式打开；</li><li>O_APPEND：每次写操作都会将数据追加到文件末尾；</li><li>O_WRONLY：仅允许写操作；<br><code>dup(fd1)</code>复制文件描述符 fd1 到 fd2 ，新描述符 fd2 与 fd1 共享相同的文件表项；<br><code>Write(fd1, &quot;pqrs&quot;, 4)</code>将&quot;pqrs&quot;写入文件；<br><code>Write(fd3, &quot;jklmn&quot;, 5)</code>将&quot;jklmn&quot;写入文件末尾；<br><code>Write(fd2, &quot;wxyz&quot;, 4)</code>将&quot;wxyz&quot;写入文件，注意fd1的文件位置为4(写入pqrs后)，所以此时文件的内容为&quot;pqrswxyz&quot;；<br><code>Write(fd3, &quot;ef&quot;, 2)</code>将“ef”仍写入文件末尾；<br>所以最终答案为：“pqrswxyzef”；</li></ul><h1>Standard I/O</h1><p>标准I/O库将一个打开的文件模型化为一个<strong>流</strong>。对于程序员而言，一个流就是一个指<br>向FILE 类型的结构的指针。每个ANSIC程序开始时都有三个打开的流stdin、stdout<br>和stderr，分别对应于标准输人、标准输出和标准错误；<br><img src="CSAPP%2016-io4/7.png" alt=""></p><h1>Unix I/O vs. Standard I/O</h1><p><img src="CSAPP%2016-io4/8.png" alt=""></p><h1>系统调用和API</h1><ul><li>应用编程接口（API）与系统调用两者在概念上不完全相同，它们都是系统提供给用户程序使用的编程接口，但前者指的是功能更广泛、抽象程度更高的函数，后者仅指通过软中断（自陷）指令向内核态发出特定服务请求的函数。</li><li>系统调用封装函数是 API 函数中的一种。</li><li>API 函数最终通过调用系统调用实现 I/O。一个API 可能调用多个系统调用，不同 API 可能会调用同一个系统调用。但是，并不是所有 API 都需要调用系统调用。</li><li>API 在用户态执行，系统调用封装函数也在用户态执行，但具体服务例程在内核态执行。</li></ul><h1>I/O 类型</h1><ul><li><strong>Programmed I/O</strong>：无条件传统方式，查询方式，效率低；<img src="CSAPP%2016-io4/9.png" alt=""></li><li><strong>Interrupt Driven I/O</strong>：中断驱动 I/O 中，<strong>处理器启动 I/O 操作后无需等待，可以执行其他任务</strong>，直到设备通过中断信号通知处理器数据传输完成；</li><li><strong>DMA</strong>：<strong>由 DMA 模块负责在 I/O 单元和主存之间直接传输数据</strong>，无需处理器干预；</li></ul><h1>总结</h1><p><img src="CSAPP%2016-io4/10.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 14-ecf-procs</title>
    <link href="/2025/01/05/CSAPP%2014-ecf-procs/"/>
    <url>/2025/01/05/CSAPP%2014-ecf-procs/</url>
    
    <content type="html"><![CDATA[<p>正常来讲，程序计数器PC会在处理器运行时不断地读取指令序列的地址，两个指令间的过渡被称为<strong>控制转移</strong>，该指令序列被称为<strong>控制流</strong>，其中包含一些平滑的突变（即两条指令之间不相邻，如函数调用）；</p><p>异常是指指令地址在控制流中发生突变所做出的反应；系统通过对突变做出反应，将这种突变称为<strong>异常控制流ECF</strong>；</p><h1>异常处理</h1><h2 id="1-概述">1. 概述</h2><p>当有事件发生时，会通过一个跳转表（被称为异常表，每个异常编号对应一个索引存储的条目的地址），进行一个间接过程的调用（异常），转移控制给异常处理程序，当异常处理程序处理完成后，根据异常的类型，有以下三种结果：</p><ul><li>返回控制给$I_{cur}$；</li><li>返回控制给$I_{next}$；</li><li>终止被中断的程序；<br><img src="./CSAPP%2014-ecf-procs/1.png" alt=""><br>异常控制使得控制从用户态转移到内核态，被压入内核栈中；</li></ul><h2 id="2-异常类型">2. 异常类型</h2><p>异常包含以下几种类型：</p><ul><li>Interrupts中断（Asynchronous异步的，其余都是Synchronous同步的）；</li><li>Traps陷阱；</li><li>Faults故障；</li><li>Aborts终止；</li></ul><h3 id="中断">中断</h3><p>由外部事件引起，并非专门的指令造成的，比如Timer interrupt（看门狗中断）、I/O interrupt；</p><h3 id="陷阱">陷阱</h3><p>故意执行的异常，<strong>在用户程序和内核之间提供一个接口，称为系统调用System Calls</strong>；执行完后返回$I_{next}$继续执行；</p><h3 id="故障">故障</h3><p>由错误情况引起，将控制转移给故障处理程序，比如<strong>缺页异常（可修复的）</strong>；执行完后返回$I_{cur}$继续执行或者终止；<br><img src="./CSAPP%2014-ecf-procs/2.png" alt=""><br>以上例子中，当执行到该指令时，a[500]存放在磁盘中，需要从磁盘加载到内存中，此时触发故障，故障处理程序缺失的地址送到内存后，返回$I_{cur}$重新执行，此时能正确加载数据；<br><img src="./CSAPP%2014-ecf-procs/3.png" alt=""><br>以上例子中，故障处理程序发现该地址是虚拟空间的无效地址，因此报段错误；</p><h3 id="终止">终止</h3><h3 id="Linux提供的系统调用">Linux提供的系统调用</h3><p>和异常表不是一个东西！！！<img src="./CSAPP%2014-ecf-procs/4.png" alt=""><br>一个打开文件的例子，注意 <strong><code>%rax</code>存放syscall number</strong>，同时存放返回值，如果返回值小于0说明发生错误；<img src="./CSAPP%2014-ecf-procs/5.png" alt=""><br>注意系统调用和函数调用的区别：</p><ul><li>系统调用是在内核态中执行的；</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 13-linking</title>
    <link href="/2025/01/05/CSAPP%2013-linking/"/>
    <url>/2025/01/05/CSAPP%2013-linking/</url>
    
    <content type="html"><![CDATA[<h1>链接概述</h1><ul><li>源程序的编译<code>gcc -Og -o prog main.c swap.c</code>可以分为以下四个阶段：<ul><li>Pre-Processor预处理(cpp)<ul><li><code>cpp -o main.i main.c</code> or <code>gcc -E -o main.i main.c</code>，<code>-E</code>为限制gcc只做预处理工作</li></ul></li><li>Compiler编译(ccl)<ul><li><code>cc -S -o main.s main.i</code> or <code>gcc -S -o main.s main.i</code>，<code>-S</code>表示只做编译；</li></ul></li><li>Assmebler汇编(as)<ul><li><code>as -o main.o main.s</code>，这步得到的是<strong>可重定位文件</strong>；</li></ul></li><li>Linker链接(ld)<ul><li><code>ld -static -o prog main.o sum.o</code>以及其他库文件，<code>-static</code>表示静态编译<br><img src="./CSAPP%2013-linking/1.png" alt=""></li></ul></li></ul></li><li>链接动作在编译、加载和运行时都可以被执行</li></ul><h2 id="1-静态链接器Linker任务：">1. 静态链接器Linker任务：</h2><ol><li>Symbol resolution 符号解析（符号绑定）：<ol><li>将<strong>引用符号和定义符号建立关联</strong>；</li><li>定义的实质是被分配了存储空间，为函数名制定了其代码所在区，为变量名制定了其所占的静态数据去；</li><li>掌握如何区分定义符号和应用符号；</li></ol></li><li>Relocation 重定位：<ol><li>合并相同的节；例如，所有.text节合并作为可执行文件中的.text节；</li><li>对定义符号进行重定位，确定地址；例如，为函数确定首地址，进而确定每条指令的地址，为变量确定首地址；</li><li>对引用符号进行红定位，确定地址；需要用到在.rel_data和.rel_text节中保存的重定位信息；</li></ol></li></ol><h2 id="2-符号解析：">2. 符号解析：</h2><ul><li>Global symbol：自定他用，全局可见，跨模块使用，在链接时进行符号解析：</li><li>External symbol：他定自用，和Glbal Symbol相对，链接时在其他模块中查找；</li><li>Local symbol：自定自用，局部符号通常由<code>static</code>修饰，限制其作用域。</li><li>注意区分Local non-static varibles、Local static varibles：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> x = <span class="hljs-number">15</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> x = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">return</span> x++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">g</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> x = <span class="hljs-number">19</span>;<br><span class="hljs-keyword">return</span> x += <span class="hljs-number">14</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">h</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> x += <span class="hljs-number">27</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意区分上面每个$x$，函数$f$和$g$中的都是作用域在函数内的<strong>局部静态变量</strong></li><li>最外面的$x$，即函数$h$引用的是<strong>文件范围内的静态变量</strong>；</li><li>全局符号的符号解析：如果存在多个定义相同名字的全局变量：<ul><li><strong>强符号</strong>：<strong>函数以及初始化的全局变量</strong>；</li><li><strong>弱符号</strong>：<strong>未初始化的全局变量</strong>；<img src="./CSAPP%2013-linking/2.png" alt=""></li><li>规则：<ul><li>不许有多个同名的强符号，否则Linker error；</li><li>如果有一个同名的强符号和多个弱符号，则取强；</li><li>如果有多个同名的弱符号，随机选择；</li></ul></li><li>注意，<strong>链接器不做类型检查</strong>，所以会发生如下问题：<img src="./CSAPP%2013-linking/3.png" alt=""></li><li>引用double类型的x变量（8bytes）时可能会覆盖y的空间；</li></ul></li></ul><h2 id="3-目标文件Object-Files">3. 目标文件Object Files</h2><ul><li>可重定位目标文件(.o file)</li><li>可执行目标文件(a.out file)：前者经过链接得到的产物，可以直接复制到内存中并执行；</li><li>共享目标文件(.so file)：特殊的可重定位目标文件，可以在程序加载或运行时被动态地加载进内存并链接；</li></ul><h2 id="4-ELF可重定位目标文件（可执行可链接模式）：">4. ELF可重定位目标文件（可执行可链接模式）：</h2><p><img src="./CSAPP%2013-linking/4.png" alt=""></p><ul><li>ELF header：16字节的序列，包括字的大小等信息；</li><li>.text section：代码段；</li><li>.rodata section：只读数据，比如switch的跳转表、printf的格式字符串；</li><li>.data：初始化的全局变量和静态C变量；</li><li>.bss：未初始化以及初始化为0的全局变量和静态C变量；<ul><li>实际上不占用任何存储空间，仅是一个占位符；</li><li>Better Save Space；</li><li>运行时自动分配这些变量的初始值为0；</li><li>有些题目比较恶心，会区分.bss和COMMOM：<ul><li>.bss存放未被初始化的静态变量以及初始化为0的全局或静态变量；</li><li>COMMOM存放未被初始化的全局变量；</li></ul></li></ul></li><li>.symtab：符号表；</li><li>.rel.txt，.rel.data，占位符，即引用别的模块中定义的全局变量和函数的指令的占位符，就是下图箭头所指的；<img src="./CSAPP%2013-linking/6.png" alt=""></li><li>.debug：调试信息(需要加上<code>gcc -g</code>)；</li><li>Section header table：每个节的大小信息；</li></ul><h2 id="5-可执行文件的目标文件格式">5.可执行文件的目标文件格式</h2><p><img src="./CSAPP%2013-linking/5.png" alt=""></p><ul><li>多了一个程序头表：包含第一条指令的地址；</li><li>少了.rel.txt和.rel.data，因为已经链接完了，无需再重定位；</li></ul><h2 id="6-重定位">6. 重定位</h2><ul><li>重定位信息：<img src="./CSAPP%2013-linking/7.png" alt=""></li></ul><h3 id="R-386-PC32重定位方式">R_386_PC32重定位方式</h3><p><img src="./CSAPP%2013-linking/8.png" alt=""></p><ul><li>根据重定位前的.o文件，能得到哪些信息？<ul><li>main在.text节中偏移为0处开始，占0x12bytes；</li><li><code>e8 fc ff ff ff</code>中，<code>e8</code>是<code>call</code>的机器码，后面应该存放swap函数的地址，但目前未重定位，所以没有意义，是占位符；</li><li>下一行的<code>7: R_386_PC32 swap</code>也是占位符，用于重定位，7表示需要在地址7(6 + 1，call的机器码占一个字节)处进行重定位，R_386_PC32表示需要计算的是PC相对地址；<br><img src="./CSAPP%2013-linking/9.png" alt=""></li></ul></li><li>根据以上信息，问题是：<br><img src="./CSAPP%2013-linking/10.png" alt=""></li><li>main函数从<code>0x8048380</code>开始，占0x12bytes，swap紧跟main后，所以其起始地址为<code>0x8048380 + 0x12 = 0x804892B</code>，由于其机器代码首地址需要按4字节边界对齐，所以应该是<code>0x8048394</code>；</li><li><strong>重定位后，call指令的机器代码应该是什么？</strong><ul><li>由于采用R_386_PC32相对地址法，转移目标地址 = PC + 偏移地址(重定位值)；</li><li>在执行call时，PC指向call指令的下一条地址，即<code>0x8048380 + 0x7 = 0x8048387</code>；</li><li>但是，<strong>由于一开始有一个占位的初始偏移值<code>fc ff ff ff</code>即-4，链接器在进行重定位之前，会先减掉这个临时的偏移量</strong>，所以，正确的PC地址应该是<code>0x8048387 - (-4) = 0x804838b</code>；</li><li>事实上，这个PC地址就是call指令的下一条语句的地址；</li><li>重定位值 = 转移目标地址 - PC = <code>0x8048394 - 0x804838b = 0x9</code>；</li><li>然后链接器将call指令的机器代码修正为<code>e8 09 00 00 00</code>；（小端法）</li></ul></li></ul><h3 id="R-386-32的重定位方式">R_386_32的重定位方式</h3><p><img src="./CSAPP%2013-linking/11.png" alt=""></p><h1>静态库链接Static Libraries</h1><ul><li>将所有相关的目标文件模块打包成一个单独的文件，称为静态库；</li><li>使链接器构造可执行文件时，只要复制静态库里被程序引用的目标模块；</li><li>相比于链接整个模块，减少了可执行文件在磁盘和内存中的大小；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">create static libraries</span><br><span class="hljs-meta prompt_">unix&gt; </span><span class="language-bash">ar rs libc.a \ atoi.o printf.o ... random.o</span><br></code></pre></td></tr></table></figure><p><img src="./CSAPP%2013-linking/12.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">与静态库链接</span><br><span class="hljs-meta prompt_">unix&gt; </span><span class="language-bash">gcc -static -o prog2r \ main2.o -L. -lvector</span><br></code></pre></td></tr></table></figure><p><img src="./CSAPP%2013-linking/13.png" alt=""></p><ul><li>自定义创建静态库文件（ar工具）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell">gcc -c myproc1.c myproc2.c<br>ar rcs mylib.a myproc1.o myproc2.o<br><br>gcc -c main.c<br>gcc -static -o myproc main.o ./mylib.a # 标准的静态库无需显示给出<br></code></pre></td></tr></table></figure><ul><li>在进行符号解析到过程中，按从左往右的顺序进行链接，并将符号分为三个集合：<ul><li>E：合并以组成可执行文件的所有目标文件集合；</li><li>U：当前所有未解析的引用符号；</li><li>D：当前所有定义的符号的集合，来更新U和E；</li></ul></li><li>符号解析的完整过程如下：<ol><li>扫描到main.o并加入E；</li><li>把main.o中未解析的引用myfunc加入U，把main加入D；</li><li>扫描到静态库文件mylib.a，将U中的符号与mylib.a中所有目标模块依次匹配，将myfunc从U中删除移到D，将myproc1.o加入E；</li><li>此时myproc1.o中发现未定义printf符号，将其加入到U；</li><li>不断扫描静态库文件，直至U、D不变；</li><li>扫描默认的库文件libc.a时，找到printf.o定义，将printf.o加入到E，并将printf从U移动到D，此时U一定是空的，否则就报错了；</li><li>由于未引用myproc2.o的内容，它并不在E中，被丢弃；<br><img src="./CSAPP%2013-linking/14.png" alt=""></li></ol></li><li>但是静态库链接的顺序扫描会导致一个问题：<img src="./CSAPP%2013-linking/15.png" alt=""></li><li>所以好的做法是<strong>将静态库放在命令行最后</strong>；</li><li><strong>如果静态库之间并不相互独立，静态库需要重复出现</strong>；<img src="./CSAPP%2013-linking/16.png" alt=""></li><li>静态库的缺陷：<ul><li>主存资源浪费；</li><li>磁盘空间浪费；</li><li>更新困难，使用不便；</li></ul></li></ul><h1>动态链接的共享库Shared Libraries</h1><ul><li>共享库是一个目标文件（Linux：.so文件；Windows：.dll文件）；</li><li>从程序中分离出来，磁盘和内存中都只有一个备份；</li><li>可以<strong>在程序运行或加载时，加载到内存的任意位置，并和一个内存中的程序链接起来，称为动态链接</strong>；<br><img src="./CSAPP%2013-linking/17.png" alt=""></li><li><code>ldd prog</code>可以打印出可执行文件需要的动态链接库；</li><li>自定义创建动态链接库：（<code>-fpic</code>是生成位置无关的共享库代码文件）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">unix&gt; </span><span class="language-bash">gcc -Og -c test1.c test2.c</span><br><span class="hljs-meta prompt_">unix&gt; </span><span class="language-bash">gcc -shared -fpic -o test.so \ test1.o test2.o</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">unix&gt; </span><span class="language-bash">gcc -c main.c</span><br><span class="hljs-meta prompt_">unix&gt; </span><span class="language-bash">gcc -o <span class="hljs-built_in">test</span> main.o ./test.so</span><br></code></pre></td></tr></table></figure><ul><li><strong>动态链接库在加载时的链接过程</strong>：<img src="./CSAPP%2013-linking/18.png" alt=""></li><li>在静态链接器ld链接的过程中，生成重定位和符号表信息；</li><li>加载可执行程序时，加载器发现在程序表中的 <strong>.interp 段</strong>，其中包含了动态链接器路径名 <a href="http://ld-linux.so">ld-linux.so</a>，因而加载器根据指定路径加载并启动动态链接器运行；</li><li>完成重定位后，将控制权交给可执行文件，开始执行程序；</li><li><strong>动态链接库在运行时的链接过程</strong>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><span class="hljs-comment">/* Dynamically load the shared library that contains addvec() */</span><br>handle = dlopen(<span class="hljs-string">&quot;./libvector.so&quot;</span>, RTLD_LAZY);<br><br><span class="hljs-comment">/* Get a pointer to the addvec() function we just loaded */</span><br>addvec = dlsym(handle, <span class="hljs-string">&quot;addvec&quot;</span>);<br><br><span class="hljs-comment">/* Now we can call addvec() just like any other function */</span><br>addvec(x, y, z, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">/* Unload the shared library */</span><br>dlclose(handle);<br></code></pre></td></tr></table></figure><p><img src="./CSAPP%2013-linking/19.png" alt=""></p><ul><li>上述过程也被称为<strong>Lazy Binding (延迟绑定)</strong>，它将函数地址的绑定推迟到<strong>函数第一次被调用时</strong>，而不是在程序加载到内存时立即完成所有函数地址的绑定；</li><li>延迟绑定依赖两种关键的数据结构：<strong>GOT（全局偏移表）</strong> 和 <strong>PLT（过程链接表）</strong>；</li><li>GOT：<ul><li>它是一个包含地址的表，存放在程序的数据段中（.data 或 .bss）。</li><li>每个引用的全局对象（包括全局变量和动态链接函数）在 GOT 中占据一个条目（8 字节）。</li><li>每个目标模块（目标文件或共享库）都会有自己的独立 GOT。</li><li>在程序加载时，动态链接器计算全局变量或函数的绝对地址。将每个 GOT 条目更新为对应全局对象的<strong>绝对地址</strong>。</li></ul></li><li>PLT：<ul><li><strong>PLT 是一段可执行代码</strong>，用来间接调用动态链接的函数。</li><li>每个动态链接的函数在 PLT 中都有一个对应的条目，<strong>每个条目大小为 16 字节</strong>。</li><li>在程序中，<strong>所有对动态函数的调用都会先跳转到对应的 PLT 条目，而不是直接调用函数地址</strong>。</li><li>每个动态函数在 GOT 中都有一个对应的条目，初始状态下，该条目指向动态链接器的解析代码。</li><li><strong>当动态链接器解析了目标函数地址后，会更新对应的 GOT 条目为函数的实际地址</strong>。</li><li><strong>第一次调用函数</strong>：<ul><li>PLT 条目先访问 GOT，发现 GOT 中的地址是动态链接器的入口。</li><li>动态链接器解析函数的实际地址，并更新 GOT 条目。</li></ul></li><li><strong>后续调用函数</strong>：<ul><li>PLT 条目直接跳转到 GOT 条目中存储的函数地址，避免重复解析。<br><img src="./CSAPP%2013-linking/20.png" alt=""></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 09-machine-advanced</title>
    <link href="/2025/01/05/CSAPP%2009-machine-advanced/"/>
    <url>/2025/01/05/CSAPP%2009-machine-advanced/</url>
    
    <content type="html"><![CDATA[<h1>程序运行的内存分配策略</h1><ol><li>静态存储分配<ol><li>编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间；</li><li>程序代码中<strong>不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现</strong>,因为会导致编译程序无法计算准确的存储空间需求</li></ol></li><li>栈式存储分配<ol><li>在编译期间，过程、函数以及嵌套程序块的活动记录大小（最大值）应该是可以确定的（以便进入的时候动态地分配活动记录的空间），这是进行栈式存储分配的必要条件，如果不满足则应该使用堆式存储管理</li></ol></li><li>堆式存储分配<ol><li><strong>数据对象的生存期与创建它的过程/函数的执行期无关</strong></li><li>在任意时刻以任意次序从数据段的堆区分配和释放数据对象的运行时存储空间，分配和释放数据对象的操作是应用程序通过向操作系统提出申请来实现<br><img src="./CSAPP%2009-machine-advanced/1.png" alt=""></li></ol></li></ol><h1>缓冲区溢出攻击</h1><ul><li>一个例子<img src="./CSAPP%2009-machine-advanced/2.png" alt=""></li><li>应对之道：<ul><li>Stack Randomization，栈随机化，栈底指针浮动；</li><li>设置金丝雀Canary；</li><li>栈区域规定是不可执行的</li></ul></li></ul><h1>金丝雀</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">40072f:  <span class="hljs-keyword">sub</span>    <span class="hljs-number">$0</span>x18,%rsp    # 分配栈空间24bytes<br><span class="hljs-number">400733</span>:  <span class="hljs-keyword">mov</span>    %fs:<span class="hljs-number">0x28</span>,%rax   # Get Canary %fs:<span class="hljs-number">0x28</span>是一个只读的内存区域<br>40073c:  <span class="hljs-keyword">mov</span>    %rax,<span class="hljs-number">0x8</span>(%rsp)  # Place it on stack(Canary 8byetes)<br><span class="hljs-number">400741</span>:  <span class="hljs-keyword">xor</span>    %eax,%eax  # 自己和自己做异或，即擦除Canary<br><span class="hljs-number">400743</span>:  <span class="hljs-keyword">mov</span>    %rsp,%rdi<br><span class="hljs-number">400746</span>:  callq  4006e0 &lt;gets&gt;<br>40074b:  <span class="hljs-keyword">mov</span>    %rsp,%rdi<br>40074e:  callq  <span class="hljs-number">400570</span> &lt;puts@plt&gt;<br><span class="hljs-number">400753</span>:  <span class="hljs-keyword">mov</span>    <span class="hljs-number">0x8</span>(%rsp),%rax  # Get it again from stack<br><span class="hljs-number">400758</span>:  <span class="hljs-keyword">xor</span>    %fs:<span class="hljs-number">0x28</span>,%rax   # 重新和只读区域上的值做异或<br><span class="hljs-number">400761</span>:  <span class="hljs-keyword">je</span>     <span class="hljs-number">400768</span> &lt;echo+<span class="hljs-number">0x39</span>&gt; # ZF = <span class="hljs-number">0</span>，即说明两者相等，没问题<br><span class="hljs-number">400763</span>:  callq  <span class="hljs-number">400580</span> &lt;__stack_chk_fail@plt&gt; # 否则说明stack上的Canary被顶掉，Fail<br><span class="hljs-number">400768</span>:  <span class="hljs-keyword">add</span>    <span class="hljs-number">$0</span>x18,%rsp<br>40076c:  retq<br></code></pre></td></tr></table></figure><h1>面向返回攻击Return-Oriented Programming Attacks</h1><ul><li>利用已有的代码Gadget，跳转到Gadgets上逐步执行操作；</li><li>还是防不了金丝雀；<br><img src="./CSAPP%2009-machine-advanced/3.png" alt=""></li></ul>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 08-machine-data</title>
    <link href="/2025/01/05/CSAPP%2008-machine-data/"/>
    <url>/2025/01/05/CSAPP%2008-machine-data/</url>
    
    <content type="html"><![CDATA[<h1>Array数组</h1><ul><li><code>Type A[L]</code>会在内存中分配连续的$L * sizeof(Type)$个字节；</li><li>其中单独的<code>A</code>表示数组指针；$A + i$事实上是$A + i * sizeof(Type)$的地址；<img src="./CSAPP%2008-machine-data/1.png" alt=""></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">get_digit</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">return</span> a[x];<br>&#125;<br><br><span class="hljs-comment">// 翻译成汇编代码</span><br><span class="hljs-comment">// %rdi = a, %rsi = x;</span><br>movl (%rdi, %rsi, <span class="hljs-number">4</span>), %eax; <span class="hljs-comment">// a + 4 * x;</span><br></code></pre></td></tr></table></figure><ul><li>数组可以视为首项的指针，对于两者混用的情况，做出以下区分：</li></ul><table><thead><tr><th>Decl</th><th style="text-align:left"></th><th style="text-align:left">A1, A2</th><th style="text-align:left"></th><th></th><th>*A1, *A2</th><th></th></tr></thead><tbody><tr><td></td><td style="text-align:left">Cmp</td><td style="text-align:left">Bad</td><td style="text-align:left">Size</td><td>Comp</td><td>Bad</td><td>Size</td></tr><tr><td>int A1[3]</td><td style="text-align:left">Y</td><td style="text-align:left">N</td><td style="text-align:left">12</td><td>Y</td><td>N</td><td>4</td></tr><tr><td>int *A2</td><td style="text-align:left">Y</td><td style="text-align:left">N</td><td style="text-align:left">8</td><td>Y</td><td>Y</td><td>4</td></tr></tbody></table><ul><li>其中<code>int *A2</code>声明了一个指向整形的指针，但它指向的地址显然没有被指定，即指向一个未被分配的内存空间，是一个坏指针；<img src="./CSAPP%2008-machine-data/2.png" alt=""></li></ul><table><thead><tr><th>Decl</th><th></th><th>An</th><th></th><th></th><th>*An</th><th></th><th></th><th>**An</th><th></th></tr></thead><tbody><tr><td></td><td>Cmp</td><td>Bad</td><td>Size</td><td>Cmp</td><td>Bad</td><td>Size</td><td>Cmp</td><td>Bad</td><td>Size</td></tr><tr><td>int A1[3]</td><td>Y</td><td>N</td><td>12</td><td>Y</td><td>N</td><td>4</td><td>N</td><td>-</td><td>-</td></tr><tr><td>int *A2[3]</td><td>Y</td><td>N</td><td>24</td><td>Y</td><td>N</td><td>8</td><td>Y</td><td>Y</td><td>4</td></tr><tr><td>int (*A3)[3]</td><td>Y</td><td>N</td><td>8</td><td>Y</td><td>Y</td><td>12</td><td>Y</td><td>Y</td><td>4</td></tr><tr><td>int (*A4[3])</td><td>Y</td><td>N</td><td>24</td><td>Y</td><td>N</td><td>8</td><td>Y</td><td>Y</td><td>4</td></tr></tbody></table><ul><li>其中<code>int *A2[3]</code>相当于<code>int (*A4[3])</code>，其中，<code>()</code>的优先级最高，<code>[]</code>次之，然后是<code>*</code>；</li><li><code>int *A2[3]</code>表示包含3个整形指针的数组；方括号<code>[]</code>的优先级高于<code>*</code>，所以<code>A2[3]</code>表示A2是一个数组；<code>int *</code>表示数组的每个元素是一个指向int类型的指针。</li><li><code>int (*A3)[3]</code>表示指向一个包含3个整形的数组的指针；<code>()</code>的优先级高于<code>[]</code>，所以 <code>(\*A3)</code>表示<code>A3</code>是一个指针。<img src="./CSAPP%2008-machine-data/3.png" alt=""></li><li>二维数组按行优先存储；<img src="./CSAPP%2008-machine-data/4.png" alt=""></li><li>要访问<code>A[i][j]</code>，取<code>A + (i * C + j) * 4</code>即可；</li></ul><h1>Structure自定义结构体</h1><ul><li>结构体也是一段连续的内存区域；<img src="./CSAPP%2008-machine-data/5.png" alt=""></li><li>结构体的某个类型对象的<strong>地址必须是k = 2, 4, 8的倍数（对齐）</strong>；原因是：<ul><li><strong>内存访问的单位是块</strong>：<ul><li>在现代计算机中，内存通常是以<strong>固定大小的块</strong>（如 4 字节或 8 字节，依赖于系统架构）进行访问的。</li><li>这种对齐方式是硬件设计的结果，因为大多数处理器一次性加载的数据是 4 字节（32 位）或 8 字节（64 位），以提高性能。</li></ul></li><li><strong>缓存行（Cache Line）的作用</strong>：<ul><li>缓存行是 CPU 缓存与内存之间传输数据的最小单位，典型大小为 <strong>64 字节</strong>。</li><li>当 CPU 访问内存时，会将整块缓存行加载到缓存中，以减少后续访问的延迟。</li></ul></li><li><strong>跨缓存行访问的影响</strong>：如果一个数据（如一个结构体或数组元素）跨越了两个缓存行：<ol><li>CPU 需要加载两个缓存行（额外的内存访问）。</li><li>性能下降，因为需要两次读取操作。</li></ol></li><li><strong>对齐的意义</strong>：<ul><li>数据对齐可以避免跨缓存行的情况，确保数据操作只涉及单个缓存行，从而提高访问效率。</li></ul></li><li><strong>虚拟内存的分页（Page）机制</strong>：现代操作系统的虚拟内存将内存划分为 <strong>页（Page）</strong>，每页通常是 4 KB。<ul><li>页是内存管理的最小单位，每一页可能映射到不同的物理内存区域，或者部分未分配。</li><li><strong>跨页访问的复杂性</strong>：如果一个数据块（如数组或结构体）跨越了两个页：<ol><li>操作系统需要处理两次页表查找，性能下降。</li><li>如果某一页未映射（如缺页错误），会导致额外的开销。</li><li>在某些极端情况下（如页权限不同），可能会引发访问冲突或安全问题。</li></ol></li><li><strong>对齐的重要性</strong>：</li><li>避免数据跨页存储可以减少页表查找和缺页错误，简化虚拟内存管理，提高内存操作效率。</li></ul></li></ul></li><li>所以，倾向于将占字节数大的对象放在前面减小空间浪费；</li></ul><h1>浮点代码</h1><ul><li>不在教学和考试范围内；</li></ul><h1>Union共用体</h1><ul><li>根据最大的类型对象所占字节数分配内存；</li><li>一次只能使用一个对象；<br><img src="./CSAPP%2008-machine-data/6.png" alt=""></li></ul><ol><li>Same as (float) u?<ul><li>不相同：<ul><li><code>(float) u</code>的含义：<ul><li>这是一个类型转换，表示将 unsigned 类型的整数 u 转换为 float 类型。</li><li>转换时，u 的数值会从整数解释为浮点数，改变其表示方式。例如，u = 42 会被转换为浮点数 42.0。</li></ul></li><li><code>bit2float</code>的含义：<ul><li>bit2float 并不改变位模式，而是通过 union 将 unsigned 类型的位模式解释为 float 类型。</li><li>如果传入的 u 并不是有效的浮点数位模式，结果可能是未定义的浮点数。</li></ul></li></ul></li></ul></li><li>Same as (unsigned) f？<ul><li>同理，不相同；</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>汇编代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 07-machine-procedures</title>
    <link href="/2025/01/04/CSAPP%2007-machine-procedures/"/>
    <url>/2025/01/04/CSAPP%2007-machine-procedures/</url>
    
    <content type="html"><![CDATA[<h1>进程机制</h1><ol><li>Passing control传递控制，记录函数返回地址，跳转到函数开始地址；</li><li>Passing data传递参数；</li><li>Memory management内存管理；</li></ol><h1>运行时的栈和栈帧</h1><ul><li>习惯性将栈顶画在底部，从下到上地址增大，栈向低地址生长，即向下生长；</li><li><code>pushq Src</code>，会使得<code>%rsp</code>减小；<code>popq Dest</code>，会使得<code>%rsp</code>增加；</li><li>不会改变具体栈上的内容，只会改变指针的位置；</li><li><code>callq label</code>：<ul><li>push return address to stack；</li><li>jump to label；</li><li>即将栈向下生长一格，将函数返回地址放入，<code>%rsp</code>存的是指向该返回地址的指针；然后<code>%rip</code>变为函数的开始地址；</li></ul></li><li><code>ret</code>：<ul><li>pop address from stack；</li><li>jump to address(即将PC<code>%rip</code>设置为该地址)；</li><li>此时过程内的一切东西都会被释放（除了动态申请的内存）；</li></ul></li><li>label是不占位置的；<br><img src="./CSAPP%2007-machine-procedures/1.png" alt=""><br><img src="./CSAPP%2007-machine-procedures/2.png" alt=""></li><li><strong>Stack Frames栈帧</strong>：即过程活动记录，每次调用函数分配的一段独立的栈帧，<code>ret</code>时释放栈帧；</li><li>一个常见的调用过程的栈内容如下：（向下生长，往下为低地址）</li></ul><table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr><tr><td>Arg n</td></tr><tr><td>$\cdots$</td></tr><tr><td>Arg 7</td></tr><tr><td>Return Addr(Caller’s %rip)以上部分均为Caller的栈帧</td></tr><tr><td>optional Callee’s %rbp</td></tr><tr><td>Saved Registers + Local Varibles</td></tr><tr><td>Arg Build(optional)，如果该函数内部还要调用其他函数，需要传递的参数在这里进行准备；以上部分为Callee的栈帧</td></tr></tbody></table><h1>数据传送与局部存储</h1><ul><li>以下讨论均为整形，浮点数有另一套东西；</li><li>当传递参数超过6个时，x86-64要求<strong>超过寄存器限制的参数按照从右到左的顺序压入栈（后面的参数先进入栈）</strong>：<img src="./CSAPP%2007-machine-procedures/3.png" alt=""></li><li>由于寄存器在所有进程之间进行共享，所以规定Callee被调用者不会覆盖Caller调用者会使用到的寄存器的值：<ul><li>Caller Saved调用者保存：<strong>调用者（Caller）负责保存</strong>在函数调用前需要保留的寄存器值，如果调用者需要在函数调用后继续使用某些寄存器中的值，那么它必须在调用函数之前将这些值保存到栈中或其他地方，并在函数返回后再恢复；<ul><li>通过上述操作，Callee可以在调用过程中使用和改变这些寄存器的值；</li><li>典型的有：<code>%r10，%r11，%rax，%rdi，%rsi，%rdx，%rcx，%r8，%r9</code>，即参数基本器和返回寄存器，调用者需要对自己负责，调用子函数时肯定需要确保这些值不能被被调用者改变；</li></ul></li><li>Callee Saved被调用者保存：<strong>被调用者（Callee）负责保存</strong>在函数调用中需要保护的寄存器值，通常通过压栈来进行（就是上面画的Callee的栈帧中Saved Registers的部分）；<ul><li>典型的有：<code>%rbx，%rbp，%r12，%r13，%r14，%r15</code>，<strong>比较特殊的是<code>%rsp</code>，因为调用子函数时，栈指针会往下移至子函数栈帧的栈顶，当子函数结束时，显然需要子函数来恢复栈顶指针指向调用者栈帧的栈顶</strong>；</li></ul></li></ul></li><li>一个Callee Saved的例子<img src="./CSAPP%2007-machine-procedures/5.png" alt=""><ul><li>首先，<code>%rdi</code>作用Caller Saved，需要由该函数保存，由于<code>%rbx</code>为Callee Saved，即被调用者保存，其值在该函数运行过程中不会发生改变，所以将<code>%rdi</code>保存在<code>%rbx</code>中，通过寄存器实现了保存；</li><li>上述操作导致了一个问题，<code>%rbx</code>作为Callee Saved，而该函数作为其上一层（主函数）的被调用者，该函数作为被调用者需要保存<code>%rbx</code>，所以，该函数一开头将<code>%rbx</code>压入栈，再最后又弹回给<code>%rbx</code>，通过在栈上存储，实现了保存；</li></ul></li><li>再看一个递归的例子<img src="./CSAPP%2007-machine-procedures/6.png" alt=""><ul><li>在该函数中递归调用时，作为主调函数，需要保存<code>%rdi</code>，与上面的例子类似保存在<code>%rbx</code>中；</li><li>由于<code>%rbx</code>是Callee Saved，pcouter_r作为主函数和上一层pcounter_r的被调用者，所以也需要保存<code>%rbx</code>；</li></ul></li></ul><h1>一个函数调用的例子</h1><p><img src="CSAPP%2007-machine-procedures/4.png" alt=""></p><ol><li>栈操作不是运用传统的push和pop操作，直接移动指针，两者含义是否相同？<ul><li><strong>功能上相同</strong>：两种方式都用于管理栈上的数据；</li><li><strong>实现上不同</strong>：直接调整<code>%rsp</code>更高效，尤其在需要分配大块连续内存时；而 <code>push/pop</code>更适合操作单个寄存器或简单的栈保存和恢复；</li></ul></li><li>为何多申请了一个8字节空间？<ul><li>System V ABI 规范了函数调用时的堆栈布局，以确保各函数之间的参数传递和返回地址的存储符合标准。<strong>堆栈以 16 字节对齐的方式操作</strong>，从而在调用指令（如<code>CALL</code>和<code>RET</code>）时避免对齐问题；</li></ul></li><li>何时申请栈中局部空间，何时不需要申请？<ol><li><strong>需要申请局部空间的情况：</strong><ol><li><strong>局部变量无法存放在寄存器中</strong>：如果局部变量的数量超过了可用的寄存器，或者局部变量较大（如数组、结构体），必须在栈中分配空间。</li><li><strong>指针操作需要实际内存地址</strong>：如代码中的 &amp;v1 需要将变量地址传递给函数，此时必须为变量分配实际的内存空间。</li><li><strong>函数递归或多层嵌套调用</strong>：每次调用会分配独立的栈帧用于保存局部变量和状态。</li></ol></li><li><strong>不需要申请局部空间的情况：</strong><ol><li><strong>变量可以完全存储在寄存器中</strong>：编译器优化时，会尽可能将局部变量映射到寄存器中，避免占用栈空间。</li><li><strong>无需持久化变量状态</strong>：如果局部变量只在寄存器中临时使用且不需要在函数调用间共享，则不需要分配栈空间。</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>汇编代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 06-machine-control</title>
    <link href="/2025/01/04/CSAPP%2006-machine-control/"/>
    <url>/2025/01/04/CSAPP%2006-machine-control/</url>
    
    <content type="html"><![CDATA[<h1>条件码</h1><p><img src="./CSAPP%2006-machine-control/1.png" alt=""><br><img src="./CSAPP%2006-machine-control/2.png" alt=""><br><img src="./CSAPP%2006-machine-control/3.png" alt=""><br><img src="./CSAPP%2006-machine-control/4.png" alt=""></p><ul><li><strong>注意<code>cmp</code>实际上做减运算，后减前</strong>；</li></ul><h1>Loop循环结构</h1><ol><li>do-while：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123;<br>body;<br>&#125; <span class="hljs-keyword">while</span>(test);<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Loop:<br>body;<br>t = test;<br><span class="hljs-keyword">if</span> (t) <span class="hljs-keyword">goto</span> Loop;<br></code></pre></td></tr></table></figure><ol start="2"><li>while：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (test) &#123;<br>body;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果开启-O2优化，采用Jump-to-middle翻译方法，即判断在后面，先跳到末尾进行判断，再返回中间执行整体；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">goto</span> test;<br>Loop:<br>body;<br><br>test:<br>t = test;<br><span class="hljs-keyword">if</span> (t) <span class="hljs-keyword">goto</span> Loop;<br></code></pre></td></tr></table></figure><p>如果开启-O1优化，采用Guarded-do翻译方法，先进行判断，然后转换为do-while循环；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">t = test;<br><span class="hljs-keyword">if</span> (!t) <span class="hljs-keyword">goto</span> END;<br>Loop:<br>body;<br>t = test;<br><span class="hljs-keyword">if</span> (t) <span class="hljs-keyword">goto</span> Loop:<br>END;<br></code></pre></td></tr></table></figure><ol start="3"><li>for：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (init; test; update) &#123;<br>body;<br>&#125;<br></code></pre></td></tr></table></figure><p>转化为while循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">init;<br><span class="hljs-keyword">while</span> (test) &#123;<br>body;<br>update;<br>&#125;<br></code></pre></td></tr></table></figure><p>写成goto形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">init;<br>t = test;<br>Loop:<br>body;<br>update;<br><span class="hljs-keyword">if</span> (t) <span class="hljs-keyword">goto</span> Loop;<br>END;<br></code></pre></td></tr></table></figure><h1>Switch分支结构</h1><ul><li>并非if，通过跳转表来实现，每一个分支被视为一个代码块，代码块的开头的地址被存放在跳转表中；<img src="./CSAPP%2006-machine-control/5.png" alt=""></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">my_switch:</span><br><span class="hljs-keyword">movq</span> %rax, %rcx<br>cmpq <span class="hljs-number">$6</span>, %rdi // x : <span class="hljs-number">6</span><br><span class="hljs-keyword">ja</span> .L8 // if x &gt; <span class="hljs-number">6</span>, goto <span class="hljs-meta">default</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">jmp</span> *.L4(,%rdi, <span class="hljs-number">8</span>) // *(.L4 + x * <span class="hljs-number">8</span>)的地址上的值，即间接跳转，先计算出跳转表上的索引位置，跳转到该索引上的值处；<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>汇编代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 05-machine-basics</title>
    <link href="/2025/01/04/CSAPP%2005-machine-basics/"/>
    <url>/2025/01/04/CSAPP%2005-machine-basics/</url>
    
    <content type="html"><![CDATA[<h1>指令的概念</h1><ul><li>微指令是微程序级命令，属于硬件范畴</li><li>伪指令是由若干机器指令组成的指令序列，属于软件范畴</li><li>机器指令介于二者之间，处于硬件和软件的交界面，本章中提及的指令都指机器指令；<ul><li>汇编指令是机器指令的汇编表示形式，即符号表示</li><li>机器指令（二进制串）和汇编指令一一对应，它们都与具体机器结构有关，都属于机器级指令；</li><li>编译Compiling：<code>gcc -Og -S test.c</code>，<code>-Og</code>为优化选项，得到汇编代码<code>test.s</code>；</li></ul></li></ul><h1>机器代码的组成</h1><ul><li>操作性质（操作码）、源操作数、目的操作数地址（立即数，寄存器编号，存储地址）；<br><img src="CSAPP%2005-machine-basics/1.png" alt=""></li><li>通常由以下三部分组成：<ul><li>程序计数器PC(Program Counter)：即<code>%rip</code>(x86-64)，指向当前正在执行指令的下一条指令的地址；</li><li>整数寄存器Register file：分别存储了64位的值（地址，整数数据）；</li><li>状态寄存器Condition codes：最近执行的算术或逻辑指令的状态信息；</li></ul></li><li>注意机器代码不区分无符号整数和有符号整数，不区分函数和指针；</li></ul><h1>ISA指令集体系结构</h1><p><img src="CSAPP%2005-machine-basics/2.png" alt=""></p><h1>信息访问（保护模式下）</h1><ol><li>整数寄存器：<img src="CSAPP%2005-machine-basics/3.png" alt=""><ol><li><code>%rax</code>，函数返回值；</li><li><code>%rdi</code>，函数调用的第一个参数；</li><li><code>%rsi</code>，函数调用的第二个参数；</li><li><code>%rdx</code>，函数调用的第三个参数；</li><li><code>%rcx</code>，函数调用的第四个参数；</li><li><code>%r8</code>，函数调用的第五个参数；</li><li><code>%r9</code>，函数调用的第六个参数（超过6个参数放在栈空间中）；</li><li><code>%rsp</code>，栈顶指针；</li></ol></li><li>操作数指示符号<ol><li>寄存器：直接调用即可；</li><li>立即数：<code>$ + 整数</code>表示；</li><li>内存引用：<code>(%rax)</code></li><li>基址、比例变址、位移操作：<code>D(Rb, Ri, S)</code>，表示获取Rb + S * Ri + D地址上的数，Rb为段基址，Ri为有效地址(不能是%rsp)，S为比例因子(1、2、4、8)，D为偏移量；<img src="CSAPP%2005-machine-basics/4.png" alt="">即算的时候是直接拿寄存器做运算得到地址，但最终的结果应该是该地址上的数；</li></ol></li><li>传送指令：<ol><li>mov：<code>movq src, dest</code>；<ol><li>立即数可以移动到寄存器或内存地址(寄存器的内容，即此时立即数存在内存中，寄存器存的是指向该内存的地址)；<ol><li><code>movq $0x4, %rax</code> $\Leftrightarrow$ <code>temp = 0x4</code>；</li><li><code>movq $-147, (%rax)</code>$\Leftrightarrow$ <code>*p = -147</code>；</li></ol></li><li>寄存器可以移动到寄存器或内存地址；</li><li>内存只能移动到寄存器，内存之间不能移动；</li><li><code>movl</code>指令以寄存器为目的是，不但会更新低32位的值，还会将高位4字节都设置为0；</li><li><code>movs</code>符号扩展；<code>movz</code>零扩展；</li></ol></li><li>lea：加载有效地址，<code>leaq (%rdi, %rdi, 2), %rax</code>；<ol><li><strong>注意与<code>mov</code>区别，<code>lea</code>虽然加了括号，但实际上取的是内存的地址，且结果也是内存的地址，而非地址的指向</strong>，所以上面那句指令等价于<code>t = x + x * 2</code>；</li></ol></li></ol></li><li>二元运算指令：<img src="CSAPP%2005-machine-basics/5.png" alt=""><ul><li>注意<code>sarq</code>为算术右移，<code>shrq</code>为逻辑右移；</li><li><strong>除了乘除，都不区分有符号和无符号</strong>；</li><li><strong>加减影响所有标志</strong>；</li><li><strong>递增递减影响除进位借位CF以外的标志</strong>；</li><li><strong>取负NEG影响标志：对0取负得到0，CF = 0；其余情况CF = 1</strong>；</li><li><strong>比较运算：做减法得到标志，不会改变寄存器的值</strong>；</li></ul></li><li>一元运算指令：<img src="CSAPP%2005-machine-basics/6.png" alt=""><ul><li>逻辑运算中，<code>not</code>不会影响标志，其余OF = CF = 0，ZF和SF根据结果设置；</li><li><strong><code>test</code>做“与”操作，但不会改变寄存器的值，仅影响标志位</strong>；</li></ul></li></ol><h1>GCC的使用举例</h1><ol><li><code>gcc -Og -S test.c</code>得到汇编代码<code>test.s</code>；</li><li><code>gcc -O1 test.c -o test</code>得到可执行文件<code>test</code>；</li><li><code>objdump -d test.o &gt; test.txt</code>得到反汇编代码；</li><li>注意可重定位目标文件和可执行目标文件的差异，可重定位目标文件还没有经过链接器链接：<img src="CSAPP%2005-machine-basics/7.png" alt=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>汇编代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 04-float</title>
    <link href="/2025/01/04/CSAPP%2004-float/"/>
    <url>/2025/01/04/CSAPP%2004-float/</url>
    
    <content type="html"><![CDATA[<h1>二进制表示方法</h1><ul><li>引入负指数即可；</li><li>缺陷是无法平衡整数部分的范围和小数范围的精度；</li></ul><h1>IEEE标准</h1><p><img src="./CSAPP%2004-float/2.png" alt=""><br><img src="./CSAPP%2004-float/1.png" alt=""></p><ul><li>exp：阶码；</li><li>frac：尾数；</li></ul><ol><li>规格化Normalized：exp不全为0且不全为1；<ol><li>$E = exp - Bias = exp - (2^{k-1} - 1),Bias  = 2^{k - 1} - 1$ ；<ol><li>32bits：$Bias = 2^7 -1 = 127,exp\in [1,254]\rightarrow E\in [-126,127]$；</li><li>64bits：$Bias = 2^{10} - 1 = 1023,exp \in [1, 2023]\rightarrow E\in [-1022,1023]$；</li></ol></li><li>$M = 1.frac_{(2)}$；</li></ol></li><li>非规格化Denormalized：exp全为0；<ol><li>$E = 1 - Bias$；</li><li>$M = frac$；</li></ol></li><li>特殊值Special Values：exp全为1；<ol><li>exp全为1，frac全为0，s = 0表示正无穷$+\infty$，s = 1表示负无穷$-\infty$；</li><li>exp全为1，frac不为0，表示NaN，不是一个数；<br><img src="./CSAPP%2004-float/3.png" alt=""></li></ol></li></ol><ul><li>分布特点：在0附近均匀分布，到外面扩大（指数分布）；</li><li>舍入规则：4舍6入5向偶；（不在考试范围内）；</li><li>类型转换：<ul><li>$double/float\rightarrow int$<ul><li>直接对实际存储的二进制串进行位截断；</li><li>体现为向0舍入；</li><li>超界的情况转化为$T_{min}$；</li></ul></li><li>$int \rightarrow float$<ul><li>位数相同，不会截断，但可能会发生舍入；</li></ul></li><li>$int/float \rightarrow double$<ul><li>double的有效位数更多，所以能保留精确度；</li></ul></li><li>$double \rightarrow float$<ul><li>能表达的范围变小，可能溢出为$\infty$，并且精度降低，可能发生舍入；</li></ul></li></ul></li></ul><p><img src="./CSAPP%2004-float/4.png" alt=""><br>解答：</p><ol><li>x如果很大，(float)x会发生舍入；</li><li>double表示范围大于int，所以能精确表示；</li><li>同理2；</li><li>(float)d会发生溢出或舍入；</li><li>没问题，-f或者-d就是符号位取反即可；</li></ol><ul><li>同时，注意浮点数加法运算不满足结合律；</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 02-Bits-ints-part2</title>
    <link href="/2025/01/04/CSAPP%2002-Bits-ints-part2/"/>
    <url>/2025/01/04/CSAPP%2002-Bits-ints-part2/</url>
    
    <content type="html"><![CDATA[<h1>Addition加法</h1><ol><li>无符号数加法：$s = UAdd_w(u,v) = (u +v)% 2^w$；结果寄存器会截断溢出的1位；<ol><li>溢出时，结果一定小于任何一个加数；</li></ol></li><li>有符号数加法：$s = (int)((unsigned)u + (unsigned)v)$；<ol><li>正溢出：$x + y \ge 2^{w-1}$，截断后结果为$x + y - 2^w$；</li><li>负溢出：$x + y &lt; 2^{w-1}$，截断后结果为$x + y + 2^w$；</li><li>正 + 负：不可能溢出；</li></ol></li><li>用加法实现减法：$(A - B)<em>{\text{补}} = (A)</em>\text{补} + (-B)_\text{补}$<ol><li>如何求$(-B)<em>\text{补}$<br>$(B)</em>\text{补} + (-B)<em>\text{补} = 11\cdots 1$<br>$\sim(B)</em>\text{补} + (B)<em>\text{补} + 1 = 11\cdots 1 + 1 = 0$<br>$(-B)</em>\text{补} = \sim (B)_\text{补} + 1$</li></ol></li><li>加法逆元：<ol><li>无符号数：$-x = 2^w - x(x \ne 0)$，0的逆元是0；</li><li>有符号数：$x + (-x) = 0$，注意特例$T_{min},10\cdots 0 + 10\cdots 0 = 0$，即$-T_{min} = T_{min}$；</li></ol></li></ol><h1>Adder加法器</h1><p><img src="CSAPP%2002-Bits-ints-part2/1.png" alt=""></p><ul><li>当做减法(Sub = 1)或产生进位(Co = 1)时，CF = 1，表示发生借位或进位；</li><li>SF = 运算结果的符号位；</li><li>ZF = 1 if Sum = 0；</li><li>OF = 1 if 两个加数同号但与Sum异号(即上述发生溢出的情形)；<br><img src="CSAPP%2002-Bits-ints-part2/2.png" alt=""><br>以上题为例：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> x = <span class="hljs-number">1000</span> <span class="hljs-number">0110</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y = <span class="hljs-number">1111</span> <span class="hljs-number">0110</span>; <span class="hljs-comment">// -y_补 = 00001010</span><br><br><span class="hljs-type">int</span> m = x = <span class="hljs-number">1000</span> <span class="hljs-number">0110</span> = <span class="hljs-number">-122</span>;<br><span class="hljs-type">int</span> n = y = <span class="hljs-number">1111</span> <span class="hljs-number">0110</span> = <span class="hljs-number">-10</span>;<br><br># CF = <span class="hljs-number">1</span>(减法有借位)，OF = <span class="hljs-number">0</span>(并没有溢出），SF = <span class="hljs-number">1</span>；<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> z1 = x - y = <span class="hljs-number">1000</span> <span class="hljs-number">0110</span> + <span class="hljs-number">00001010</span> = <span class="hljs-number">10010000</span> = <span class="hljs-number">144</span>;<br><span class="hljs-type">int</span> k1 = m - n = <span class="hljs-number">10010000</span> = <span class="hljs-number">-112</span> = <span class="hljs-number">-112</span> - (<span class="hljs-number">-10</span>);<br><br># CF = <span class="hljs-number">1</span>(有进位)，OF = <span class="hljs-number">1</span>(发生溢出)，SF = <span class="hljs-number">0</span>；<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> z2 = x + y = <span class="hljs-number">1000</span> <span class="hljs-number">0110</span> + <span class="hljs-number">11110110</span> = <span class="hljs-number">01111100</span> = <span class="hljs-number">124</span> = (<span class="hljs-number">134</span> + <span class="hljs-number">246</span>) % <span class="hljs-number">256</span>;<br><span class="hljs-type">int</span> k2 = m + n = <span class="hljs-number">01111100</span> = <span class="hljs-number">124</span> = <span class="hljs-number">-122</span> - <span class="hljs-number">10</span> + <span class="hljs-number">256</span>;<br></code></pre></td></tr></table></figure><h1>Multiplication</h1><ol><li>无符号数乘法：和加法类似进行截断；</li><li>补码乘法：先按无符号数进行乘法运算截断，然后将结果转化为有符号数；</li><li>变量与常数之间的乘运算（左移）：<img src="CSAPP%2002-Bits-ints-part2/3.png" alt=""></li><li>变量与常数之间的除运算（算术右移）：<img src="CSAPP%2002-Bits-ints-part2/4.png" alt=""></li><li>如果负数要向0取整，记得加偏移量；即：$x = (x + 1&lt;&lt;k-1)&gt;&gt;k$；</li></ol>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 02-Bits-ints-part1</title>
    <link href="/2025/01/04/CSAPP%2002-Bits-ints-part1/"/>
    <url>/2025/01/04/CSAPP%2002-Bits-ints-part1/</url>
    
    <content type="html"><![CDATA[<h1>Word Size 字长</h1><ul><li>32位(bits)机器，字长为4Bytes(32/8)，寻址空间为$2^{32} = 4 * 2^{30} = 4GB$；</li><li>内存中的管理方式如下，32位的机器最小连续字间隔4Byte，64位的机器最小连续字间隔8Byte，字节Byte是最基本存储单元；<img src="./CSAPP%2002-Bits-ints-part1/1.png" alt=""></li></ul><h1>数据表示</h1><ul><li>int可以跨平台兼容，long和pointer一样：<br><img src="./CSAPP%2002-Bits-ints-part1/2.png" alt=""></li></ul><h1>数据的存储排列</h1><p><img src="./CSAPP%2002-Bits-ints-part1/8.png" alt=""><br>解答：0x08000100；</p><h1>字的存放问题</h1><ul><li>大端法（高对低，最低有效字节在高低址）；</li><li>小端法（低对低，最低有效字节在最前（低地址））</li><li>以<code>int x = 0x01234567, &amp;x = 0x100</code>为例：</li></ul><table><thead><tr><th>Address</th><th>0x100</th><th>0x101</th><th>0x102</th><th>0x103</th></tr></thead><tbody><tr><td>Big Endian</td><td>01</td><td>23</td><td>45</td><td>67</td></tr><tr><td>Little Endian</td><td>67</td><td>45</td><td>23</td><td>01</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *pointer;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_bytes</span><span class="hljs-params">(pointer start, <span class="hljs-type">size_t</span> len)</span>&#123; <span class="hljs-comment">// 从数据的指针开始打印数据，即从低地址开始打印</span><br>    <span class="hljs-type">size_t</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\t0x%.2x\n&quot;</span>,start+i, start[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">15213</span>; <span class="hljs-comment">// 15213 = 00 00 3b 6d;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int a = 15213;\n&quot;</span>);<br>    show_bytes((pointer) &amp;a, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <br>    <span class="hljs-type">int</span> b = <span class="hljs-number">-15213</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int b = -15213;\n&quot;</span>);<br>    show_bytes((pointer) &amp;b, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <br>    <span class="hljs-type">char</span> s[<span class="hljs-number">6</span>] = <span class="hljs-string">&quot;18213&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;string s = \&quot;18213\&quot;\n&quot;</span>);<br>    show_bytes((pointer) &amp;s, <span class="hljs-keyword">sizeof</span>(s));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意对于字符数组，存储时每个字符按照小端法存储，所以表现出来的结果是整个字符串小端法和大端法没有区别；</li></ul><h1>字的边界对齐问题</h1><ul><li>按边界对齐：（以32位机器为例，按字节编址，4个字节同时读写）<ul><li>字地址：4的倍数；</li><li>半字地址：2的倍数；</li><li>字节地址：任意；</li></ul></li><li>浪费了一些空间，但减少了访存次数；<br><img src="./CSAPP%2002-Bits-ints-part1/3.png" alt=""></li></ul><h1>运算</h1><h2 id="布尔运算">布尔运算</h2><ul><li>按位与，按位取反；</li><li>$\sim 0x41(01000001) \rightarrow 10111110 = 0xBE$；</li><li>$\sim 0x00\rightarrow 0xFF$；</li><li>$0x69 &amp; 0x55 \rightarrow 01101001 &amp; 01010101 = 01000001$</li></ul><h2 id="逻辑运算">逻辑运算</h2><ul><li><code>||, &amp;&amp;, !</code>，注意与布尔运算区别，运算的结果只有0或1（运算结果只要不为0false，就是1true）；</li></ul><h2 id="移位运算">移位运算</h2><ul><li>只需注意算术右移左边填充符号位即可；</li></ul><h1>无符号数和有符号数的位级表示</h1><ul><li>运算时，有符号数优先转化为无符号数；</li></ul><table><thead><tr><th>关系表达式</th><th>运算类型</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td>$0 == 0U$</td><td>unsigned</td><td>True</td><td></td></tr><tr><td>$-1 &lt; 0$</td><td>signed</td><td>True</td><td></td></tr><tr><td>$-1 &lt; 0U$</td><td>unsigned</td><td>False</td><td>$-1 = 1\cdots 1_2 = U_{max} &gt; 0$</td></tr><tr><td>$2147483647(2^{31} - 1) &gt; -2147483637 - 1$</td><td>signed</td><td>True</td><td></td></tr><tr><td>$2147483647U &gt; -2147483637 - 1$</td><td>unsigned</td><td>False</td><td>$-2147483637 - 1 = T_{min} \rightarrow 1\cdots 0U = 2^{31} &gt; 2^{31} - 1$</td></tr><tr><td>$2147483647 &gt; (int)2147483648U$</td><td>signed</td><td>True</td><td>$(int)2147483648U = 1\cdots 0 = -2^{31}$</td></tr><tr><td>$-1 &gt; -2$</td><td>signed</td><td>True</td><td></td></tr><tr><td>$(unsigned)-1 &gt; -2$</td><td>unsigned</td><td>True</td><td>$(unsigned)-1 = U_{max}$</td></tr></tbody></table><ul><li>数据类型只决定读取方式，不改变存储方式(01串)；</li><li>一些另外的注意点：<img src="./CSAPP%2002-Bits-ints-part1/4.png" alt=""><code>sizeof()</code>返回的类型为unsigned int，所以以下代码会导致死循环：<img src="./CSAPP%2002-Bits-ints-part1/5.png" alt=""></li></ul><h1>位扩展和位截断</h1><h2 id="Sign-Extension">Sign Extension</h2><ul><li>根据最高位决定补0或者补1；</li></ul><h2 id="Sign-Truncation">Sign Truncation</h2><ul><li>无符号数截断$B2U_k(x_{k-1}\cdots x_0) = B2U_w(x_{w-1}\cdots x_k x_{k-1}\cdots x_0) % 2^k$</li><li>有符号数截断$B2T_k(x_{k-1}\cdots x_0) = U2T_w(B2U_w(x_{w-1}\cdots x_k x_{k-1}\cdots x_0)%2^k)$，即先截断，再重新解释；</li><li>例子：<br><img src="./CSAPP%2002-Bits-ints-part1/6.png" alt=""><br>解答：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">short</span> si = <span class="hljs-number">0</span>x <span class="hljs-number">80</span> <span class="hljs-number">00</span> = <span class="hljs-number">-32768</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> usi = <span class="hljs-number">0</span>x <span class="hljs-number">80</span> <span class="hljs-number">00</span> = <span class="hljs-number">32768</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>x FF FF <span class="hljs-number">80</span> <span class="hljs-number">00</span> = <span class="hljs-number">-32768</span>;<br><span class="hljs-type">unsigned</span> ui = <span class="hljs-number">0</span>x <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">80</span> <span class="hljs-number">00</span> = <span class="hljs-number">32768</span>;<br></code></pre></td></tr></table></figure><p><img src="CSAPP%2002-Bits-ints-part1/7.png" alt=""><br>解答：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>x <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">80</span> <span class="hljs-number">00</span> = <span class="hljs-number">32768</span>;<br><span class="hljs-type">short</span> si = (<span class="hljs-type">short</span>)i = <span class="hljs-number">0</span>x <span class="hljs-number">80</span> <span class="hljs-number">00</span> = <span class="hljs-number">-32768</span>;<br><span class="hljs-type">int</span> j = si = <span class="hljs-number">0</span>x FF FF <span class="hljs-number">80</span> <span class="hljs-number">00</span> = <span class="hljs-number">-32768</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 01-Overview</title>
    <link href="/2025/01/03/CSAPP%2001-Overview/"/>
    <url>/2025/01/03/CSAPP%2001-Overview/</url>
    
    <content type="html"><![CDATA[<h1>程序的执行过程</h1><p><img src="./CSAPP%2001-Overview/1.png" alt=""></p><ul><li>编辑代码：高级程序语言阶段</li><li>Compiler编译器：汇编代码（指令操作用助记符表示）</li><li>Assembler汇编器：将汇编代码转为机器指令（01字符串）</li><li>执行机器代码，调度硬件，运行程序；</li></ul><h1>8086CPU</h1><p><img src="./CSAPP%2001-Overview/2.png" alt=""></p><blockquote><p>通用寄存器组GPRS</p><blockquote><p>数据寄存器：</p><blockquote><p>AX：累加器；<br>BX：基地址(Base)；<br>CX：计数寄存器(Counter)；<br>DX：数据寄存器；<br>地址寄存器：<br>SP：堆栈指针Stack Pointer；<br>BP：基址指针Base Pointer；<br>DI：目标地址Dest；<br>SI：源地址Source；</p></blockquote></blockquote></blockquote><blockquote><p>内部寄存器</p><blockquote><p>CS：代码段code；和IP一起得到下一条指令的地址；<br>DS：数据段data；<br>SS：堆栈段；函数调用时的返回地址、局部变量和参数等；<br>ES：附加段：<br>IP：指令指针；总是指向<strong>当前正在执行的指令的下一条指令的偏移地址</strong>；</p></blockquote></blockquote><blockquote><p>标志寄存器：</p><blockquote><p>OF：溢出标志Overflow；<br>DF：方向Direction；<br>IF：中断允许；<br>SF：符号（ = 运算结果的最高位）；<br>ZF：零标志（运算结果 = 0时，ZF = 1）；<br>AF：辅助进位；<br>PF：奇偶（低8位满足偶校验，PF = 1）；<br>CF：进位/借位；</p></blockquote></blockquote><ul><li>8086的地址总线为20，总共可寻址空间为$2^{20} = 2MB$；</li></ul><h1>一个完整程序的执行过程</h1><ol><li>从键盘上读取hello命令，即从键盘到I/O中继器再到CPU；<img src="CSAPP%2001-Overview/3.png" alt=""></li><li>从磁盘(外存)加载可执行文件到主存(内存)，在这之前CPU先向主存发送读取的指令；<img src="CSAPP%2001-Overview/4.png" alt=""></li><li>执行程序，将输出字符串从存储器写到显示器，即CPU先从内存上获取字符串的地址存入寄存器，再控制I/O设备输出到图形化窗口；<img src="CSAPP%2001-Overview/5.png" alt=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2024/12/26/KMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/12/26/KMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1>next数组</h1><blockquote><p><code>next[j]=k</code>：k是当模式串中第j个字符与主串中相应字符 “失配”时，在模式串中需重新和主串中该字符进行比较的字符的位置。</p></blockquote><p>$$<br>\left.{next[j]=}\left{\begin{array}{ll}<br>\mathbf{0} &amp; \text{当 j=1 时(代表下一趟比较}\mathrm{i=i+1,j=1})\\<br>\mathbf{max{k\mid1&lt;k&lt;j}\text{且前k - 1个元素和后k-1个元素一致}}&amp;\text{此集合不为空时,下一趟比较i = i ,j = k}\\<br>\mathbf{1}&amp;\text{其它情況(即$j \ne 1且上述集合为空$)}\end{array}\right.\right.<br>$$</p><blockquote><p><strong>快速填写记法：</strong></p><p>（1）字符串从1开始标号；</p><p>（2）next[1]默认为0；</p><p>（3）next[i] = 前 i -1 位字符串公共前后缀的长度 + 1；</p><p><strong>Notice：</strong></p><p>前缀：除最后一个字符外，一个字符串的全部头部组合；</p><p>后缀：除第一个字符外，一个字符串全部的尾部组合；所以，<code>&quot;aaa&quot;</code>的公共前缀和长度为2。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">GetNext</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *T, <span class="hljs-type">int</span> *next)</span> &#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>; <span class="hljs-comment">// j 表示模式串位置, k 是前缀长度</span><br>    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 初始化 next 数组</span><br>    <span class="hljs-keyword">while</span> (j &lt; <span class="hljs-built_in">strlen</span>(T)) &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || T[j] == T[k]) &#123;<br>            j++;<br>            k++;<br>            next[j] = k; <span class="hljs-comment">// 更新 next[j]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            k = next[k]; <span class="hljs-comment">// 回退</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>nextval数组</h1><blockquote><p><strong>引入原因</strong>：next数组中，前后两个相邻的字母如果相同，在匹配过程中遇到需要回退的情况，可以跳过回退到该字母。</p></blockquote><p>$$<br>\begin{array}{l}<br>nextval[i] &amp; = 1\<br>nextval[i] &amp; = \left{\begin{array}{ll}<br>nextval[i] = nextval[next[i]] &amp; \text{当$Pattern_i = Pattern_{next[i]}$时}\\<br>nextval[i] = next[i] &amp; \text{当$Pattern_i \ne Pattern_{next[i]}$时}\end{array}\right.<br>\end{array}<br>$$</p><p><img src="/2024/12/26/KMP%E7%AE%97%E6%B3%95/KMP.png" alt=""></p><h1>完整代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">GetNextVal</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *T, <span class="hljs-type">int</span> *nextval)</span> &#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>; <span class="hljs-comment">// j 表示模式串位置, k 是前缀长度</span><br>    nextval[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 初始化 nextval 数组</span><br>    <br>    <span class="hljs-keyword">while</span> (j &lt; <span class="hljs-built_in">strlen</span>(T)) &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || T[j] == T[k]) &#123;<br>            j++;<br>            k++;<br>            <span class="hljs-keyword">if</span> (T[j] != T[k]) &#123;<br>                nextval[j] = k; <span class="hljs-comment">// 当 T[j] ≠ T[next[j]] 时，直接赋值</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nextval[j] = nextval[k]; <span class="hljs-comment">// 当 T[j] == T[next[j]] 时，优化跳跃</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            k = nextval[k]; <span class="hljs-comment">// 回退</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index_KMP</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *S, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *T, <span class="hljs-type">int</span> pos)</span> &#123;<br>    <span class="hljs-type">int</span> nextval[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 假设模式串长度不超过 100</span><br>    GetNextVal(T, nextval); <span class="hljs-comment">// 生成 nextval 数组</span><br>    <br>    <span class="hljs-type">int</span> i = pos; <span class="hljs-comment">// 主串的当前指针</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 模式串的当前指针</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i\tj\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-built_in">strlen</span>(S) &amp;&amp; j &lt;= <span class="hljs-built_in">strlen</span>(T)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>, i, j); <span class="hljs-comment">// 输出当前的 i 和 j 值</span><br>        <br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || S[i - <span class="hljs-number">1</span>] == T[j - <span class="hljs-number">1</span>]) &#123;<br>            i++;<br>            j++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            j = nextval[j]; <span class="hljs-comment">// 模式串向右移动</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-built_in">strlen</span>(T)) &#123;<br>        <span class="hljs-keyword">return</span> i - <span class="hljs-built_in">strlen</span>(T); <span class="hljs-comment">// 匹配成功，返回匹配位置</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 匹配失败</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> S[] = <span class="hljs-string">&quot;abcaacabcab&quot;</span>; <span class="hljs-comment">// 主串</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> T[] = <span class="hljs-string">&quot;abcab&quot;</span>;       <span class="hljs-comment">// 模式串</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;主串: %s\n&quot;</span>, S);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;模式串: %s\n&quot;</span>, T);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;匹配过程:\n&quot;</span>);<br>    <br>    <span class="hljs-type">int</span> pos = Index_KMP(S, T, <span class="hljs-number">1</span>); <span class="hljs-comment">// 从第一个字符开始匹配</span><br>    <br>    <span class="hljs-keyword">if</span> (pos &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;匹配成功，位置: %d\n&quot;</span>, pos);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;匹配失败\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构Review</title>
    <link href="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/"/>
    <url>/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/</url>
    
    <content type="html"><![CDATA[<h2 id="Chapter1-概论">Chapter1 概论</h2><ul><li>数据、数据元素、数据项、数据对象、数据结构等基本概念<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E6%A6%82%E8%AE%BA%E6%A6%82%E5%BF%B5.png" alt=""><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E6%A6%82%E8%AE%BA%E6%A6%82%E5%BF%B52.png" alt=""><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E6%A6%82%E8%AE%BA%E6%A6%82%E5%BF%B53.png" alt=""></li><li>逻辑结构，存储结构及数据运算的含义及其相互关系<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt=""><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt=""></li><li>算法评价标准：正确性、可读性、健壮性、效率与存储量需求、支持分布式和并行处理的算法在大数据场景下更有优势。</li></ul><h2 id="Chapter2-线性表">Chapter2 线性表</h2><h3 id="2-2链表">2.2链表</h3><ul><li>头节点的使用：头节点的指针域指向第一个数据节点的地址<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E5%A4%B4%E8%8A%82%E7%82%B9.png" alt=""></li></ul><h2 id="Chapter3-栈、队列">Chapter3 栈、队列</h2><h3 id="3-1-栈">3.1 栈</h3><h4 id="3-1-1-顺序栈">3.1.1 顺序栈</h4><ul><li>非空栈中的栈顶指针<strong>top来指向栈顶元素的下一个位置</strong>；</li><li>空栈时top = base，栈中元素的数量 = top - base；</li></ul><h4 id="3-1-2-链栈">3.1.2 链栈</h4><ul><li>链表指针方向是从栈顶指向栈底；</li></ul><h4 id="3-1-3-应用">3.1.3 应用</h4><ul><li>括弧匹配检验</li><li>中缀表达式：左括号在栈外时优先级最高，在栈内时优先级很 低，仅高于栈外的右括号；</li><li>后缀表达式；<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E8%BD%AC%E6%8D%A2.png" alt=""></li><li>尾递归：递归调用出现在函数中的最后一行，并且没有任何局部变量参与最后一行代码的计算。此时支持“尾递归优化”的编程语言就可以在执行尾递归代码时不进行入栈操作；</li></ul><h3 id="3-2-队列">3.2 队列</h3><h4 id="3-2-1-顺序队列">3.2.1 顺序队列</h4><ul><li>队空是front  = rear = 0；非空队列头指针始终指向队列头元素，而尾指针始终指向<strong>队列尾元素的下一个位置</strong>。</li><li>循环队列：解决“假溢出”；判空采用：front == rear；判满采用：少用一个元素空间，当队尾指针加1就会从后面赶上队头指针，这种情况下队满的条件是：(rear+1) % MAXSIZE  == front；</li></ul><h4 id="3-2-2-链队">3.2.2 链队</h4><h2 id="Chapter4-串">Chapter4 串</h2><h3 id="4-1-串的基本操作">4.1 串的基本操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Concat(&amp;T, S1, S2); <span class="hljs-comment">// 用T返回由S1和S2连接而成的新串两串</span><br>SubString(&amp;Sub, S, pos, len); <span class="hljs-comment">// 用Sub返回S字符串第pos个位置开始的长度为len的子串</span><br>StrCompare(S, T); <span class="hljs-comment">// 两串比较S &gt; T，返回值 &gt; 0；S = T，返回值 = 0；S &lt; T，返回值 &lt; 0；</span><br>Index(S, T, pos); <span class="hljs-comment">// 在S中第pos个位置开始后的部分找到与T相同的子串，返回第一次出现的位置，未找到则返回 0</span><br>Replace(&amp;S, T, V); <span class="hljs-comment">// 用V替换S中与T相等的不重叠子串</span><br>StrInsert(&amp;S, pos, T); <span class="hljs-comment">// 在S的第pos个位置前插入T</span><br>StrDelete(&amp;S, pos, len); <span class="hljs-comment">// 在S中的第pos个位置开始删除长度为len的子串</span><br></code></pre></td></tr></table></figure><h3 id="4-2-串的模式匹配算法">4.2 串的模式匹配算法</h3><h4 id="4-2-1-简单模式匹配算法Brute-Force">4.2.1 简单模式匹配算法Brute Force</h4><p>逐个遍历字符串的每个字母，并逐个检查从它开始的长为len个的字符是否匹配；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span> &#123;<br>i = pos;  j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= S[<span class="hljs-number">0</span>] &amp;&amp; j &lt;= T[<span class="hljs-number">0</span>]) &#123;<br><span class="hljs-keyword">if</span> (S[i] == T[j]) &#123; <br>++i;<br>++j; <br>&#125;<br><span class="hljs-comment">// 继续比较后继字符</span><br><span class="hljs-keyword">else</span> &#123; <br>i = i-j+<span class="hljs-number">2</span>;<br>j = <span class="hljs-number">1</span>;<br>&#125; <br><span class="hljs-comment">// 指针后退重新开始匹配</span><br>&#125;<br><span class="hljs-keyword">if</span> (j &gt; T[<span class="hljs-number">0</span>]) <br><span class="hljs-keyword">return</span> i-T[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-comment">// Index</span><br></code></pre></td></tr></table></figure><p>最好情况下平均时间复杂度为$O(m + n)$，最坏情况下为$O(m * n)$。</p><h4 id="4-2-2-KMP算法">4.2.2 KMP算法</h4><p>见<a href="https://yokumii.github.io/blog/2024/12/26/KMP%E7%AE%97%E6%B3%95/">KMP算法</a>。</p><h2 id="Chapter5-数组与广义表">Chapter5 数组与广义表</h2><h3 id="5-1-数组">5.1 数组</h3><ul><li>数组是线性表的扩展，其数据元素本身也是线性表；</li><li>数组中各元素都具有统一的类型；</li></ul><h3 id="5-2-矩阵的压缩存储">5. 2 矩阵的压缩存储</h3><ul><li>目的是为了节省空间；</li></ul><h4 id="5-2-1-对称矩阵">5.2.1 对称矩阵</h4><h4 id="5-2-2-带状矩阵">5.2.2 带状矩阵</h4><h4 id="5-2-3-随机稀疏矩阵">5.2.3 随机稀疏矩阵</h4><p>（1）顺序存储方法：三元表法<br>（2）链式存储方法：十字链表法<br>在行、列两个方向上，将非零元素链接在一起。克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便。<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95.png" alt=""></p><h3 id="5-3-广义表">5.3 广义表</h3><ul><li>广义表是由零个或多个原子或者子表组成的有限序列；<ul><li>原子：逻辑上不能再分解的元素；</li><li>子表：作为广义表中元素的广义表；</li></ul></li><li>广义表中的元素全部为原子时即为线性表，线性表是广义表的特例，广义表是线性表的推广；</li><li>一般用大写字母表示广义表的名称，用小写字母表示原子；</li><li>表的长度：表中的（第一层）元素个数；</li><li>表的深度：表中元素的最深嵌套层数；</li><li>表头：表中的第一个元素；</li><li>表尾：除第一个元素外，剩余元素<strong>构成的广义表</strong>。 任何一个非空广义表的表尾必定仍为广义表；</li></ul><h2 id="Chapter-6-树和二叉树">Chapter 6 树和二叉树</h2><h3 id="6-1-树">6.1 树</h3><h3 id="6-2-二叉树">6.2 二叉树</h3><h3 id="6-3-线索二叉树">6.3 线索二叉树</h3><ul><li>如果无左孩子，那利用左孩子指针指向直接前驱节点；如果无右孩子，那利用右孩子指针指向直接后继节点；</li></ul><h3 id="6-4-树和森林">6.4 树和森林</h3><ul><li>孩子兄弟链表表示法：左孩子，右兄弟；</li></ul><h4 id="6-4-1-树转化为二叉树">6.4.1 树转化为二叉树</h4><ol><li>在所有兄弟结点之间加一条连线；</li><li>对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线；</li><li>以根为轴心将整棵树顺时针转45度；<br>特点：无右子树、左支是孩子、右支是兄弟；</li></ol><h4 id="6-4-2-森林转化为二叉树">6.4.2 森林转化为二叉树</h4><ol><li>先将森林的每一个树转化为二叉树；</li><li>从后一棵树开始，将后一棵树作为前一棵树的右子；</li></ol><h4 id="6-4-3-二叉树转化为树-森林">6.4.3 二叉树转化为树/森林</h4><ol><li>把双亲节点的左孩子的右孩子、右孩子的右孩子、……和双亲节点连接起来；</li><li>删除所有双亲节点与右孩子的连线；</li></ol><h4 id="6-4-4-树的遍历">6.4.4 树的遍历</h4><p><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png" alt=""></p><h4 id="6-4-5-森林的遍历">6.4.5 森林的遍历</h4><ul><li>先序遍历：逐棵先序遍历每棵子树/对应二叉树的先序遍历；</li><li>中序遍历：逐棵中序遍历每棵子树/对应二叉树的中序遍历；</li><li></li></ul><h2 id="Chapter7-图">Chapter7 图</h2><h3 id="7-1-一些基本概念：">7.1 一些基本概念：</h3><p><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E8%B7%AF.png" alt=""><br><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E8%BF%9E%E9%80%9A.png" alt=""><br><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E5%BC%BA%E8%BF%9E%E9%80%9A.png" alt=""><br><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt=""><br><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E5%AD%90%E5%9B%BE.png" alt=""></p><h3 id="7-2-图的基本存储结构">7.2 图的基本存储结构</h3><p><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E6%AF%94%E8%BE%83.png" alt=""><br><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E5%8D%81%E5%AD%97%E8%A1%A8%E6%B3%95.png" alt=""></p><h3 id="7-3-最小生成树">7.3 最小生成树</h3><p><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png" alt=""></p><h3 id="7-4-拓扑排序">7.4 拓扑排序</h3><h4 id="7-4-1-无前驱的顶点优先算法">7.4.1 无前驱的顶点优先算法</h4><p><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E6%97%A0%E5%89%8D%E9%A9%B1%E7%9A%84%E9%A1%B6%E7%82%B9%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.png" alt=""></p><h4 id="7-4-2-无后继的顶点优先">7.4.2 无后继的顶点优先</h4><p><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/%E6%97%A0%E5%90%8E%E7%BB%A7%E7%9A%84%E9%A1%B6%E7%82%B9%E4%BC%98%E5%85%88.png" alt=""></p><h3 id="7-5-关键路径">7.5 关键路径</h3><h4 id="7-5-1-AOE网">7.5.1 AOE网</h4><p><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/AOE%E7%BD%91.png" alt=""><br><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/AOE%E7%BD%912.png" alt=""></p><h4 id="7-5-2-关键术语">7.5.2 关键术语</h4><p><img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/AOE%E7%BD%91%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5.png" alt=""></p><h4 id="7-5-3-求解方法">7.5.3 求解方法</h4><p>希望求解关键路径，即源点到汇点最长的路径；</p><ol><li>对于事件<ol><li>最早发生时间：源点为0，其他点 = Max(源点到该事件的路径长度)；</li><li>最迟发生时间：（倒着算）汇点 = 最早发生时间，其他点 = Min(下一个点最早发生时间 - 边权)；（为了保证下一个事件能最早发生，所以取最小的那个时间）</li></ol></li><li>对于活动<ol><li>最早发生时间：等于起始点事件的最早发生时间；</li><li>最迟发生时间：等于终点时间的最迟发生时间 - 边权；<br>关键路径为最迟发生时间 - 最早发生时间 = 0的边；</li></ol></li></ol><h2 id="Chapter9-查找">Chapter9 查找</h2><h3 id="9-1-顺序查找">9.1 顺序查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyType key)</span> &#123;<br>ST.elem[<span class="hljs-number">0</span>].key = key; <span class="hljs-comment">// 用作哨兵；</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ST.length; key != ST.elem[i].key; i--) &#123;<br><span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 找到了就返回正确的位置，没找到返回0；</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>监视哨的好处：无需进行边界检测，提高效率；</p><p>平均查找长度ASL：</p><p>（1）成功ASL：$(1 + n)* n /2 * \frac{1}{n} = \frac{n+1}{2}$；</p><p>（2）失败ASL：$1 + n$；</p><h3 id="9-2-折半查找">9.2 折半查找</h3><h4 id="9-2-1-构建步骤">9.2.1 构建步骤</h4><p>（1）mid = (1 + n)/2 作为根节点，(1 + mid - 1)/2 作为它的左孩子，(mid + 1 + n)/2 作为右孩子；<br>（2）如此构建折半查找树；</p><h4 id="9-2-2-平均查找长度ASL">9.2.2 平均查找长度ASL</h4><ol><li>成功ASL：待查找的节点在第$x$层，需要比较的次数就是$x$，加权求和即可；</li></ol><h3 id="9-3-二叉排序树">9.3 二叉排序树</h3><h4 id="9-3-1-构建步骤">9.3.1 构建步骤</h4><p>（1）给定序列，第一个节点作为根节点；<br>（2）如果比上一个节点小，则放在它的左子树；比上一个节点大，则放在它的右子树；</p><h4 id="9-3-2-调整（删除节点-p）">9.3.2 调整（删除节点*p）</h4><p>（1）p是叶子结点：修改双亲指针即可；<br>（2）p只有左（右）孩子：用它左（右）孩子的指针代替它即可；<br>（3）p有两个孩子：用它的中序后继（或前驱）代替它；其实就是<strong>左子树中最右或者右子树中最左</strong>的节点代替它。</p><h3 id="9-4-平衡二叉树">9.4 平衡二叉树</h3><h4 id="9-4-1-维持平衡操作">9.4.1 维持平衡操作</h4><blockquote><p><strong>最小不平衡子树</strong>：最下往上，第一个出现左右子树深度之差 &gt; 1的节点。</p></blockquote><h5 id="1-LL型">1. LL型</h5><blockquote><p>新插入的节点在最小不平衡子树的左孩子的左子树；</p><p>调整方法：左孩子向右上旋转；<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/LL.png" alt=""></p></blockquote><h5 id="2-RR型">2. RR型</h5><blockquote><p>新插入的节点在最小不平衡子树的右孩子的右子树；</p><p>调整方法：右孩子向左上旋转；（和LL型刚好相反）<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/RR.png" alt=""></p></blockquote><h5 id="3-LR型">3.LR型</h5><blockquote><p>新插入的节点在最小不平衡子树的左孩子的右子树；</p><p>调整方法：左孩子的右子树先左上旋，再右上旋；<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/LR.png" alt=""></p></blockquote><h5 id="4-RL型">4. RL型</h5><blockquote><p>新插入的节点在最小不平衡子树的右孩子的左子树；</p><p>调整方法：右孩子的左子树先右上旋，再左上旋；（和LR型刚好相反）<img src="/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/RL.png" alt=""></p></blockquote><h3 id="9-5-B-树">9.5 B-树</h3><p>B-树是一种多叉平衡搜索树。</p><p>对于$m$叉树，要求：</p><ul><li>每个节点最多有$m$个分支，$m-1$个元素；</li><li>根节点最少有$2$个分支，$1$个元素；</li><li>其他节点最少有$\left \lceil \frac{m}{2} \right \rceil$个分支，$\left \lceil \frac{m}{2} \right \rceil - 1$个节点；</li></ul><h4 id="9-5-1-B-树的构建和插入">9.5.1 B-树的构建和插入</h4><ol><li>先查找到插入到位置进行插入；</li><li>如果没有上溢出，无需调整；</li><li>如果发生上溢出，将第$\left \lceil \frac{m}{2} \right \rceil$个元素（中间元素）向上移动，两边分裂（直至不发生上溢出）；</li></ol><h4 id="9-5-2-B-树的删除">9.5.2 B-树的删除</h4><p>B-树的根结点可以始终置于内存中；其余非叶结点放置在外存上，每一结点可作为一个读取单位（页/块）；<br>选取较大的阶次m，降低树的高度，减少外存访问次数；</p><h3 id="9-6-B-树">9.6 B+树</h3><h2 id="Chapter-10-内部排序">Chapter 10 内部排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 用于 sort 函数</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> KeyType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    KeyType r[MAXSIZE<span class="hljs-number">+1</span>];  <span class="hljs-comment">//r[0]闲置或作哨兵</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CinList</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    cin&gt;&gt;L.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= L.length; i++) &#123;<br>        cin&gt;&gt;L.r[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CoutList</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= L.length; i++) &#123;<br>        cout&lt;&lt;L.r[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 基于比较的内部排序</span><br><br><span class="hljs-comment">// 直接插入排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= L.length; i++) &#123; <span class="hljs-comment">// 循环 n - 1 次</span><br>        <span class="hljs-keyword">if</span> (L.r[i] &lt; L.r[i - <span class="hljs-number">1</span>]) &#123;<br>            L.r[<span class="hljs-number">0</span>] = L.r[i]; <span class="hljs-comment">// 用作监视哨</span><br>            L.r[i] = L.r[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 算一次移动</span><br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">2</span>; L.r[<span class="hljs-number">0</span>] &lt; L.r[j]; j--) &#123;<br>                L.r[j + <span class="hljs-number">1</span>] = L.r[j]; <span class="hljs-comment">// 后移一位</span><br>            &#125;<br>            L.r[j + <span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 算一次移动</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 稳定排序；</span><br>    <span class="hljs-comment">// 排序过程中，数据前一部分逐渐有序，不过可能出现最后一趟之前数据均未在最终位置（最后一个数据为最小值，前 n - 1）个数据均需后移；</span><br>    <span class="hljs-comment">// 最好情况：只需比较 n - 1 次（即循环趟数），移动 0 次，时间复杂度为 O(n)；</span><br>    <span class="hljs-comment">// 最坏情况：第 i 趟需要比较 i 次（从 i - 1 比较到 0 ），移动 i + 1 次（前 i - 1 个均后移一次，监视哨放置 1 次，监视哨后移 1 次）；</span><br>        <span class="hljs-comment">// 比较次数 = (n + 2)(n - 1)/2，移动次数 = (n + 4)(n - 1)/2，时间复杂度为 O(n^2)；</span><br>    <span class="hljs-comment">// 平均时间 O(n^2)；</span><br>    <span class="hljs-comment">// 优化操作：</span><br>        <span class="hljs-comment">// （1）折半插入排序：在找插入位置时采用二分查找，减少了比较次数，移动次数不变；</span><br>&#125;<br><br><span class="hljs-comment">// 希尔排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-comment">// 间隔步长d选点作为一组子表进行插排，不断缩小步长，代码略，不太可能考写代码；</span><br>    <br>    <span class="hljs-comment">// 不稳定排序；</span><br>    <span class="hljs-comment">// 最好情况和最坏情况和直接插排一样；</span><br>    <span class="hljs-comment">// 平均时间 O(n^1.3)；</span><br>&#125;<br><br><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> isSorted = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length - <span class="hljs-number">1</span> &amp;&amp; isSorted; i++) &#123; <span class="hljs-comment">// 最多排 n - 1 趟</span><br>        isSorted = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; L.length - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (L.r[j] &gt; L.r[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 下沉</span><br>                L.r[<span class="hljs-number">0</span>] = L.r[j];<br>                L.r[j] = L.r[j + <span class="hljs-number">1</span>];<br>                L.r[j + <span class="hljs-number">1</span>] = L.r[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 交换过程，记为3次移动</span><br>                isSorted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标志进行交换；</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 稳定排序</span><br>    <span class="hljs-comment">// 最好情况：只需比较 n - 1 次，无需移动，时间复杂度为 O(n)；</span><br>    <span class="hljs-comment">// 最坏情况：需要 n - 1 趟，第 i 趟需要比较 n - i 次，移动 3 * (n - i) 次；</span><br>        <span class="hljs-comment">// 比较次数 = n(n - 1) /2，移动次数 = 3n(n - 1)/2，时间复杂度为 O(n^2)；</span><br>    <span class="hljs-comment">// 平均时间 O(n^2)；</span><br>    <span class="hljs-comment">// 特点是，在排序过程中，每一趟中最大的元素逐渐下沉至尾部，即最终位置上；</span><br>&#125;<br><br><span class="hljs-comment">// 快速排序的划分过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    KeyType pivotkey = L.r[low];<br>    L.r[<span class="hljs-number">0</span>] = L.r[low]; <span class="hljs-comment">// 选择low作为支点，同时将low移动到辅助空间，low的位置空出来放下一个找到的元素；</span><br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123; <span class="hljs-comment">// low和high相遇时停止</span><br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; L.r[high] &gt;= pivotkey) &#123; <span class="hljs-comment">// 从后往前，找到第一个小于支点的元素，将它放到支点原来的位置；</span><br>            high--;<br>        &#125;<br>        L.r[low] = L.r[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; L.r[low] &lt;= pivotkey) &#123; <span class="hljs-comment">// 从前往后，找到第一个大于支点的元素，将它放到刚刚空出来的位置；</span><br>            low++;<br>        &#125;<br>        L.r[high] = L.r[low];<br>    &#125;<br>    L.r[low] = L.r[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 将支点移回去；</span><br>    <span class="hljs-keyword">return</span> low; <span class="hljs-comment">// 返回支点位置，用于划分不同序列；</span><br>&#125;<br><br><span class="hljs-comment">// 快速排序递归的辅助函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Qsort</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivotloc = <span class="hljs-built_in">Partition</span>(L, low, high); <span class="hljs-comment">// 进行划分，确定支点位置；</span><br>        <span class="hljs-built_in">Qsort</span>(L, low, pivotloc - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">Qsort</span>(L, pivotloc + <span class="hljs-number">1</span>, high); <span class="hljs-comment">// 对支点左右两部分继续进行划分；</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 快速排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-built_in">Qsort</span>(L, <span class="hljs-number">1</span>, L.length);<br>    <br>    <span class="hljs-comment">// 不稳定排序</span><br>    <span class="hljs-comment">// 划分时，比较次数 &lt;= n 次，时间复杂度为O(n)，移动次数为 4 次（支点移到辅助空间，大于支点的节点移动，小于节点的支点移动，支点移回去）；</span><br>    <span class="hljs-comment">// 最好情况：划分时划分为左右两个等长子序列，需要排序的趟数 &lt;= log_2(n)，所以时间复杂度为 O(nlogn)；</span><br>    <span class="hljs-comment">// 最坏情况：初始完全逆序，每次划分只能将最大的，即支点移动到最后面，得到一个子序列，时间复杂度为 O(n^2)；</span><br>    <span class="hljs-comment">// 快速排序通常被认为是同数量级中时间复杂度为 O(nlogn) 中平均性能最好的；</span><br>    <span class="hljs-comment">// 采用递归实现的快排，递归层数 = 二叉树深度，即排序的趟数，所以理想空间开销为 O(logn) ，最坏开销为 O(n)；</span><br>    <span class="hljs-comment">// 特点是，每一趟排完后，支点的位置就在最终文字；</span><br>&#125;<br><br><span class="hljs-comment">// 选择排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= L.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// n - 1 趟；</span><br>        <span class="hljs-type">int</span> k = i; <span class="hljs-comment">// 记录待替换的元素位置；</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= L.length; j++) &#123; <span class="hljs-comment">// 找到 i + 1 位置到结尾处最小的元素放到 i 位置；</span><br>            <span class="hljs-keyword">if</span> (L.r[j] &lt; L.r[k]) &#123;<br>                k = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != k) &#123;<br>            L.r[<span class="hljs-number">0</span>] = L.r[i];<br>            L.r[i] = L.r[k];<br>            L.r[k] = L.r[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 交换元素，记为 3 次移动；</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不稳定排序，找到最小的过程中，选择的是下标最大的最小值；</span><br>    <span class="hljs-comment">// 排序过程中，前一部分数据逐渐有序，且放置在最终位置上；</span><br>    <span class="hljs-comment">// 排序趟数为 n - 1 趟，第 i 趟的比较次数为，n - i，总比较次数为 (1 + n - 1)(n - 1)/2 = n(n - 1)/2；</span><br>    <span class="hljs-comment">// 每趟排序交换 1 次，记为 3 次移动，移动次数为 3(n - 1)次；</span><br>    <span class="hljs-comment">// 时间复杂度为 O(n^2)；</span><br>&#125;<br><br><span class="hljs-comment">// 完全二叉堆的概念：</span><br>    <span class="hljs-comment">// 小顶堆：每个节点的值都小于等于左右孩子的值；</span><br>    <span class="hljs-comment">// 大顶堆：每个节点的值都大于等于左右孩子的值；</span><br><span class="hljs-comment">// 输出堆顶元素后调整堆的操作——筛选：</span><br>    <span class="hljs-comment">// （1）将堆底元素移到堆顶，此时堆的性质被破坏，但左右子树仍保持堆的局部性质；</span><br>    <span class="hljs-comment">// （2）将此时的堆顶元素与左右孩子中较大的元素交换，如此做，直到满足了堆的性质；</span><br><span class="hljs-comment">// 堆的构建：给定某一序列后，从最后一个非叶子结点的子树开始从下往上调整；</span><br>    <span class="hljs-comment">// 对于完全二叉树，最后一个非叶子结点序号为 n/2；</span><br>    <br><span class="hljs-comment">// 筛选</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> root, <span class="hljs-type">int</span> end)</span> </span>&#123; <span class="hljs-comment">// root 是待调整的子树根节点的序号，end 是待调整的子树的最后一个节点</span><br>    L.r[<span class="hljs-number">0</span>] = L.r[root]; <span class="hljs-comment">// 存储当前堆顶元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * root; j &lt;= end &amp;&amp; j + <span class="hljs-number">1</span> &lt;= end; j *= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (L.r[j] &lt; L.r[j + <span class="hljs-number">1</span>]) &#123;<br>            j++; <span class="hljs-comment">// j 表示左右孩子中较大的节点；</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (L.r[<span class="hljs-number">0</span>] &gt;= L.r[j]) &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 父节点大于左右孩子，满足大顶堆的性质；</span><br>        &#125;<br>        L.r[root] = L.r[j]; <span class="hljs-comment">// 孩子节点换到根节点</span><br>        root = j; <span class="hljs-comment">// 此时根节点指向交换下去的节点</span><br>    &#125;<br>    L.r[root] = L.r[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// 堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-comment">// 建立堆</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L.length / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 从最后一个非叶子结点开始，逐步从下往上调整；</span><br>        <span class="hljs-built_in">HeapAdjust</span>(L, i, L.length);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 每次取出最大的元素（堆顶），和堆底元素交换，重新调整堆；</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L.length; i &gt; <span class="hljs-number">1</span>; i--) &#123;<br>        L.r[<span class="hljs-number">0</span>] = L.r[<span class="hljs-number">1</span>];<br>        L.r[<span class="hljs-number">1</span>] = L.r[i];<br>        L.r[i] = L.r[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 交换堆顶和堆底，记为 3 次移动；</span><br>        <span class="hljs-built_in">HeapAdjust</span>(L, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 调整剩余部分 1 ～ i - 1；</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 不稳定排序</span><br>    <span class="hljs-comment">// 对于二叉树，树高 k = 「log_2(n)」+ 1；</span><br>    <span class="hljs-comment">// 每次筛选，从根到叶子结点，最多经过 2(k - 1) 次比较（左右孩子比较，较大者与父节点比较，共 2 次），最多经过 k 次交换，即 3 * k 次移动；</span><br>    <span class="hljs-comment">// 堆排序需要经过 n - 1 次筛选；</span><br>    <span class="hljs-comment">// 时间复杂度为 O(nlogn)；</span><br>    <span class="hljs-comment">// 排序过程中，序列后面的数据逐渐有序，并且在最终位置；</span><br>    <span class="hljs-comment">// 对记录数较大的文件很有效；</span><br>&#125;<br><br><span class="hljs-comment">// 2-路归并排序基本思想：</span><br>    <span class="hljs-comment">// 含有一个元素的子表总是有序的，所以对相邻的含有一个元素的子表进行合并，得到表长 = 2 的有序表；如此做直至生成表长 = n 的有序表；共需要 「log_2(n)」 趟；</span><br>    <br><span class="hljs-comment">// 合并两张子表(left表示第一张表的开头，mid表示第一张表的结尾，mid + 1表示第二张表的开头，right表示第二张表的结尾)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> Source[], <span class="hljs-type">int</span>* Dest, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = left;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>        <span class="hljs-keyword">if</span> (Source[i] &lt; Source[j]) &#123; <span class="hljs-comment">// 先判断小于条件，保证排序稳定性！！！</span><br>            Dest[k] = Source[i];<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            Dest[k] = Source[j];<br>            j++;<br>        &#125;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 此时一个数组已空，另一个数组非空，将剩余元素放入Dest；</span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;<br>        Dest[k] = Source[i];<br>        k++, i++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt;= mid) &#123;<br>        Dest[k] = Source[j];<br>        k++, j++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 归并排序的递归辅助函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MSort</span><span class="hljs-params">(<span class="hljs-type">int</span> Source[], <span class="hljs-type">int</span>* Dest, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start == end) &#123; <span class="hljs-comment">// 当数组长度为 1 时，该数组已经有序的，不用再分解；</span><br>        Dest[start] = Source[start]; <span class="hljs-comment">// 改成 Return 也一样；</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> Temp[MAXSIZE]; <span class="hljs-comment">// 辅助数组；</span><br>        <span class="hljs-built_in">MSort</span>(Source, Temp, start, mid); <span class="hljs-comment">// 将 Source[start:mid] 归并为有序的 Temp[start:mid]；</span><br>        <span class="hljs-built_in">MSort</span>(Source, Temp, mid + <span class="hljs-number">1</span>, end); <span class="hljs-comment">// 将 Source[mid + 1:end]归并为有序的 Temp[mid + 1:end]；</span><br>        <span class="hljs-built_in">Merge</span>(Temp, Dest, start, mid, end); <span class="hljs-comment">// 将有序子表 Temp[start:mid] 和 Temp[mid + 1:end] 合并为 Dest[start:end]</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-built_in">MSort</span>(L.r, L.r, <span class="hljs-number">1</span>, L.length);<br>    <br>    <span class="hljs-comment">// 稳定排序</span><br>    <span class="hljs-comment">// 空间复杂度为 O(n)；</span><br>    <span class="hljs-comment">// 归并趟数 = 「log_2(n)」，每趟归并需要移动 n 次，时间复杂度为 O(nlogn)；</span><br>&#125;<br><br><span class="hljs-comment">// 基于比较的内部排序总结：</span><br>    <span class="hljs-comment">// 插入排序：直接插入排序、希尔排序（特点是移动次数较多）；</span><br>    <span class="hljs-comment">// 交换排序：冒泡排序、快速排序（相邻元素之间作比较，比较次数较多）；</span><br>    <span class="hljs-comment">// 选择排序：简单选择排序、堆排序（比较次数较多）；</span><br>    <span class="hljs-comment">// 归并排序；</span><br>    <span class="hljs-comment">// 稳定排序有：直接插入排序、冒泡排序、归并排序；</span><br>    <span class="hljs-comment">// 快速排序是目前基于比较的内部排序中最好的方法；</span><br>    <span class="hljs-comment">// 关键字随机分布时，快速排序的平均时间最短，堆排序次之，但后者所需的辅助空间少；</span><br>    <span class="hljs-comment">// 当 n 较小时，可采用直接插入或简单选择排序，前者是稳定排序，但后者通常记录移动次数少于前者（插入排序可能会导致 n - 1 个元素都需要移动，而选择排序每次只需要交换 1 次）；</span><br>    <span class="hljs-comment">// 当 n 较大时，应采用时间复杂度为 O(nlogn) 的排序方法(主要为快速排序和堆排序)或者基数排序的方法，但基数排序对关键字的结构有一定要求；</span><br>    <span class="hljs-comment">// 假设有 n 个值不同的元素存于顺序结构中，要求不经排序选出前 k (k &lt;= n) 个最小元素，问哪些方法可用，哪些方法比较次数最少？这 k 个元素也要有序如何？</span><br>        <span class="hljs-comment">// 选择排序或冒泡排序：k 趟（数据比较次数约为 k * n 次）；</span><br>        <span class="hljs-comment">// 快速排序：每次仅对第一个子序列划分，直至子序列长度小于等于k；长度不足k，则再对其后的子序列划分出补足的长度即可；</span><br>        <span class="hljs-comment">// 堆排序：先建小根堆，k-1 次堆调整（数据比较次数约为 4n + (k-1)logn）；</span><br>        <br><span class="hljs-comment">// 基于分配的内部排序</span><br><br><span class="hljs-comment">// 桶排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BucketSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到数组中的最大值和最小值</span><br>    KeyType maxVal = L.r[<span class="hljs-number">1</span>], minVal = L.r[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= L.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (L.r[i] &gt; maxVal) maxVal = L.r[i];<br>        <span class="hljs-keyword">if</span> (L.r[i] &lt; minVal) minVal = L.r[i];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算桶的数量和范围</span><br>    <span class="hljs-type">int</span> bucketCount = L.length;<br>    vector&lt;vector&lt;KeyType&gt;&gt; <span class="hljs-built_in">buckets</span>(bucketCount);<br>    <br>    <span class="hljs-comment">// 将元素分配到对应的桶中</span><br>    <span class="hljs-type">double</span> range = (<span class="hljs-type">double</span>)(maxVal - minVal + <span class="hljs-number">1</span>) / bucketCount; <span class="hljs-comment">// 每个桶的范围</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= L.length; i++) &#123;<br>        <span class="hljs-type">int</span> index = (L.r[i] - minVal) / range; <span class="hljs-comment">// 根据范围计算桶索引</span><br>        <span class="hljs-keyword">if</span> (index &gt;= bucketCount) index = bucketCount - <span class="hljs-number">1</span>;<br>        buckets[index].<span class="hljs-built_in">push_back</span>(L.r[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 对每个桶内部进行排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        <span class="hljs-built_in">sort</span>(buckets[i].<span class="hljs-built_in">begin</span>(), buckets[i].<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 使用 STL 的 sort 排序</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 将排序后的数据从桶中取出，放回原数组</span><br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bucketCount; i++) &#123;<br>        <span class="hljs-keyword">for</span> (KeyType val : buckets[i]) &#123;<br>            L.r[idx++] = val;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 稳定排序；</span><br>    <span class="hljs-comment">// 空间复杂度为 O(n + k)，其中 n 为元素数量，k 为桶的数量；</span><br>    <span class="hljs-comment">// 平均时间复杂度为 O(n + klogk)，最坏情况时间复杂度为 O(n^2)（所有元素都落在同一个桶中）；</span><br>    <span class="hljs-comment">// 适合待排序数据值域较大但分布比较均匀；</span><br>&#125;<br><br><span class="hljs-comment">// 计数排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CountSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-type">int</span> maxVal = L.r[<span class="hljs-number">1</span>], minVal = L.r[L.length];<br>    <span class="hljs-comment">// 查找最大值和最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= L.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (L.r[i] &gt; maxVal) &#123;<br>            maxVal = L.r[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (L.r[i] &lt; minVal) &#123;<br>            minVal = L.r[i];<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计数数组</span><br>    <span class="hljs-type">int</span>* C = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[maxVal - minVal + <span class="hljs-number">1</span>]();<br>    <span class="hljs-comment">// 计数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= L.length; i++) &#123;<br>        C[L.r[i] - minVal]++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = minVal; i &lt;= maxVal; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; C[i - minVal]; j++) &#123;<br>            L.r[k] = i;<br>            k++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 稳定排序（上述实现过程简略，没有体现稳定排序）；</span><br>    <span class="hljs-comment">// 当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法；</span><br>    <span class="hljs-comment">// 当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。当 k &gt; n 时，效率下降；</span><br>&#125;<br><br><span class="hljs-comment">// 基数排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RadixSort</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-comment">// 稳定排序；</span><br>    <span class="hljs-comment">// 设记录数为 n ，关键字位数为 d ，基数为 r；</span><br>    <span class="hljs-comment">// 每一趟，分配复杂度为 O(n)，收集复杂度为 O(r)；</span><br>    <span class="hljs-comment">// 共需要排 d 趟，所以时间复杂度 O(d * (n + r)) = O(n)（r 和 d 均为常数）；</span><br>    <span class="hljs-comment">// 辅助空间：n 个记录游标，队头指针数组[0:r - 1]和队尾指针数组[0:r - 1]，空间复杂度为 O(n + r)；</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    SqList L;<br>    <span class="hljs-comment">// 测试数据 6 0 -4 8 1 -4 -6</span><br>    <span class="hljs-comment">// 答案 -6 -4 -4 0 1 8</span><br>    <span class="hljs-built_in">CinList</span>(L);<br>    <span class="hljs-comment">// InsertSort(L);</span><br>    <span class="hljs-comment">// BubbleSort(L);</span><br>    <span class="hljs-comment">// QuickSort(L);</span><br>    <span class="hljs-comment">// SelectSort(L);</span><br>    <span class="hljs-comment">// HeapSort(L);</span><br>    <span class="hljs-comment">// MergeSort(L);</span><br>    <span class="hljs-comment">// BucketSort(L);</span><br>    <span class="hljs-built_in">CountSort</span>(L);<br>    <span class="hljs-built_in">CoutList</span>(L);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Chapter-11-外部排序">Chapter 11 外部排序</h2><h3 id="11-1-置换选择法">11.1 置换选择法</h3><p>意义是<strong>在内存工作区容量的限制下，获得尽可能长的初始归并段</strong>。<br>假设内存中用到的优先队列WA规模为$5$，初始待排序文件FI：</p><p><code>5, 20, 26, 46, 31, 25, 16, 51, 17, 28, 1</code></p><p>文件放入内存工作区：<br>WA：<code>5,20,26,46,31</code>；</p><p>第一趟：<br>WA：<code>25,20,26,46,31</code>，第一个归并段：<code>5</code>；</p><p>第二趟：<br>WA：<code>25,16,26,46,31</code>，第一个归并段：<code>5,20</code>；</p><p>第三趟：（不能出最小的16，要出一个比20大的）<br>WA：<code>51,16,26,46,31</code>，第一个归并段：<code>5,20,25</code>；</p><p>第四趟：<br>WA：<code>51,16,17,46,31</code>，第一个归并段：<code>5,20,25,26</code>；</p><p>第五趟：<br>WA：<code>51,16,17,46,28</code>，第一个归并段：<code>5,20,25,26,31</code>；</p><p>第六趟：<br>WA：<code>51,16,17,1,28</code>，第一个归并段：<code>5,20,25,26,31,46</code>；</p><p>第七趟：<br>WA：<code>16,17,1,28</code>，第一个归并段：<code>5,20,25,26,31,46,51</code>；</p><p>第八趟～第十一趟：（此时剩余待排序文件无法放入第一个归并段，生成第二个归并段）<br>第二个归并段：<code>1,16,17,28</code>；</p><h3 id="11-2-最佳归并树">11.2 最佳归并树</h3><p>最佳归并树即$k$叉(阶)哈夫曼树。设初始归并段为$m$个，进行$k-$路归并。<br>需要补充$y$个虚段（用元素$0$表示）：$(k - 1) * x + k = m + y$。<br>注意虚段在画哈夫曼树之前先添加。</p><h3 id="11-3-败者树">11.3 败者树</h3><p>对于初始为升序的归并段进行多路归并，败者树中记录的冠军节点保存的是<strong>最小关键字所在的归并段号</strong>，分支节点保存的是失败者所在的归并段号。</p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>匹配问题</title>
    <link href="/2024/12/17/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2024/12/17/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>匹配/对集问题</h1><h2 id="定义">定义</h2><blockquote><p><img src="/2024/12/17/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/%E5%8C%B9%E9%85%8D%E5%AE%9A%E4%B9%89.png" alt=""><br>翻译成人话就是，匹配要求边集中任何两条边不相邻，最大匹配要求边数最多，完全匹配要求所有顶点都包含。</p></blockquote><h2 id="霍尔婚姻定理-HALL’S-MARRIAGE-THEOREM">霍尔婚姻定理 HALL’S  MARRIAGE  THEOREM</h2><blockquote><p><img src="/2024/12/17/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/%E9%9C%8D%E5%B0%94%E5%A9%9A%E5%A7%BB%E5%AE%9A%E7%90%86.png" alt=""></p></blockquote><h1>稳定匹配问题</h1><blockquote><p><strong>问题描述</strong>：给出一个$n$个男性的集合$M$和$n$个女性的集合$W$，找到一个“稳定”匹配。</p><blockquote><p>每位男性根据对女性的心仪程度从高至低进行排名；<br>每位女性根据对男性的心仪程度从高至低进行排名；</p></blockquote><p><strong>不稳定对</strong>：给出一个完美匹配$S$，男性$m$和女性$w$是不稳定的，如果同时满足下列条件：</p><blockquote><p>$m$相比起当前配偶，更喜欢$w$；<br>$w$相比起当前配偶，更喜欢$m$；</p></blockquote><p><strong>稳定匹配</strong>：一个不包含不稳定对的完美匹配。</p></blockquote><h3 id="Gale-Shapley-算法（延迟决定法）">Gale-Shapley 算法（延迟决定法）</h3><p><img src="/2024/12/17/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/Gale-Shapley%E7%AE%97%E6%B3%95%20.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10005</span>;<br><span class="hljs-type">int</span> M[N] = &#123;<span class="hljs-number">0</span>&#125;, W[N] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 第0个元素表示已经配对的男性/女性个数；男性和女性集合，0表示目前还单身，&gt;0表示已经和该数字对应的异性配对</span><br><span class="hljs-type">int</span> M_pri[N][N] = &#123;<span class="hljs-number">0</span>&#125;, W_pri[N][N] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 第0个元素记录的是男生 m 在寻找心仪女生时的进度；男性和女性对异性的心仪程度排名</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPri</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">G_S</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lovemore</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> w,<span class="hljs-type">int</span> num)</span></span>;<br><br><span class="hljs-comment">// 获取心仪程度输入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPri</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            cin &gt;&gt; M_pri[i][j]; <span class="hljs-comment">// 表示第i位男性对女性心仪程度排名，M_pri[i][j]位女生排名第j名；</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            cin &gt;&gt; W_pri[i][j]; <span class="hljs-comment">// 表示第i位女性对男性心仪程度排名，W_pri[i][j]位男生排名第j名；</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Gale-Shapley 算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">G_S</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m, w;<br><span class="hljs-keyword">while</span> (M[<span class="hljs-number">0</span>] != num) <span class="hljs-comment">// 男生们还未完成配对</span><br>&#123;<br>w = m = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (M[++m] != <span class="hljs-number">0</span>) ; <span class="hljs-comment">// 找到第一个出现的还没有配对的男生m</span><br>w = M_pri[m][++M_pri[m][<span class="hljs-number">0</span>]]; <span class="hljs-comment">// 找到第m位男生心中剩下排名第一的女生w</span><br><span class="hljs-keyword">if</span> (W[w])<span class="hljs-comment">//如果女生已经在约会了</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">lovemore</span>(m,w,num)) <span class="hljs-comment">// 如果w更爱m</span><br>&#123;<br>M[W[w]] = <span class="hljs-number">0</span>; <span class="hljs-comment">// w 甩了当前和她配对的</span><br>M[m] = w;<br>W[w] = m;<br>&#125;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果女生没有约会还是自由状态，成功配对</span><br>&#123;<br>M[m]=w;<br>            M[<span class="hljs-number">0</span>]++;<br>W[w]=m;<br>            W[<span class="hljs-number">0</span>]++;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 判断w是不是更爱m</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lovemore</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> w,<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123; <span class="hljs-comment">// 按排名从高到低往下找</span><br>        <span class="hljs-keyword">if</span> (W_pri[w][i] == W[w]) &#123; <span class="hljs-comment">// 先找到和w配对的那个</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (W_pri[w][i] == m) &#123; <span class="hljs-comment">// 先找到m，说明更爱m</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= num; i++)<br>cout&lt;&lt;<span class="hljs-string">&quot;(&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>&lt;&lt;M[i]&lt;&lt;<span class="hljs-string">&quot;)&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-built_in">getPri</span>(n);<br><span class="hljs-built_in">G_S</span>(n);<br><span class="hljs-built_in">output</span>(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论题型</title>
    <link href="/2024/12/17/%E5%9B%BE%E8%AE%BA%E9%A2%98%E5%9E%8B/"/>
    <url>/2024/12/17/%E5%9B%BE%E8%AE%BA%E9%A2%98%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>10.1.1 度序列可简单图化</h1><blockquote><p><strong>可简单图化的充要条件</strong>：<img src="/2024/12/17/%E5%9B%BE%E8%AE%BA%E9%A2%98%E5%9E%8B/Havel%E5%AE%9A%E7%90%86.png" alt=""></p><p><strong>例题</strong>：<img src="/2024/12/17/%E5%9B%BE%E8%AE%BA%E9%A2%98%E5%9E%8B/%E5%8F%AF%E7%AE%80%E5%8D%95%E5%9B%BE%E5%8C%96%E4%BE%8B%E9%A2%98.png" alt=""></p><blockquote><p><strong>解法</strong>：每次度序列按非递增顺序排列，删除度最大的节点，更新其他节点的度，重新排列，继续重复上述过程。有2种不合理的情况：<br>（1）某次对剩下序列排序后，最大的度数（设为d1）超过了剩下的顶点数；<br>（2）对最大度数后面的d1个数各减1后，出现了负数。</p></blockquote><p><strong>应用</strong>：<strong>Frogs’ Neighborhood</strong></p><blockquote><p><strong>Description</strong></p><blockquote><p>未名湖附近共$N$个大小湖泊$L_1, L_2, \cdots, L_n$(其中包括未名湖)，每个湖泊$L_i$里住着一只青蛙$F_i(1 \le i \le N)$。如果湖泊$L_i$和$L_j$之间有水路相连，则青蛙$F_i$和$F_j$互称为邻居。现在已知每只青蛙的邻居数目$x_1, x_2, \cdots, x_n$，请你给出每两个湖泊之间的相连关系。</p></blockquote><p><strong>Input</strong></p><blockquote><p>第一行是测试数据的组数$T(0 \le T \le 20)$。每组数据包括两行，第一行是整数$N(2 &lt; N &lt; 10)$，第二行是$N$个整数，$x_1, x_2,\cdots, x_n(0 \le x_i \le N)$。</p></blockquote><p><strong>Output</strong></p><blockquote><p>对输入的每组测试数据，如果不存在可能的相连关系，输出&quot;NO&quot;。否则输出&quot;YES&quot;，并用$N\times N$的矩阵表示湖泊间的相邻关系，即如果湖泊$i$与湖泊$j$之间有水路相连，则第$i$行的第$j$个数字为$1$，否则为$0$。每两个数字之间输出一个空格。如果存在多种可能，只需给出一种符合条件的情形。相邻两组测试数据之间输出一个空行。</p></blockquote></blockquote><blockquote><p><strong>Source</strong></p><blockquote><p><a href="http://poj.org/searchproblem?field=source&amp;key=POJ+Monthly--2004.05.15+Alcyone%40pku">POJ Monthly–2004.05.15 Alcyone@pku</a></p></blockquote><p><strong>参考代码</strong></p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> degree, id; <span class="hljs-comment">// 顶点的度数和标号</span><br>&#125; v[<span class="hljs-number">20</span>];<br><br><span class="hljs-type">int</span> map[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a, node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.degree &gt; b.degree; <span class="hljs-comment">// 按度数降序排序</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t, n, flag;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <span class="hljs-comment">// 输入测试数据组数</span><br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <span class="hljs-comment">// 输入当前测试的顶点数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v[i].degree);  <span class="hljs-comment">// 输入每个顶点的度数</span><br>            v[i].id = i;  <span class="hljs-comment">// 记录顶点编号</span><br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(map, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(map));  <span class="hljs-comment">// 初始化邻接矩阵</span><br>        flag = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 贪心算法：依次处理每个顶点，尝试连接符合要求的邻接顶点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>            <span class="hljs-built_in">sort</span>(v + k, v + n, cmp);  <span class="hljs-comment">// 对剩余的顶点按度数排序</span><br>            <span class="hljs-type">int</span> i = v[k].id;  <span class="hljs-comment">// 当前要连的顶点编号</span><br>            <span class="hljs-type">int</span> d1 = v[k].degree;  <span class="hljs-comment">// 当前节点的度数</span><br><br>            <span class="hljs-keyword">if</span> (d1 &gt; n - k - <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果当前节点的度数大于剩余顶点数，无法构图</span><br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 从当前顶点开始，逐步连接其邻居，并减少相应邻居的度数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt;= d1 &amp;&amp; flag; r++) &#123;<br>                <span class="hljs-type">int</span> j = v[k + r].id;  <span class="hljs-comment">// 当前要连接的顶点编号</span><br>                <span class="hljs-keyword">if</span> (v[k + r].degree &lt;= <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果有度数为负的节点，说明构图失败</span><br>                    flag = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                v[k + r].degree--;  <span class="hljs-comment">// 减少邻居的度数</span><br>                map[i][j] = map[j][i] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 在邻接矩阵中标记连接</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>            <span class="hljs-comment">// 输出邻接矩阵</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (j) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, map[i][j]);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (t) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <span class="hljs-comment">// 如果不是最后一组数据，输出空行</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>10.1.2 计算两点之间长度为k的通路数Counting Paths by Adjacency Matrices</h1><p><img src="/2024/12/17/%E5%9B%BE%E8%AE%BA%E9%A2%98%E5%9E%8B/%E8%AE%A1%E7%AE%97%E4%B8%A4%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF%E6%95%B0.png" alt=""><br>类似求传递闭包。<img src="/2024/12/17/%E5%9B%BE%E8%AE%BA%E9%A2%98%E5%9E%8B/%E8%AE%A1%E7%AE%97%E4%B8%A4%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF%E6%95%B02.png" alt=""></p><h1>10.1.3</h1>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平面图</title>
    <link href="/2024/12/10/%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
    <url>/2024/12/10/%E5%B9%B3%E9%9D%A2%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1>一、定义</h1><ul><li>如果一个图能画在平面上使得它的边仅在端点相交，则称这个图为可嵌人平面的，或称为<strong>平面图</strong>。平面图G的这样一种画法称为G的一个<strong>平面嵌人</strong>。<br><img src="/2024/12/10/%E5%B9%B3%E9%9D%A2%E5%9B%BE/%E5%B9%B3%E9%9D%A2%E5%9B%BE%E5%AE%9A%E4%B9%89.png" alt="平面图定义"></li><li>一个平图$G$把平面划分成若干个连通区域，这些区域的闭包称为$G$的<strong>面</strong>。面边界回路的长度称为<strong>面的次数</strong>，记为$Deg(f)$或$d(f)$。</li><li>每个平图恰有一个无界的面，称为<strong>外部面</strong>。</li></ul><h1>二、相关性质和定理</h1><h2 id="2-1-面的次数之和与边数关系">2.1 面的次数之和与边数关系</h2><blockquote><p>$\sum {d(f)} = 2\varepsilon$</p></blockquote><h2 id="2-2-Euler公式">2.2 Euler公式</h2><blockquote><p>若$G$是连通平图，则有：$\nu - \varepsilon + \phi = 2$</p></blockquote><blockquote><p><strong>简单平面图存在一个度数小于5的顶点</strong>；</p></blockquote><h1>三、判断方法</h1><h1>3.1 必要条件</h1><blockquote><ol><li><p>若$G$是$v \ge 3$的简单平面图，则$\varepsilon \le 3\nu - 6$。</p></li><li><p>Euler公式</p></li></ol></blockquote><h2 id="3-2-Kuratowski’s-Theorem-库拉托夫斯基定理">3.2 Kuratowski’s Theorem(库拉托夫斯基定理)</h2><blockquote><p>一个图是平面图当且仅当它不包含$K_{3,3}$或$K_5$的剖分图.</p><blockquote><p><strong>剖分图</strong>：把$G$的边进行一系列剖分得到的图<br><img src="/2024/12/10/%E5%B9%B3%E9%9D%A2%E5%9B%BE/K4%E5%89%96%E5%88%86%E5%9B%BE.png" alt="K4剖分图"><br>剖分图也可以这么理解：即用Path代替Edge。<br>把边$(u, v)$删除，添加一个点$w$，再添加两条边$(u,w)$和$(w, v)$，称之为<strong>初等细分</strong>；<br>得到的新图和原图称之为是<strong>同胚(Homeomorphic)的</strong>；</p></blockquote><blockquote><p><strong>Platonic Solids(柏拉图体)</strong>:<img src="/2024/12/10/%E5%B9%B3%E9%9D%A2%E5%9B%BE/%E6%9F%8F%E6%8B%89%E5%9B%BE%E4%BD%931.png" alt="柏拉图体1"><br><strong>顶点数、边数(棱数)、面数的关系</strong>：<br>其中，$v$表示顶点数，$e$表示棱数，$f$表示面数，$k$为每个顶点的出发边的数目，$l$为每个面上边的数目，$\sum deg(v) = 2e = fl = kv$.<img src="/2024/12/10/%E5%B9%B3%E9%9D%A2%E5%9B%BE/%E6%9F%8F%E6%8B%89%E5%9B%BE%E4%BD%932.png" alt="柏拉图体2"></p></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机导论与程序设计复习</title>
    <link href="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、程序语言概述">一、程序语言概述</h2><ul><li>可编程<img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E5%8F%AF%E7%BC%96%E7%A8%8B.png" alt=""></li><li><strong>计算机信息处理本质</strong>是: 接收输入的数据、对输入的数据进行加工和处理、产生结果并输出。</li><li>程序可以预先存储在计算机中调度运行。计算机的操作是在程序的控制下进行的。</li><li>可编程结构、图灵机都是计算机模型。</li><li>冯诺依曼机</li><li>程序的运行就是不断地取指令、分析指令、执行指令的过程，这3个步骤均由控制单元来控制。控制单元取指令、分析指令，产生操作控制信号发给输入输出设备、运算部件或者主存，完成指令的执行。</li><li><strong>指令</strong>由“0”和“1”的二进制码组成 ,是指挥计算机工作的命令，是计算机<em><strong>唯一可以直接识别</strong></em>的语言；</li><li><strong>指令系统</strong>：计算机能直接识别和执行的全部指令的集合， 称为该种计算机的指令系统。</li><li><strong>程序</strong>是按事先设计的功能和性能要求编制的指令序列。</li><li><strong>算法</strong>：完成一个任务或者解决一个问题的步骤 序列（操作序列）。</li><li><strong>符号语言</strong>：用符号或助记符来表示不同的机器语言指令(包括操作码和和操作数地址）。符号语言又称汇编语言。</li><li><strong>过程化的程序设计</strong>即是实现某一计算的操作过程和操作步骤，然后用编程语言来描述这些操作过程和步骤。</li><li><strong>程序要素</strong>：数据与运算表达式、输入输出、控制结构、子程序(函数)</li><li><strong>C编程活动</strong>：编辑程序-编译程序-链接程序-运行程序</li></ul><h2 id="二、程序设计初步：数据类型、常量、变量">二、程序设计初步：数据类型、常量、变量</h2><ul><li>最小的存储单元是<strong>位</strong>（bit）</li><li><strong>字</strong> （word）是设计计算机时运算单元给定的整数运算的数据通路的宽度。因此，计算机中每个数据的二进制位数都是固定长度的。</li><li>汉字数字化<img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E6%B1%89%E5%AD%97%E6%95%B0%E5%AD%97%E5%8C%96.png" alt=""></li><li>数据类型包括两层含义：定义了值的集合(属于该类型的数据能够<strong>取值的范围</strong>）以及能应用于这些数值上的操作集合（<strong>数据操作</strong>）。</li></ul><h2 id="三、算数运算-逻辑运算">三、算数运算/逻辑运算</h2><ul><li>C语言中默认的算术运算符的结合方向为“自左至右”,即先左后右。但是<strong>赋值运算符是右结合，即从右到左计算</strong>。</li><li><strong>命名常量</strong>：不能改写的变量(命名常量)。有些变量一旦定义并初始化,便不允许程序去改变该存储空间中的数据。例如，C语言中：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">float</span> pi = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><ul><li>小数转化为整数：<ul><li>小数四舍五入取整：(int)(2.5+0.5); (int)(-2.3-0.5);</li><li>小数向上取整：ceil函数返回大于等于参数的最小整数</li><li>小数向下取整：floor函数返回小于等于参数的最大整数</li></ul></li><li>逻辑非运算最高，然后是算术运算和关系运算，其他逻辑运算的优先级仅高于赋值运算。<strong>逻辑运算的结合性默认是左结合，只有非运算是右结合</strong>。<img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt=""></li><li>发生意外或错误，程序无法继续处理时，需要终止，操作系统提供了exit()函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">功 能: 关闭所有文件，终止正在执行的进程。</span><br><span class="hljs-comment">exit(0)表示正常退出；</span><br><span class="hljs-comment">exit(x)（x不为0）都表示异常退出，这个x是返回给操作系统的，以供其他程序使用；</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>; <span class="hljs-comment">// 参数status，程序退出的返回值</span><br></code></pre></td></tr></table></figure><ul><li>注意++和—有前缀和后缀的区别：<ul><li>++i，–i(在使用ｉ之前,先使 i 的值加(减)１)</li><li>i++，i–(在使用ｉ之后,使ｉ的值加(减)１)</li></ul></li></ul><h2 id="四、有限自动状态机">四、有限自动状态机</h2><ul><li>有限状态机可以简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。<ul><li>状态：存储关于过去的信息，它反映从系  统开始到现在时刻的输入变化。</li><li>转移:指示状态变更，并且用必须满足来  确使转移发生的条件来描述它。</li><li>动作:在给定时刻要进行的活动的描述。</li></ul></li></ul><h2 id="五、子程序">五、子程序</h2><ul><li>子程序是封装并给以命名的一段程序代码，这段程序代码完成子程序所定义的功能，可供调用。</li><li>封装：子程序可以独立完成功能，调用者只需知道如何调用子程序（即子程序接口）</li><li>引入子程序的目的：</li></ul><ol><li>程序&quot;复用&quot;，避免在程序中使用重复代码；</li><li>结构化程序设计的需要：自顶向下、逐步细化，将复杂问题分解为相对简单的子问题，这些子问题用子程序实现，从而提高主程序结构的清晰性和易读性。</li><li>使程序的调试和 维护变得更加容易。</li></ol><ul><li>子程序设计原则<ul><li>高内聚：功能相对独立和完整；</li><li>低耦合：与外界（调用者）的关系尽量松散，不要太紧密，使其能方便地被重用；</li></ul></li><li>子程序在C语言中的实现机制：C语言中的函数机制</li><li>return语句中返回值表达式的类型要和返回值的类型说明一致。如果不一致，则以<strong>返回值类型</strong>为准(进行类型转换，参数类型的转换有可能是低类型向高类型转换，也可能是高类型向低类型转换。高类型向低类型转换可能会导致不正确的结果（如long类型向short类型的转换）。)。<br><img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E9%94%99%E8%AF%AF.png" alt=""><br><img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E9%94%99%E8%AF%AF2.png" alt=""></li><li>函数的调用：函数的调用和执行的实质是<strong>控制转移</strong>，调用函数时，将控制转到被调用的函数，被调函数执行结束时，则将控制转回主调函数，继续执行后续的操作 。</li><li>子程序参数传递两种方式：<strong>按值传递</strong>和<strong>按引用传递</strong>。</li><li>函数原型的作用：是对被调用函数的<strong>接口声明</strong>，它告诉编译器函数返回的数据类型、函数所要接收的参数个数、参数类型和参数顺序，编译器用函数原型校验函数调用是否正确。</li><li>数据在内存中的存储：<ul><li>系统区：用于存放系统软件和运行需要的数据，如操作系统。只要机器一运行，这部分空间就必须保留给系统软件使用</li><li>用户程序代码区：存放用户程序代码</li><li>静态存储区：存放程序运行期间不释放的数据（静态局部变量、全局变量）</li><li>栈区：存放程序运行期间会被释放的数据（函数参数、非静态局部变量）以及活动的控制信息</li><li>堆区：用户可以在程序运行过程中根据需要动态地进行存储空间的分配，这样的分配在堆区进行<br><img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.png" alt=""></li></ul></li></ul><p><img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E5%87%BD%E6%95%B0%E7%9A%84%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95.png" alt=""></p><h2 id="六、数组">六、数组</h2><ul><li>线性表是具有相同数据类型的$n(n&gt;=0)$个数据元素的有限序列。线性表数据元素之间为线性关系，即任意两个元素之间都可比较大小。</li><li>线性表有两种存储结构：连续（顺序表）、随机（链表）。</li><li>数组初始化是在编译阶段进行的。这样将减少运行时间，提高效率。</li><li>若在定义一个数组的同时赋初值，如果初始化值的个数小于数组元素的个数，剩余的元素被自动初始化为0。(整型数组各元素不会自动初始化为0，至少要把第一个数组元素初始化为0，才能使剩下的元素自动初始化为0。)</li><li>二维数组做形参，第2个下标必须给出，使编译器能确定元素内存地址；多维数组做函数形参时，需要给出除了第1个下标之外的其他所有的下标<img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.png" alt=""></li></ul><h2 id="七、字符串">七、字符串</h2><ul><li>scanf函数读取用户键入的字符到字符数组，直到遇到空格、回车、或文件结束符为止。空格、回车、或文件结束符被丢弃，最后一个字符读入后往字符数组中写入结束符‘\0’。</li><li>gets()函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，存储其余字符，并在这些字符的末尾添加一个空字符使其成为一个C字符串。它经常和puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。成功则返回所读字符串指针，失败返回空指针.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> * <span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span> * str)</span>;<br></code></pre></td></tr></table></figure><ul><li>将str所指向的字符串输出到文件或显示器上，字符串结束标记‘\0’ 不会被输出。成功则返回字符长度，失败返回-1。puts输出字符串时，会将字符数组中所有内容输出，直到‘\0’，但会在末尾自动追加输出‘\n’ 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str)</span>;<br></code></pre></td></tr></table></figure><ul><li>fgets从文件或键盘读取字符到str所指向的数组中，直到<strong>读够n-1个字符</strong>，或读到换行符‘\n’ ，但<strong>不会丢弃换行符</strong>，或者读到文件末尾。最后一个字符读入后自动写入一个 ‘\0’ 。若成功则返回str，若无字符读入数组或者读取失败返回空指针NULL。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> * <span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">int</span> n, FILE *stream)</span>;<br></code></pre></td></tr></table></figure><ul><li>将str所指向的字符串输出到文件或显示器上，字符串结束标记‘\0’ 不会被输出。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * str, FILE *stream)</span>;<br></code></pre></td></tr></table></figure><h1>八、自定义结构体</h1><ul><li>结构是用其他类型的对象构造出来的派生数据类型（注意：结构是一种数据类型）；</li><li>结构既可以在函数外定义，也可以在函数内定义。但函数内定义的结构只能在本函数中使用；</li><li>同一结构中的成员不能同名，不同结构中的成员可以同名；</li><li>嵌套结构：结构中的数据项，可以是另一个已经定义的结构变量；</li><li>如果初始化的个数少于结构中的成员数目，剩余成员被自动化初始为0（整型、浮点型）、‘\0’（字符或者字符串型）、NULL（指针）；<br><img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt=""></li><li>传递结构变量方法：传递结构、还是指向结构的指针？<ul><li>传递指针<ul><li>优点：既可以工作在较早的C实现上，也可以工作在较新的C实现上；执行速度快：只需要传递一个地址。</li><li>缺点：缺少对数据的保护（可以使用const限定词解决这个问题）。</li></ul></li><li>传递结构：</li><li>优点：安全性。函数处理的是原始数据的副本。</li><li>缺点： 早期的C实现不处理这种代码，浪费时间和空间；</li></ul></li></ul><h1>九、计算机原理</h1><ul><li>计算的定义：<ul><li>以数字为基础、遵循一定的计算规则进行; 如：数的加减乘除，函数的微分、积分、方程的求解、定理的证明推导;</li><li>广义：计算就是把一个符号串f变换成另一个符号串g；</li><li>更广义：计算就是对信息的变换 ；</li><li>由于计算规则的机械化、公式化，可以借助计算工具来实现计算。</li></ul></li><li>图灵机：<img src="/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/%E5%9B%BE%E7%81%B5%E6%9C%BA.png" alt=""></li><li>图灵机模型被认为是计算机的基本理论模型：计算机是使用相应的程序来完成任何设定好的任务。图灵机是一种<strong>离散的、有穷的、构造性</strong>的问题求解思路，一个问题的求解可以通过构造其图灵机(即程序)来解决。图灵认为：凡是能用算法方法解决的问题也一定能用图灵机解决; 凡是图灵机解决不了的问题任何算法也解决不了----图灵可计算性问题。</li><li>巴贝奇的分析机由四部分构成：<ul><li>第一部分：保存数据的齿轮式&quot;存贮仓库&quot;(Store)；</li><li>第二部分：对数据进行各种运算的装置(“作坊”)；</li><li>第三部分：对操作顺序进行控制、并对所要处理的数据及输出结果加以选择的装置；</li><li>第四部分：送入和取出数据、以及在&quot;存贮仓库&quot;和&quot;作坊&quot;之间运输数据的输入输出部件。</li><li>分析机工作过程：通过输入部件将要处理的数据输入并存储到&quot;存储仓库&quot;中，在控制装置控制下，从存储仓库依次取出数据运输到运算装置进行运算，最终运算结果由输出部件进行输出。</li></ul></li><li>冯.诺依曼机体系结构的特点：<ul><li>指令和数据采用二进制表示，从而简化机器的逻辑线路；－－指令和数据的表示</li><li>指令和数据一样存储在主存储器中；－－指令和数据的存储</li><li>计算机由运算器、控制器、存储器、输入设备、输出设备五大部分组成。</li></ul></li><li>程序的运行就是不断地<strong>取指令、分析指令、执行指令</strong>的过程，这3个步骤均由控制器来控制。控制器取指令、分析指令，产生操作控制信号发给输入输出设备、运算部件或者主存，完成指令的执行。</li><li>计算机系统由硬件和软件两大部分组成；</li><li>操作系统是最基本、最重要的系统软件，直接运行在<strong>裸机（硬件）</strong> 上，只有在操作系统的支持下，才可以运行其他软件，故操作系统是计算机软件的核心和基础。</li><li>操作系统的基本功能：<strong>作业管理、进程管理、内存管理、设备管理、文件管理</strong>；</li><li>进程是一个<strong>具有一定独立功能的程序关于某个数据集合的一次运行活动</strong>。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li><li>程序与进程的关系<ul><li>进程是动态的，强调执行过程，而程序是静态的；</li><li>进程具有并发性(宏观上同时运行)，程序没有；</li><li>不同的进程可以对应同一程序，只是该程序对应的数据集不同。</li></ul></li><li>进程状态转换：<ol><li>运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。</li><li>就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。</li><li>阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</li></ol></li></ul><h1>汇总简答题</h1><ol><li><strong>什么是计算？</strong><ul><li>以数字为基础、遵循一定的计算规则进行；如：数的加减乘除，函数的微分、积分、方程的求解、定理的证明推导；</li><li>广义：计算就是把一个符号串f变换成另一个符号串g；</li><li>更广义：计算就是对信息的变换；</li></ul></li><li><strong>什么是冯诺依曼结构？</strong><ul><li>冯诺依曼结构是一种计算机设计模型，其核心思想是将数据和程序存储在同一存储器中，并通过控制器统一管理。其组成包括：<ul><li>输入设备</li><li>输出设备</li><li>控制器</li><li>运算器</li><li>存储器</li></ul></li></ul></li><li><strong>什么是内存？什么是外存？两者的区别是什么？</strong><ul><li><strong>内存</strong>：存储程序和数据的高速存储设备，直接与CPU交互，断电后数据丢失。</li><li><strong>外存</strong>：如硬盘、U盘，用于长期存储数据，断电后数据不会丢失。</li><li><strong>区别</strong>：内存速度快但容量小；外存容量大但速度慢。</li></ul></li><li><strong>什么是指令？什么是指令系统？什么是程序？</strong><ul><li><strong>指令</strong>：由“0”和“1”的二进制码组成 ,是指挥计算机工作的命令，是计算机<em><strong>唯一可以直接识别</strong></em>的语言；</li><li><strong>指令系统</strong>：计算机能直接识别和执行的全部指令的集合， 称为该种计算机的指令系统。</li><li><strong>程序</strong>：<strong>程序</strong>是按事先设计的功能和性能要求编制的指令序列。</li></ul></li><li><strong>简述计算机的组成结构与工作原理。</strong><ul><li><strong>组成结构</strong>：包括输入设备、输出设备、存储器、运算器、控制器。</li><li><strong>工作原理</strong>：通过输入设备获取数据，存储器存储数据和程序，控制器按照指令系统控制运算器完成数据处理，结果通过输出设备输出。</li></ul></li><li><strong>计算机系统由哪两大部分组成？</strong><ul><li><strong>硬件系统</strong>：如CPU、内存、硬盘等。</li><li><strong>软件系统</strong>：如操作系统、应用程序等。</li></ul></li><li><strong>什么是操作系统？它具有哪些管理功能？</strong><ul><li><strong>操作系统</strong>：管理计算机硬件与软件资源的系统软件，提供用户与计算机交互的接口。</li><li><strong>管理功能</strong>：<ol><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>设备管理</li><li>作业管理</li></ol></li></ul></li><li><strong>什么是机器语言、符号语言和高级语言？它们各自有什么特点？</strong><ul><li><strong>机器语言</strong>：由0和1组成的二进制代码，可直接被计算机识别；执行效率高但难以编写和理解。</li><li><strong>符号语言</strong>：使用助记符（如MOV、ADD）代替机器码，通过汇编程序翻译成机器语言；较容易理解。</li><li><strong>高级语言</strong>：接近自然语言，易读易写，通过编译或解释器转换成机器语言；跨平台且开发效率高。</li></ul></li><li><strong>计算机唯一可以直接识别的是什么语言？</strong><ul><li>计算机唯一可以直接识别的是<strong>机器语言</strong>。</li></ul></li><li><strong>简述预处理程序和翻译程序各自的功能。</strong><ul><li><strong>预处理程序</strong>：处理源代码中的指令（如宏定义、头文件引入），生成预处理后的代码。</li><li><strong>翻译程序</strong>：将源代码翻译为机器语言，生成目标文件。</li></ul></li><li><strong>链接程序的目的是什么？</strong><ul><li>链接程序的目的在于将多个目标文件和库文件连接成一个可执行文件，同时解决跨文件函数调用和变量引用的问题。</li></ul></li><li><strong>载入程序的功能是什么？</strong><ul><li>载入程序负责将可执行文件从外存加载到内存，并为其分配运行所需的资源，使程序可以被CPU执行。</li></ul></li><li><strong>程序是如何运行的？</strong><ul><li>程序的运行就是不断地<strong>取指令、分析指令、执行指令</strong>的过程，这3个步骤均由控制单元来控制。控制单元取指令、分析指令，产生操作控制信号发给输入输出设备、运算部件或者主存，完成指令的执行。</li></ul></li><li><strong>什么是标识符？</strong><ul><li>标识符是程序中用来标识变量、常量、函数、数组等名称的字符序列。</li></ul></li><li><strong>什么是常量？使用命名常量和符号常量有哪些好处？</strong><ul><li><strong>常量</strong>：程序中值固定不变的量，例如数字3.14或字符’A’。</li><li><strong>好处</strong>：<ol><li>增强代码的可读性，例如PI比3.14更具意义。</li><li>方便修改，只需更改定义处即可在全局生效。</li><li>避免代码中出现“魔法数”（即难以理解的硬编码值）。</li></ol></li></ul></li><li><strong>什么是函数？</strong><ul><li>函数是一个具有特定功能的代码块，用于完成某种任务。它通过调用来执行，可以提高代码的复用性和可读性。</li></ul></li><li><strong>函数声明的作用是什么？</strong><ul><li>函数声明（也称为函数原型）用于向编译器声明函数的名称、返回类型和参数类型，使编译器在函数调用时能进行正确的检查。</li></ul></li><li><strong>函数定义包括哪几部分内容？</strong><ul><li>函数定义通常包括以下部分：<ol><li><strong>返回类型</strong>：函数执行完后返回的值的类型，例如int、float。</li><li><strong>函数名</strong>：用于标识函数的名称，例如add。</li><li><strong>参数列表</strong>：函数接收的输入参数，包含类型和变量名，例如int a, int b。</li><li><strong>函数体</strong>：包含具体实现功能的代码块，用{}括起来。</li></ol></li></ul></li><li><strong>什么是算法?</strong></li><li><strong>结构化程序设计的主要内容是？</strong><ol><li><strong>程序控制结构：</strong><ul><li><strong>顺序结构</strong>：程序按照语句的书写顺序依次执行。</li><li><strong>选择结构</strong>：根据条件判断选择执行某一分支（如if-else、switch-case）。</li><li><strong>循环结构</strong>：重复执行某一代码块，直到满足特定条件（如for、while、do-while）。</li></ul></li><li><strong>模块化设计：</strong><ul><li>将程序划分为若干功能模块，每个模块完成一个独立的功能。</li><li>模块之间通过函数接口进行通信，减少相互依赖。</li></ul></li><li><strong>自顶向下设计：</strong><ul><li>从问题的整体出发，逐步细化，依次设计各子模块，最终实现整个程序。</li></ul></li><li><strong>封装与复用：</strong><ul><li>每个模块应具有独立性，其内部实现细节对外部隐藏，只通过定义好的接口与其他模块交互。</li><li>提高代码复用性，减少重复开发。</li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉环游和哈密尔顿环游</title>
    <link href="/2024/12/06/%E6%AC%A7%E6%8B%89%E7%8E%AF%E6%B8%B8%E5%92%8C%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E7%8E%AF%E6%B8%B8/"/>
    <url>/2024/12/06/%E6%AC%A7%E6%8B%89%E7%8E%AF%E6%B8%B8%E5%92%8C%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E7%8E%AF%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1>欧拉环游</h1><h2 id="定义">定义</h2><blockquote><p><strong>欧拉回路</strong>：我们称一个通过图的每条边恰好一次的闭途径为欧拉环游 (Eulertour)；<br><strong>欧拉通路</strong>：我们称一个通过图的每条边恰好一次的路为欧拉通路；<br><strong>欧拉图</strong>：如果一个图包含一个欧拉环游，就称它是欧拉的(Eulerian)；</p></blockquote><h2 id="判断的充要条件">判断的充要条件</h2><blockquote><p>对于无向连通图，一个连通图是欧拉的<strong>当且仅当它的每个顶点度是偶数</strong>。<br>连通图$G$是存在从$a$到$b$的欧拉路径，当且仅当$G$是连通的，并且除$a$和$b$($a \ne b$)的度为奇数(odd)之外，没有度为奇数(odd)的顶点；</p></blockquote><blockquote><p>对于有向连通图，一个连通图是欧拉的当且仅当$G$是连通的，且每个顶点的出度 = 入度；<br>有向连通图$G$含有欧拉通路，当且仅当$G$是连通的，并且$G$中除两个顶点(节点不相等)外，其余每个顶点的入度=出度，且此两点满足$\left |deg^+{(u)} - deg^-{(v)}\right | = 1$</p></blockquote><h1>哈密尔顿通路</h1><h2 id="定义-2">定义</h2><blockquote><p><strong>哈密尔顿回路</strong>：图$G$的哈密顿回路(Hamiltonian circuit)指的是遍历$G$中每一个点且只遍历一次的回路, 这样的轨迹称为哈密顿环游(Hamiltonian tour)；<br><strong>哈密尔顿通路</strong>：1. 图G的哈密顿路径(Hamiltonian path)指的是遍历G中每一个点且只遍历一次的路径, 这样的轨迹称为哈密顿轨迹(Hamiltonian trail)；</p></blockquote><h2 id="一些充分条件">一些充分条件</h2><h3 id="Dirac’s-theorem狄拉克定理">Dirac’s theorem狄拉克定理</h3><blockquote><p>对于简单连通图$G$，如果$G$的顶点数$n \ge 3$，且所有顶点的度都$\ge \frac{n}{2}$，那么$G$存在哈密尔顿回路；</p></blockquote><h3 id="Ore’s-theorem欧尔定理">Ore’s theorem欧尔定理</h3><blockquote><p>对于简单连通图$G$，如果$G$的顶点数$n \ge 3$，且对于每一对不相邻的顶点$u, v$，都有$deg(u) + deg(v) \ge n$，那么$G$存在哈密尔顿回路；</p></blockquote><h2 id="必要条件-可以用来判断不是哈密尔顿通路">必要条件(可以用来判断不是哈密尔顿通路)</h2><blockquote><p>设无向图$G = (V,E)$，非空子集$V_1 \subset V$，则$P(G - V_1)\le \left | V_1 \right |$，其中$p(G - V_1)$为图$G$删除$V_1$中的节点后的连通分支数；</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论基本概念</title>
    <link href="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1>图论中的基本概念</h1><h2 id="图的基本概念">图的基本概念</h2><ul><li><strong>图</strong>：具有顶点集$V$的图亦称为$V$上的图(a graph on V)，图$G$的顶点集记为$V(G)$, 边集记为$E(G)$；</li><li><strong>邻接Adjacency</strong>：如果${x,y}$是$G$的一条边，则称两个顶点$x$和$y$是相邻的(adjacent)或邻点 (neighbour)，$x,y$称为边的endpoint；如果两条边$e \ne f$有一个公共端点，则称$e$和$f$是相邻的；</li><li><strong>领域、邻点集Neiborhood</strong>：The set of all neighbors of a vertex $v$ of $G = (V,E)$, denoted by $N(v)$, is called the neighborhood of $v$. 即顶点$v$的所有邻点构成的集合。If $A$ is a subset of $V$ , we denote by $N(A)$ the set of all vertices in G that are adjacent to at least one vertex in $A$. So,$N(A)=\bigcup_{\nu\in A}N(\nu)$.</li><li><strong>度</strong>：A vertex with degree $0$ is called isolated.(孤立点); A vertex of degree $1$ is called pendant.(悬挂点);</li><li><strong>生成子图Spanning subgraph</strong>：删边不删点；</li><li><strong>导出子图Induced subgraph</strong>：若$G’ \subset G$且$G’$包含了$E$中所有满足$x,y \in E$的边$xy$,则称$Q$是$G$的导出子图(induced subgraph)；（人话，删点不删边）；</li><li><strong>图的收缩The contraction of G</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E5%9B%BE%E7%9A%84%E6%94%B6%E7%BC%A9.png" alt=""></li><li><strong>补图Graph complement</strong>：相对于完全图的补<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E8%A1%A5%E5%9B%BE.png" alt=""></li><li><strong>关联矩阵Incidence matrices</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E5%85%B3%E8%81%94%E7%9F%A9%E9%98%B5.png" alt="">即第$i$行表示第$i$个顶点与哪些边连接，第$j$列表示第$j$条边连接哪些顶点。</li></ul><blockquote><p><strong>握手定理Handshaking Theorem</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%8F%A1%E6%89%8B%E5%AE%9A%E7%90%86.png" alt=""><br>无向图中，如果有度为奇数的点，那么这些点的个数必为偶数个。</p></blockquote><ul><li><strong>有向图的度</strong>：The in-degree of $v$, $deg^- (v)$, is the number of edges going to $v$(入度); The out-degree of $v$, $deg^+ (v)$, is the number of edges coming from $v$(出度); The degree of $v$, $deg(v):deg^-(v)+deg^+ (v)$, is the sum of v’s in-degree and out-degree.</li></ul><blockquote><p><strong>有向图握手定理</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%9C%89%E5%90%91%E5%9B%BE%E6%8F%A1%E6%89%8B%E5%AE%9A%E7%90%86.png" alt=""></p></blockquote><ul><li><strong>阶</strong>：一个图的顶点个数称为它的阶(order),记为$\left | G \right |$，它的边数记为$\Vert G \Vert$；</li><li><strong>平凡图</strong>：阶为0或1的图称为平凡的 (trivial)；</li><li><strong>独立</strong>：互不相邻的顶点/边称独立顶点/独立边(independent vertex/edge)。若一个顶点集或边集中没有两个元素是相邻的，则该集合称为<strong>独立集</strong>(independent set)；独立的顶点集也称作<strong>稳定集</strong>(stable set)；</li></ul><h2 id="一些特殊的图结构Special-Graph-Structures">一些特殊的图结构Special Graph Structures</h2><ul><li><strong>完全图$K^n$</strong>：若$G$的所有顶点都是两两相邻的，则称$G$是完全的(complete)，n个顶点的完全图记为$K^n$；<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E5%AE%8C%E5%85%A8%E5%9B%BE.png" alt=""></li><li><strong>环图$C^n$</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E7%8E%AF%E5%9B%BE.png" alt=""></li><li><strong>轮图$W^n$</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E8%BD%AE%E5%9B%BE.png" alt="">$W^n$有$n+1$个顶点，中心点度为$n-1$，边上$n$个点度为$3$。</li><li><strong>n维体图 n-Cubes/hypercubes$Q^n$</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/n%E7%BB%B4%E4%BD%93%E5%9B%BE.png" alt=""></li><li><strong>Plato graphs（柏拉图图）</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E6%9F%8F%E6%8B%89%E5%9B%BE%E5%9B%BE.png" alt=""></li><li><strong>彼德森图（Petersen）</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E5%BD%BC%E5%BE%97%E6%A3%AE%E5%9B%BE.png" alt=""></li><li><strong>Bipartite Graphs二分图</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E4%BA%8C%E5%88%86%E5%9B%BE.png" alt="">判断方法：1. 可以用两种颜色染色； 2. 图中不存在长度为奇数的回路；</li><li><strong>Complete Bipartite Graphs 完全二分图</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%88%86%E5%9B%BE.png" alt=""></li></ul><h2 id="图的同构Graph-Isomorphism">图的同构Graph Isomorphism</h2><ul><li><strong>图的同构</strong>：<img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E5%9B%BE%E7%9A%84%E5%90%8C%E6%9E%84.png" alt=""></li><li></li><li><strong>图不变量graph invariants</strong>：对于图上的一个映射，如果对每个同构图它均取相同的值，则这样的映射称为一个图不变量(graph invariant)。一个图的顶点数和边数就是两个简单的图不变量；图中两两相邻的最大顶点数也是图不变量。</li></ul><h2 id="图的连通性Connectivity">图的连通性Connectivity</h2><ul><li><strong>路</strong>：这里所有的$x_i$均互不相同，顶点$x_0和$$x_n$由路$P$连接(link)，并称它们为路的端点(endvertex)或顶端(end)；而$x_1,x_2,\dots,x_{n-1}$称为$P$的内部(inner)顶点。一条路上的边数称为路的长度(length)，长度为k的路记为$P^k$；</li><li><strong>简单路</strong>：A path is simple if it contains no edge more  than once.</li><li><strong>独立路</strong>：如果其中任意一条路不包含另一条路的内部顶点, 则称它们是独立路(independent path)；</li><li><strong>连通图</strong>：如果非空图$G$中的任意两个顶点之间均有一条路相连，我们称$G$是连通的(connected)；</li><li><strong>连通分支/独立子图Connected component</strong>：设$G = (V,E)$是一个图，则它的极大连通子图称为分支(component)；</li><li><strong>割点cut vertex</strong>：the removal from a graph of a vertex and all incident edges produces a subgraph with  more connected components.</li><li><strong>割边cut edge</strong>：an edge whose removal produces a graph with more connected components；</li><li><strong>点连通度</strong>：使得G是k-连通的最大整数k称为G的连通度(connectivity)，并记为$\kappa (G)$；</li><li><strong>边连通度</strong>：记为$\lambda(G)$；<br><img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E8%BF%9E%E9%80%9A%E5%BA%A6%E4%BE%8B%E5%AD%90.png" alt=""><br><img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E8%BF%9E%E9%80%9A%E5%BA%A6%E5%AE%9A%E7%90%86.png" alt=""></li><li><strong>有向图中的强连通、弱连通</strong>：强连通要求A directed graph is strongly connected if there is a path from a to b and  from b to a whenever a and b are  vertices in the graph. 弱连通与无向图类似；</li><li><strong>圈</strong>：$x_0x_1\dots x_{k-1}x_0$；</li><li><strong>围长和圈长</strong>：图$G$中最短圈的长度叫做围长(girth),记为$g(G)$,而$G$中最长圈的长度称为周长(circumference)；</li><li><strong>弦</strong>：图中不在圈上但连接圈中两个顶点的边称为这个圈的弦(chord)；</li><li><strong>导出圈</strong>：$G$的导出圈(induced cycle)是不含弦的圈，即$G$的导出子图是个圈；<br><img src="/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/%E5%AF%BC%E5%87%BA%E5%9C%88.png" alt="导出圈"></li><li><strong>距离、直径、中心点、半径</strong>：暂略；</li><li><strong>树、森林</strong>：暂略；</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU Bomb Lab 个人题解</title>
    <link href="/2024/11/05/BombLab/"/>
    <url>/2024/11/05/BombLab/</url>
    
    <content type="html"><![CDATA[<h2 id="一、实验目的">一、实验目的</h2><p>1.理解C语言程序的机器级表示。</p><p>2.初步掌握GDB调试器的用法。</p><p>3.阅读C编译器生成的x86-64机器代码，理解不同控制结构生成的基本指令模式，过程的实现。</p><h2 id="二、实验环境">二、实验环境</h2><ol><li>作业服务器</li><li>MacOS终端工具</li><li>Linux</li><li>Objdump命令反汇编</li><li>GDB调试工具</li><li>积分榜</li></ol><h2 id="三、实验内容">三、实验内容</h2><p>登录作业服务器，在home目录下可以找到Evil博士专门为你量身定制的一个bomb，当运行时，它会要求你输入一个字符串，如果正确，则进入下一关，继续要求你输入下一个字符串；否则，炸弹就会爆炸，输出一行提示信息并向计分服务器提交扣分信息。因此，本实验要求你必须通过反汇编和逆向工程对bomb执行文件进行分析，找到正确的字符串来解除这个的炸弹。</p><p>本实验通过要求使用课程所学知识拆除一个“binary bombs”来增强对程序的机器级表示、汇编语言、调试器和逆向工程等方面原理与技能的掌握。 “binary bombs”是一个Linux可执行程序，包含了5个阶段（或关卡）。炸弹运行的每个阶段要求你输入一个特定字符串，你的输入符合程序预期的输入，该阶段的炸弹就被拆除引信；否则炸弹“爆炸”，打印输出 “BOOM!!!”。炸弹的每个阶段考察了机器级程序语言的一个不同方面，难度逐级递增。</p><p>为完成二进制炸弹拆除任务，需要使用gdb调试器和objdump来反汇编bomb文件，可以单步跟踪调试每一阶段的机器代码，也可以阅读反汇编代码，从中理解每一汇编语言代码的行为或作用，进而设法推断拆除炸弹所需的目标字符串。</p><h2 id="四、实验步骤及实验分析">四、实验步骤及实验分析</h2><h3 id="准备工作">准备工作</h3><ul><li>首先通过 <code>ls</code> 命令查看文件，找到炸弹文件包 <code>bomb. tar</code>；</li><li>然后通过命令 <code>tar -xvf bomb.tar</code> 解压得到三个文件；</li></ul><h3 id="第一阶段">第一阶段</h3><ul><li>使用 <code>gdb</code> 运行<code>bomb</code>；</li><li>设置断点在函数 <code>phase_1</code> 处，开始运行，输入测试字符串<code>12345</code>；</li><li>用<code> \disas</code> 显示<code> phase_1</code> 部分的汇编代码开始分析；</li></ul><p><img src="/2024/11/05/BombLab/1.png" alt="phase_1汇编代码"></p><ul><li>观察到调用了一个 <code>strings_not_equal</code> 函数，根据函数名，其功能很可能是比较输入字符和正确字符是否匹配的函数；</li><li>在<code>strings_not_equal</code> 函数处设置断点，直接<code>continue</code>运行进入该函数；</li><li>显示<code>strings_not_equal</code> 的汇编代码开始分析；</li></ul><p><img src="/2024/11/05/BombLab/2.png" alt="strings_not_equal 函数汇编代码"></p><p><strong>Note! <code>%rdi</code> 存放函数的第一个输入，<code>%rsi</code> 存放函数的第二个输入，<code>%eax</code> 存放函数的返回值。</strong></p><ul><li>观察到调用了 <code>string_length</code> 函数，根据函数名，其功能很可能是获取输入字符数量的函数；</li><li>在 <code>string_length</code> 函数处设置断点，直接<code>continue</code>运行进入该函数；</li><li>分析可得其先比较字符串长度，二者不相等则在 <code>%eax</code> 中存 1 返回；若相等，则比较具体内容，若不相等则在 <code>%eax</code> 中存 1 返回；</li><li>结合寄存器功能和汇编代码可以得到函数比较的字符串内容分别存放在 <code>%rdi</code> 和 <code>%rsi</code> 中，分别打印寄存器的值如下：</li></ul><p><img src="/2024/11/05/BombLab/3.png" alt="字符串内容"></p><ul><li>得到 <code>%rdi</code> 存放的是我们输入的字符串， <code>%rsi</code> 是目标字符串。函数中，<code>%rsi</code> 的值被赋给 <code>%rbp</code>， <code>%rbp</code> 和 <code>%rdi</code> 上的字符串进行比较。所以 <code>phase_1</code> 需要我们输入与其相同的字符串即可通过。</li></ul><h3 id="第二阶段">第二阶段</h3><ul><li>在 <code>phase_2</code> 入口处设置断点，运行程序，输入 <code>phase_1</code> 答案，进入阶段 2；同上操作得到汇编代码进行分析；</li></ul><p><img src="/2024/11/05/BombLab/4.png" alt="第二阶段开始"></p><ul><li>观察发现其调用<code>read_six_numbers</code>函数，设置断点进入，显示该函数的汇编代码，观察到将地址<code>$0x402a31</code>存入 <code>%esi</code> 后调用 <code>scanf</code> 函数，打印该地址的值，验证了该函数的需要输入6个整数。也可以由下面的 <code>cmp</code> 语句得到，如果<code>scanf</code> 的返回值小于等于5会触发爆炸。</li></ul><p><img src="/2024/11/05/BombLab/5.png" alt="第二阶段输入格式确定"></p><p><strong>Note! <code>%rsp</code> 存放堆栈指针，括号表示获取地址上的值。<code>%rbp</code> 存放的是栈的基址。</strong></p><ul><li>继续回到 <code>phase_2</code>，由 <code>cmpl</code> 语句可见第一个输入的整数(<code>%rsp</code>存的地址上的值)需要 &gt;= 1，将其存放到 <code>%eax</code> 上，并将其变为2倍后继续存在 <code>%eax</code>，再与输入的第二个整数比较，要求结果相等，否则触发爆炸。然后检查当前栈指针是否到达栈的基址<code>%rbp</code>，如果顺利到达则跳出，成功通过。</li><li>可以推测出 <code>phase_2</code> 是一种循环结构，依次比较每个输入整数是否符合是前一个输入的2倍，推出一个答案为<code>1 2 4 8 16 32</code>。</li></ul><h3 id="第三阶段">第三阶段</h3><ul><li>同上操作，此处不再赘述，进入<code>phase_3</code>并得到汇编代码如下：</li></ul><p><img src="/2024/11/05/BombLab/6.png" alt="第三阶段汇编代码1"></p><p><img src="/2024/11/05/BombLab/7.png" alt="第三阶段汇编代码2"></p><ul><li>第三阶段代码较为冗长，先通过打印 <code>scanf</code> 函数的调用值得到输入格式为两个整数和一个字符。</li></ul><p><img src="/2024/11/05/BombLab/8.png" alt="第三阶段输入格式"></p><ul><li>分析在 <code>0x400fe4</code> 处的 <code>cmpl $0x7, 0x10(%rsp)</code> 指令以及下一条指令 <code>ja 0x4010ef</code> ，得出<code>0x10(%rsp)</code> 处的值，即输入的第一个整数（占 2<sup>4</sup> = 0x10 个字节） ≤  7。</li><li><code>0x400ff3</code> 处的指令 <code>jmpq \*0x4027a0(,%rax,8)</code> 表示跳转到 <code>0x4027a0+输入的第一个整数 *8</code> 所存储的地址处，打印出所有可能的跳转地址如下：</li></ul><p><img src="/2024/11/05/BombLab/9.png" alt="所有可能地址"></p><p><strong>Note！<code>*</code> 表示间接跳转，<code>0x4027a0</code> 是一个基地址（立即数），语句应跳转到计算得到的地址上存的地址值。</strong></p><ul><li>此时，再结合 <code>phase_3</code> 整体代码，进行拆分，可以推测其为 <code>switch</code> 分支结构，选择 <code>case 0</code> 进行分析。（每个case结构都基本相同）：</li></ul><p><img src="/2024/11/05/BombLab/10.png" alt="case 0结构"></p><ul><li>分析可得，首先比较输入的第二个整数与<code>0x2d7（727）</code>，相等则跳至 <code>4010eb &lt;+318&gt;:cmp 0xf(%rsp),%al</code>，将输入的字符与 <code>%al (0x77)</code>，对应 ASCII 码 <code>w</code>比较，相等则通过。</li></ul><p><strong>Note！<code>%al</code> 和 <code>%eax</code> 为同一个寄存器，<code>%al</code> 是 <code>%rax</code> 寄存器的最低 8 位。<code>%eax</code> 是低 32 位。</strong></p><ul><li>以此类推，得到所有可能答案如下：</li></ul><table><thead><tr><th style="text-align:center"><strong>第一个整数</strong></th><th style="text-align:center"><strong>字符</strong></th><th style="text-align:center"><strong>第二个整数</strong></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">w</td><td style="text-align:center">727</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">u</td><td style="text-align:center">786</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">g</td><td style="text-align:center">63</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">f</td><td style="text-align:center">363</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">s</td><td style="text-align:center">117</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">d</td><td style="text-align:center">602</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">q</td><td style="text-align:center">818</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">e</td><td style="text-align:center">197</td></tr></tbody></table><h3 id="第四阶段">第四阶段</h3><ul><li>同上操作，此处不再赘述，进入 phase_4 并得到汇编代码如下。</li></ul><p><img src="/2024/11/05/BombLab/11.png" alt="第四阶段汇编代码"></p><ul><li>先通过打印 <code>scanf</code> 函数的调用值得到输入格式为两个整数。</li></ul><p><img src="/2024/11/05/BombLab/12.png" alt="第四阶段输入格式"></p><ul><li>发现 <code>phase_4</code> 调用了 <code>func4</code>函数，在这之前，先检查了输入是否为2个整数，再将第二个输入的整数赋给 <code>%eax</code>，减2后和2比较大小，如果小于等于2则继续。得到第二个整数 &lt;= 4。</li><li>在进入函数之前，观察得到 <code>%esi</code>（第二个输入的整数）和 <code>%rdi (8)</code>作为参数被传入 <code>func4</code>。</li><li>进入函数，打印其汇编代码如下：</li></ul><p><img src="/2024/11/05/BombLab/13.png" alt="func4汇编代码"></p><ul><li>大致观察即可发现其为递归函数，分析汇编指令画出大致流程图如下：</li></ul><p><img src="/2024/11/05/BombLab/14.png" alt="个人绘制的大致流程图"></p><ul><li>分析得到递归函数如下：<code>func4(n, x) = x + func4(n – 1, x) + func4(n – 2, x), n &gt; 1；func4(1, x) = x, func4(0, x) = 0</code>。</li><li>如果第二个输入为2，那么可以推出<code>func4(8, 2) = 108</code>，再根据函数结束后中<code>cmp 0x4(%rsp),%eax</code>可以判断返回值需要和第一个输入相等，所以一个答案为<code>108 2</code>。</li></ul><p><img src="/2024/11/05/BombLab/15.png" alt="递归树状图"></p><h3 id="第五阶段">第五阶段</h3><ul><li>同上操作，此处不再赘述，进入 <code>phase_5</code> 并得到汇编代码如下：</li></ul><p><img src="/2024/11/05/BombLab/16.png" alt="第五阶段汇编代码"></p><ul><li>同样发现其调用 <code>strings_length</code> 函数，由第一阶段分析可知，输入的字符串长度应为6。并且函数尾部调用 <code>strings_not_equal</code> 函数，比较输入字符串（<code>%rdi</code>）和目标字符串（<code>%rsi</code>）是否相等。</li><li>由 <code>0x401204 &lt;+76&gt;: mov $0x40278f,%esi</code>语句可知目标字符串的地址，打印内容可得：</li></ul><p><img src="/2024/11/05/BombLab/17.png" alt="目标字符串内容"></p><ul><li>再分析中间对字符串的操作部分。先将输入字符串存入 <code>%rbx</code> 中，然后通过指令 <code>movzbl (%rbx,%rax,1),%edx</code> 取出输入字符的第一位存到 <code>%edx</code> 中。</li></ul><p><strong>Note! <code>movzbl</code> 从源操作数读取一个 8 位值，并将其扩展到 32 位，填充高 24 位为零，然后存入目标寄存器。</strong></p><p><strong>Note! <code>(%rbx, %rax, 1)</code>是内存地址的计算方式，表示从 <code>(%rbx + %rax * 1)</code> 地址处读取一个字节的数据。其中 <code>%rbx</code> 是基地址寄存器，<code>%rax</code> 是索引寄存器，1是偏移量。</strong></p><ul><li>对于取出的字符，执行 <code>and  $0xf,%edx</code>，分析可得其作用是将其低四位保留下来，其余位清零。</li><li>接着执行<code>movzbl 0x4027e0(%rdx),%edx</code>，表示从 <code>0x4027e0 + %rdx</code> 处取出 1 字节数据扩展后存储 到 <code>%edx</code> 中，然后将 <code>%dl</code> 中的数据存储在 <code>(%rbx + %rax \* 1)</code> 处；</li><li>上述操作重复 6 次直到 <code>%rax</code> 等于 6，即字符串操作完毕。</li><li>打印 <code>0x4027e0</code>上的内容：</li></ul><p><img src="/2024/11/05/BombLab/18.png" alt="密钥内容"></p><ul><li><p>分析可得，该阶段是在 <code>0x4027e0</code> 处挑选第 <code>%rdx</code> 个字符，然后这些挑选出的字符组合成一个字符串，即目标字符串 <code>bruins</code>；</p></li><li><p>但是我们要进行的是解密操作，<code>bruins</code> 在密钥中对应的索引为 <code>13，6，3，4，8，7</code>，所以只需要输入的字符的低四位符合对应的索引即可，一个答案是 <code>MFCDHG</code> 。</p></li><li><p>简述一下<code>phase_6</code>和<code>secret_phase</code>，两者都涉及到对自定义结构体的操作，<code>phase_6</code>是对链表按照数据大小进行重排，而<code>secret_phase</code>是一个二叉搜索树。</p></li></ul><p><img src="/2024/11/05/BombLab/19.png" alt="答案汇总"></p><p><img src="/2024/11/05/BombLab/20.png" alt="通过截图"></p>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>汇编代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.4 Group 群</title>
    <link href="/2024/11/04/9.4%20Groups%20%E7%BE%A4/"/>
    <url>/2024/11/04/9.4%20Groups%20%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1><em>Inverse</em></h1><blockquote><p><em><strong>Defination:</strong></em> 令$(S, *)$是一个幺半群，$x \in S$。当$\exists y \in S, x * y = y * x = e$，则称$y$为$x$的逆元，记为$x^{-1}$。<br>单位元一定是可逆的。<br>逆元是唯一的。<br><em><strong>Prove:</strong></em> 设$(S, *)$是一个幺半群，$x \in S$可逆，若$\exists y_1,y_2$为$x$的逆元，<br>有$y_1 = y_1 * e = y_1 * (x * y_2) = (y_1 * x) * (y_2) = e * y_2 = y_2$</p></blockquote><h1><em>Group 群</em></h1><blockquote><p><em><strong>Defination1:</strong></em> 由上面引出，若$(S, *)$是一个幺半群，如果每一个元素均可逆，则$(S, *)$构成一个群。<br><em><strong>Defination2:</strong></em> 拓展半群的定义：</p><blockquote><ol><li><em><strong>Closure</strong></em> 运算封闭性；</li><li><em><strong>Associativity</strong></em> 结合律</li><li><em><strong>Identity</strong></em> 存在单位元</li><li><em><strong>Inverse</strong></em> 每个元素都有逆元<br><em><strong>引理:</strong></em> $(S, *)$是幺半群，令$G$是其所有可逆元素构成的子集，则$(G, *)$是群。<br><em><strong>Properties:</strong></em></li><li>$(a^{-1})^{-1} = a$</li><li>$(ab)^{-1} = b^{-1}a^{-1}$</li><li>$ab = ac \rightarrow b = c$（左消去律）</li><li>$ba = ca \rightarrow b = c$（右消去律）<br>事实上，群的定义可以减弱为$\textbf{ea = a}$<br><em><strong>Prove:</strong></em> $ae = aa^{-1}(a^{-1})^{-1} = e(a^{-1})^{-1} = ea$</li></ol></blockquote></blockquote><h1><em>几类特殊的群</em></h1><h2 id="Abelian-Group-阿贝尔群-交换群"><em>Abelian Group 阿贝尔群/交换群</em></h2><blockquote><p><em><strong>Defination:</strong></em> $(G, *),\forall x,y \in G, x * y = y * x$。</p></blockquote><h2 id="平凡群"><em>平凡群</em></h2><blockquote><p><em><strong>Defination:</strong></em> $({e}, *)$</p></blockquote><h2 id="General-Linear-Group-n阶一般线性群"><em>General Linear Group n阶一般线性群</em></h2><blockquote><p><em><strong>Defination:</strong></em> $n * n$阶可逆实矩阵构成的乘法群，$GL_n® = {A \in M_n®:det(A)\neq0}$</p></blockquote><h1><em>Subgroup 子群</em></h1><blockquote><p><em><strong>Defination:</strong></em> $H$是$G$的子群，记作$H &lt; G，满足：</p><blockquote><ol><li>$e \in H$</li><li>封闭性</li><li>都有逆元<br>还可以压缩为：</li><li>非空$H \subset G$</li><li>$\forall x,y \in H,ab^{-1} \in H$<br>上述也可以作为<em><strong>判定方法</strong></em>。</li></ol></blockquote></blockquote><h1><em>Homomorphism 群同态</em></h1><blockquote><p><em><strong>Defination:</strong></em> $(G, <em>),(G’,</em>‘)$ 是两个群，$f:G \rightarrow G’$是一个群同态，那么有</p><blockquote><ol><li>$f(e) = e’$；</li><li>$f(a^{-1})=(f(a))^{-1}$；</li><li>$H$是$G$的一个子群，那么$f(H) = {f(h)|h \in H}$也是$G’$的一个子群；<br><em><strong>命题:</strong></em> $det:GL_n®\rightarrow (R, <em>)$是一个乘法群同态，即行列式是一般线性群到实数乘群的一个群同态。<br>对$SL_n®={A \in GL_n®:det(A) = 1}$，显然1是$(R, <em>)$的单位元，那么，<br>$SL_n® = det^{-1}(1)=det^{-1}({1})$，翻译成人话，特殊线性群是那些映射到单位元元素的矩阵的集合，即它是实数乘群中单位元的一个原象，也是下面提到的</em></em><em>正规子群</em>**。<br><em><strong>满同态，单同态</strong></em><br><em><strong>Note!</strong></em> 单同态当且仅当$Ker(f) = {e}$，要证明群同态是单射，只需证$Ker(f) = {e}$。</li></ol></blockquote></blockquote><h2 id="Kernal-Image-核-像">Kernal, Image 核/像</h2><blockquote><p><em><strong>Defination:</strong></em> $f:G \rightarrow G’$是一个群同态，$Ker(f) = {a\in G|f(a)=e’},Im(f)=f(G)={y\in G:\exists x\in G,y = f(x)}$</p></blockquote><h2 id="同态基本定理">同态基本定理</h2><p><em><strong>Defination:</strong></em> 设$f:G \rightarrow G’$是同态，$R$是$G$上的关系且被定义为$aRb \iff f(a) = f(b)$，那么有：</p><blockquote><p>1）$R$是同余关系；<br>2）$G’$和$G/R$同构；<img src="../img/Wondershare%20PDFelement%202024-11-05%2012.08.43.png" alt=""></p></blockquote><h1><em>Isomorphism 同构</em></h1><blockquote><p><em><strong>Defination:</strong></em> 双射的同态。</p></blockquote><h1><em>Direct Product 群的直积</em></h1><blockquote><p><em><strong>Defination:</strong></em> $(x, y)*(x’,y’)=(x \circ_1 x’, y \circ_2 y’)$</p></blockquote><h1><em>Finate Group 有限群</em></h1><blockquote><p><em><strong>Defination:</strong></em> $G\space is\space Finate\space Group \iff G$是一个有限集合<br><em><strong>The Order of Group 群的阶</strong></em></p><blockquote><p><em><strong>Defination:</strong></em> 若$x \in G$，如果$\exists 最小正整数n \in N,s.t.x^n=e$，则$|G|=n$，若不存在，则$|G|=\infty$<br><em><strong>命题1:</strong></em> 有限群的每一个元素经过有限次自乘都可以得到单位元。</p></blockquote></blockquote><h1><em>Cyclic Group 循环群</em></h1><blockquote><p><em><strong>命题1:</strong></em> 令$G=<x>$是有限循环群，假设$|x| = n$，则$G = {e,x^2,……,x^n}$，其中元素是两两不同的，则称有限群$G$的阶为$n$。<br>可以用<em><strong>Cayley图</strong></em>进行可视化表示：<img src="../img/Google%20Chrome%202024-11-05%2008.56.29.png" alt=""><em><strong>命题2:</strong></em> 任意n阶循环群互相同构，无限循环群也是互相同构的。<br><em><strong>命题3:</strong></em> 任意循环群都是交换群。<br><em><strong>命题4:</strong></em> 令$G = <x>$为无限循环群，G只有两个生成元分别为$x,x^{-1}$。<br><em><strong>几类特殊的循环群:</strong></em></p><blockquote><p>$(Z, +) = &lt;1&gt;,1$或$-1$是它的生成元，无限循环群；<br><em><strong>Lagrange定理:</strong></em> 若$H$是$G$的子群，则$|H|\space |\space |G|$。</p></blockquote></blockquote><h1>Coset 陪集</h1><blockquote><p><em><strong>左陪集</strong></em></p><blockquote><p><em><strong>Defination:</strong></em> $H$是$G$的一个子群，$aH = {ah|h \in H},a \in G$，陪集一般不是子群。<br>定义$f:H \rightarrow aH,f(x)=ax$，显然是双射，则$|H|=|aH|$。<br><em><strong>命题1:</strong></em> 两个左陪集要么相等要么无交，所有陪集构成群的一个分拆。<br>可以定义为商集$G/H$<br><em><strong>右陪集</strong></em><br>如何赋予商集一个群的结构？</p></blockquote></blockquote><h1><em>Normal Group 正规子群</em></h1><blockquote><p><em><strong>Defination:</strong></em> $N&lt;G,\forall a \in G,aN = Na$，记作$H \lhd G$，此时$(G/N,\circ)$称为商群。其单位元为$eN = N$，逆元为$a^{-1}N$<br><em><strong>商群:</strong></em> 可以通过正规子群来生成商集，并定义二元运算为$(aN) \times (bN)=[a]\circ [b] = [a * b] = abN$<br>同时有函数定义为$f_R:G \rightarrow G/R, f_R(a) = aN$,则$f_R$是由$G \rightarrow G/R$的同态，一般记为$G/N$。<br><em><strong>定理:</strong></em> 设$G$的正规子群$N$，设定义在$G$上的关系$R: aRb \iff ab^{-1} \in N$，那么有：</p><blockquote><ol><li>$R$是$G$上的同余关系；</li><li>$N = [e]$；<br><em><strong>Prove:</strong></em> $证明自反性: aa^{-1}=e \in N \Rightarrow aRa$<br>$证明对称性, if\space aRb, then\space ab^{-1}\in N,由于其存在逆元，则(ab^{-1})^{-1}=ba^{-1}\Rightarrow bRa$<br>$证明传递性,if\space aRb,bRc,then\space ab^{-1},bc^{-1}\in N,由封闭性,ab^{-1}bc^{-1} = ac^{-1}\in N\Rightarrow aRc$<br>$证明同余关系,$</li></ol></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群论</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.3 Products and Quotients of Semigroups 乘积半群、商半群</title>
    <link href="/2024/11/04/9.3%20Products%20and%20Quotients%20of%20Semigroups%20%E4%B9%98%E7%A7%AF%E5%8D%8A%E7%BE%A4%E3%80%81%E5%95%86%E5%8D%8A%E7%BE%A4/"/>
    <url>/2024/11/04/9.3%20Products%20and%20Quotients%20of%20Semigroups%20%E4%B9%98%E7%A7%AF%E5%8D%8A%E7%BE%A4%E3%80%81%E5%95%86%E5%8D%8A%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1><em>Products Semigroups 积半群（半群的笛卡尔积）</em></h1><blockquote><p><em><strong>定理1:</strong></em> 两个半群的笛卡尔积也是半群。<img src="../img/Wondershare%20PDFelement%202024-11-04%2018.29.31.png" alt=""><br><em><strong>定理2:</strong></em> 类似，两个幺半群的笛卡尔积也是幺半群且其幺元为$(e_S,e_T)$。<img src="../img/Wondershare%20PDFelement%202024-11-04%2018.31.58.png" alt=""></p></blockquote><h1><em>Congruence relation 同余关系</em></h1><blockquote><p><em><strong>Defination:</strong></em> 在半群$(S,∗)$上的等价关系R，如果满足：任意$a R a’$并且$b R b’$ $\Rightarrow$ $(a∗b) R (a’∗ b’)$，则称$R$为半群上的同余关系。<br><em><strong>回忆:</strong></em> 等价关系满足自反性、对称性、传递性。<br><em><strong>解题法:</strong></em></p><blockquote><p><em><strong>Prove Step:</strong></em> R是半群上的同余关系？</p><ol><li>等价关系显然（已知给出）。</li><li>根据$a R a’$和$b R b’$可以推出 $(a∗b) R (a’∗ b’)$。<br><em><strong>Note!</strong></em> 等价关系不一定是同余关系。反例：<img src="../img/Wondershare%20PDFelement%202024-11-04%2018.53.08.png" alt=""></li></ol></blockquote></blockquote><h1>Quotients Semigroups 商半群</h1><blockquote><p><em><strong>Defination:</strong></em> <img src="../img/Wondershare%20PDFelement%202024-11-04%2019.01.38.png" alt=""><br>其实就是按照以下步骤定义了一种二元运算：</p><blockquote><ol><li>$S = {a,b,c,……,a’,b’,c’,……}$</li><li>设定价类$[a] = {a, a’,……},[b] = {b, b’,……},[c] = {c, c’,……},……$</li><li>$S/R = {[a],[b],[c],……}$</li><li>$S/R \times S/R = {([a],[a]),([a],[b]),([a],[c]),……}$</li><li>$f:S/R \times S/R \rightarrow S/R$</li><li>$f([a],[b]) = [c] \leftrightarrow [a] \otimes [b] = [c]$<br><em><strong>Note!</strong></em> 注意$\otimes$是等价类之间的运算，可以用代入等价类中的元素进行计算，即$[a] \otimes [b] = [a * b]$<br><em><strong>幺半群导出的商半群也是幺半群</strong></em> <img src="../img/Wondershare%20PDFelement%202024-11-04%2019.43.44.png" alt=""><br><em><strong>Prove:</strong></em><br>$[a] \otimes [e] = [a * e] = [a]=[e * a] = [e] \otimes [a]$</li></ol></blockquote></blockquote><h1><em>Natural Homomorphism 自然同态</em></h1><blockquote><p><em><strong>Defination:</strong></em> $f_R:S \rightarrow S/R\space defined\space by\space f_R(a) = [a]$，显然满射(onto)。<img src="../img/Wondershare%20PDFelement%202024-11-04%2019.51.57.png" alt=""></p></blockquote><h1>*Fundamental Homomorphism 同态基本定理</h1><blockquote><p><em><strong>Defination:</strong></em> 设$f:S \rightarrow T$是同态，$R$是$S$上的关系且被定义为$aRb \iff f(a) = f(b)$，那么有：<br>1）$R$是同余关系；<br>2）$T$和$S/R$同构；<img src="../img/Wondershare%20PDFelement%202024-11-04%2020.17.07.png" alt=""></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群论</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.2 Semigroups 半群、同态、同构</title>
    <link href="/2024/11/03/9.2%20Semigroups%20%E5%8D%8A%E7%BE%A4%E3%80%81%E5%90%8C%E6%80%81%E3%80%81%E5%90%8C%E6%9E%84/"/>
    <url>/2024/11/03/9.2%20Semigroups%20%E5%8D%8A%E7%BE%A4%E3%80%81%E5%90%8C%E6%80%81%E3%80%81%E5%90%8C%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1><em>Semigroups</em></h1><ul><li><em><strong>Defination</strong></em></li></ul><blockquote><p>非空集合<br>结合性（自然满足封闭性）<br>如果可交换，则为Abel半群</p></blockquote><ul><li><em><strong>自由半群</strong></em></li></ul><blockquote><p>操作符 · 是指连接运算，显然其具有结合律。<br>称 $(A^∗, · )$ 为由 A 生成的自由半群 (free semigroup generated by A)。<img src="../img/Wondershare%20PDFelement%202024-11-03%2019.35.46.png" alt=""></p></blockquote><ul><li><em><strong>Identity 单位元，幺元</strong></em></li></ul><blockquote><p>单位元若存在必唯一。<br><em><strong>Prove:</strong></em><br>假设$e, e’$都是单位元，由单位元性质可得$e = e * e’ = e’$。</p></blockquote><ul><li><em><strong>Monoid——独异点，幺半群</strong></em></li></ul><blockquote><p>半群 $(S, *)$ 中存在单位元，则称为独异点。</p></blockquote><ul><li><em><strong>定理 1 半群的卡特兰律（广义结合律）</strong></em></li></ul><blockquote><p>如果 $a_1,\ a_2,\ …,\ a_n$ 是半群的任意元素（其中 $n ≥ 3$），那么在任意元素的乘积中插入有意义的括号形成的乘积是相等的。<br><em><strong>翻译成人话就是，任意加括号都成立</strong></em><br><em><strong>引理1:</strong></em>$(x_1……x_n) * (y_1……y_n) = x_1……x_ny_1……y_n$成立<br><em><strong>Prove:</strong></em>（数学归纳法）<br>取定$n \in N$,对$n$做数学归纳：<br>1）若$m = 1$<br>$(x_1……x_n)y_1 = x_1……x_ny_1$<br>2）由$m \rightarrow m + 1$$$\begin{align}<br>(x_1……x_n) * (y_1……y_{m+1})\<br>&amp;= (x_1……x_n) * ((y_1……y_m) * y_{m + 1})\<br>&amp;= ((x_1……x_n) * (y_1……y_{m})) * y_{m + 1}\<br>&amp;= (x_1……x_ny_1……y_{m+1}) * y_{m + 1}\<br>&amp;= x_1……x_ny_1……y_{m+1}<br>\end{align}$$至于为什么要说这个，就是这个才保证了下面的定义。</p></blockquote><ul><li><em><strong>Powers of A 幂</strong></em></li></ul><blockquote><p><em><strong>Defination:</strong></em> $x^n = x^{n - 1} * x = x * x * …… *x$，规定$x^0 = e$。<br>显然，不规定也行，$x^m * x^n = x^{m+n}, \forall m,n \ge 1$是显然的，如果我们希望更完备呢？<br>$x^m * x^0 = x^m$如果成立，那么$x^0$不就等于单位元吗？<br>有了这个规定自然又得到了以下性质。</p></blockquote><ul><li><em><strong>生成半群/生成子幺半群</strong></em></li></ul><blockquote><p><em><strong>Defination:</strong></em> 设$(S, *)$是幺半群，而$A \subset S$，则$A$生成的子幺半群记作$&lt; A &gt; = \cap T,T \supset A, T &lt; S$<br>人话，$&lt; A &gt;$是所有$S$中包含了$A$的子幺半群的交集。<br>子半群和子幺半群可以按照如下方式生成。<img src="../img/Wondershare%20PDFelement%202024-11-03%2022.48.18.png" alt=""></p></blockquote><h1><em>Subsemigroup</em></h1><ul><li><em><strong>Defination</strong></em></li></ul><blockquote><p>子集<br>运算封闭（一定满足结合性）</p></blockquote><ul><li><em><strong>Submonoid——子独异点</strong></em></li></ul><blockquote><p>子集<br>运算封闭<br>幺元属于T<br><em><strong>Note! T的幺元必须和S的幺元相同</strong></em><img src="../img/Wondershare%20PDFelement%202024-11-03%2019.50.28%201.png" alt=""><br>T 是 S 的子集，并且 $(T, *)$ 同样满足独异点定义，同时 $e∈T$；<br>显然，半群$(S, *)$ 本身也是$S$的子半群；独异点$(S, *)$ 本身也是$S$的子独异点；<br>$T = {e}$一定是群$(S, *)$ 的子独异点。</p></blockquote><h1><em>Homomorphism 同态</em></h1><blockquote><p><em><strong>Defination:</strong></em> 人话，保持运算，保持特殊元素。<br>如果$S$和$T$的满足<em><strong>幺半群同态</strong></em>关系，$$<br>f:(S, ·) \rightarrow (T, *)\leftrightarrow \left{<br>\begin{aligned}<br>&amp;保持乘法，即\forall x,y \in S, f(x · y) = f(x) * f(y)\<br>&amp;保持单位元，即f(e) = e’<br>\end{aligned}<br>\right.$$直观理解如下图：<img src="../img/Wondershare%20PDFelement%202024-11-04%2012.17.01.png" alt="">人话，两个元素作运算能映射到另一个集合，另一个集合中的元素作运算也能映射回原集合</p></blockquote><h1><em>Isomorphism 同构</em></h1><blockquote><p><em><strong>Defination:</strong></em> 人话，双射，保持运算，保持特殊元素。<br>直观理解如下图：<img src="../img/Wondershare%20PDFelement%202024-11-04%2012.14.53.png" alt=""><br><em><strong>&amp;0</strong></em> 如果$S$和$T$的满足<em><strong>幺半群同构</strong></em>关系，$$<br>f:(S, ·) \rightarrow (T, <em>)\leftrightarrow \left{<br>\begin{aligned}<br>&amp;满足双射，即\forall x,y \in S,x \leftrightarrow f(x),y \leftrightarrow f(y), x · y \leftrightarrow f(x) * f(y)\<br>&amp;保持乘法，即\forall x,y \in S, f(x * y) = f(x) · f(y)\<br>&amp;保持单位元，即f(e) = e’<br>\end{aligned}<br>\right.$$</em><strong>&amp;1 恒等映射</strong>*，即$S$是自己的同构。<br><em><strong>&amp;2</strong></em> 如果 $f$ 是从 $S\rightarrow T$ 的同构，即 $f$ 是从 $S\rightarrow T$ 的<strong>一一对应</strong>的函数，那么 $f^{−1}$ 必定存在，并且 $f^{−1}$ 是从 $S\rightarrow T$ 的一一对应的函数, 且一定是同构。<br><em><strong>&amp;3</strong></em> 显然，如果$(S,∗)$有独异点，但$(T,∗)$没有独异点，那么必定不存在从 $S\rightarrow T$ 的同构 <strong>(常用于证明不存在同构)</strong><br><em><strong>$4</strong></em> 显然，同态和同构均满足像点的乘积等于乘积的像点，区别是，同构需要一一对应。</p></blockquote><h1><em>满同态</em></h1><blockquote><p><strong>定理1</strong> 如果$S$和$T$是幺半群，且幺元分别为$e,e’$，$S\rightarrow T$为满同态映射，那么有$f(e) = e’$。<br><em><strong>Prove:</strong></em> 由同态定义，$\forall a \in S,f(e · a) = f(a) * f(e) = f(a)$，但是首先需要保证$f(a) \in T$，即满射，才能成立，此时$f(e) = e’$。<br><strong>定理2</strong> 如果$S$和$T$是幺半群，且$S$为可交换半群，$S\rightarrow T$为满同态映射，那么$T$也是可交换半群。</p></blockquote><h1><em>解题法</em></h1><ul><li><em><strong>Example:</strong></em> $(S, *)$是幺半群吗？</li></ul><blockquote><p><em><strong>Prove Step:</strong></em></p><ol><li>有没有封闭性？</li><li>结合律？</li><li>有没有单位元？</li></ol></blockquote><ul><li><em><strong>Example:</strong></em> 构造同构/证明是否为同构？</li></ul><blockquote><p><em><strong>Prove Step:</strong></em></p><ol><li>(构造或直接给出)构造一个函数 $f: S\rightarrow T$ , 使得 $f$ 的定义域 $Dom (f) = S$;</li><li>证明 $f$ 是单射 (one-to-one)的，可用反证法</li><li>证明 $f$ 是满射 (onto)的 $\rightarrow$ 故而是双射的</li><li>证明 $f(a · b)=f(a)∗f(b)$<br>同态无需证明$Step2,Step3$</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群论</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.1 群论Intro</title>
    <link href="/2024/11/03/9.1%20%E7%BE%A4%E8%AE%BAIntro/"/>
    <url>/2024/11/03/9.1%20%E7%BE%A4%E8%AE%BAIntro/</url>
    
    <content type="html"><![CDATA[<h1><em>Binary operation</em></h1><blockquote><p><strong>Defination:</strong> 对两个对象进行操作的运算称为二元运算。一般在《离散数学》这门课中只研究离散结构，e.g. 集合。</p></blockquote><h1><em>Some Properties of Binary Operations</em></h1><h2 id="Closure"><em>Closure</em></h2><blockquote><p><strong>Defination:</strong> 设集合 S 有二元运算∗, 若对 S 中的任意两个元素 $a_1$、$a_2$, 都有: $a_1∗a_2∈S$, 则称运算∗对集合 S 封闭。</p></blockquote><h2 id="Commutative"><em>Commutative</em></h2><blockquote><p><strong>Defination:</strong>   交换律也称为Abel 律，设有代数 $(S,∗)$，若对任意 $a_1,a_2∈S$,都符合等式: $a_1∗a_2=a_2∗a_1$,那么称代数 $(S,∗)$ 运算符合交换律。<br><strong>推广:</strong> 如果 $(S,∗)$ 运算符合交换律，那么对于运算序列 $a_1∗a_2∗…∗a_n$，设 $θ(12…n)$ 为任意重排列，那么有:  $a_θ(1)∗a_θ(2)∗…∗a_θ(n)=a_1∗a_2∗…∗a_n$。</p></blockquote><h2 id="Associative"><em>Associative</em></h2><blockquote><p><strong>Defination:</strong> if * is a binary operation, then * is associative or has the associative property:$(x * y) * z = x * (y * z)$，在运算过程中不需要再考虑括号了！</p></blockquote><h2 id="Distributive"><em>Distributive</em></h2><blockquote><p>略。</p></blockquote><h2 id="De-Morgan‘s-laws"><em>De Morgan‘s laws</em></h2><blockquote><p>扔个PPT在这。<img src="../imgs/Wondershare%20PDFelement%202024-11-03%2017.07.25.png" alt=""></p></blockquote><h2 id="Idempotent"><em>Idempotent</em></h2><blockquote><p><strong>Defination:</strong> $a * a = a$</p></blockquote><h2 id="Note！"><em>Note！</em></h2><blockquote><p>An operation has a property means the statement of the property is true when the operation is used with any objects in the structure.</p></blockquote><h1><em>A binary operation on a set</em></h1><blockquote><p><strong>Defination:</strong> Everywhere defined $f:A×A\rightarrow A$，同时需要满足封闭性和运算结果唯一，即双射性质。</p></blockquote><h1><em>Tables(运算表)</em></h1><blockquote><p><strong>Defination:</strong> If A is a finite set, we can define a binary operation on A by means of a table.<img src="../img/Wondershare%20PDFelement%202024-11-03%2017.15.57.png" alt=""></p></blockquote><h1><em>Some Special Elements</em></h1><h2 id="Identity-中性元"><em>Identity(中性元)</em></h2><blockquote><p><strong>Defination:</strong> $e∗x=x∗e=x$</p></blockquote><h2 id="Zero-零元"><em>Zero(零元)</em></h2><blockquote><p><strong>Defination:</strong> $\theta ∗ x=x ∗ \theta= \theta$</p></blockquote><h2 id="Inverse-逆元"><em>Inverse(逆元)</em></h2><blockquote><p><strong>Defination:</strong> $x * y = y * x = e$，两者互为逆元</p></blockquote><h2 id="Note"><em>Note!</em></h2><blockquote><ol><li>单位元以及零元的唯一性</li><li>如果$\left| A \right| &gt; 1, \theta \neq e$</li><li>可结合的运算逆元唯一性</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群论</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
